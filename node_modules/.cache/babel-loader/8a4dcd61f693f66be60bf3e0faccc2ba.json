{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.removeUnderscoresHex = exports.removeUnderscoresNoHex = exports.removeUnderscoresNumeric = exports.isValidUtf16 = exports.isBoxedPrimitive = exports.isBoxedBoolean = exports.isBoxedNumber = exports.isBoxedString = exports.isByteStringWithUnderscores = exports.isByteString = exports.isPrefixlessHexString = exports.isHexString = exports.base64Length = exports.isBase64 = exports.isPlainObject = exports.isUint8ArrayLike = exports.isWrappedResult = exports.isFunctionExternalInput = exports.isContractInput = exports.isEncodingTextInput = exports.isTypeValueInput = exports.isSafeNumber = exports.minValue = exports.maxValue = exports.places = void 0;\n\nconst big_js_1 = __importDefault(require(\"big.js\"));\n\nconst Conversion = __importStar(require(\"../conversion\"));\n\nconst isBoolean_1 = __importDefault(require(\"lodash/isBoolean\")); //recognizes boolean *or* Boolean\n\n\nconst isString_1 = __importDefault(require(\"lodash/isString\")); //recognizes string *or* String\n\n\nconst isNumber_1 = __importDefault(require(\"lodash/isNumber\")); //recognizes number *or* Number\n\n\nconst utf8_1 = __importDefault(require(\"utf8\"));\n\nfunction places(dataType) {\n  switch (dataType.typeClass) {\n    case \"int\":\n    case \"uint\":\n      return 0;\n\n    case \"fixed\":\n    case \"ufixed\":\n      return dataType.places;\n  }\n}\n\nexports.places = places;\n\nfunction maxValue(dataType) {\n  let bits = dataType.bits;\n\n  if (dataType.typeClass === \"int\" || dataType.typeClass === \"fixed\") {\n    bits -= 1; //subtract 1 for signed\n  }\n\n  const maxIntegerValue = new big_js_1.default(2).pow(bits).minus(1);\n  return Conversion.shiftBigDown(maxIntegerValue, places(dataType));\n}\n\nexports.maxValue = maxValue;\n\nfunction minValue(dataType) {\n  if (dataType.typeClass === \"uint\" || dataType.typeClass === \"ufixed\") {\n    return new big_js_1.default(0);\n  }\n\n  const minIntegerValue = new big_js_1.default(0).minus(new big_js_1.default(2).pow(dataType.bits));\n  return Conversion.shiftBigDown(minIntegerValue, places(dataType));\n}\n\nexports.minValue = minValue;\n\nfunction isSafeNumber(dataType, input) {\n  const scaledUp = input * 10 ** dataType.places;\n  return Number.MIN_SAFE_INTEGER <= scaledUp && scaledUp <= Number.MAX_SAFE_INTEGER;\n}\n\nexports.isSafeNumber = isSafeNumber;\n\nfunction isTypeValueInput(input) {\n  return typeof input === \"object\" && input !== null && typeof input.type === \"string\" && \"value\" in input && Object.keys(input).length === 2;\n}\n\nexports.isTypeValueInput = isTypeValueInput;\n\nfunction isEncodingTextInput(input) {\n  return typeof input === \"object\" && input !== null && typeof input.encoding === \"string\" && typeof input.text === \"string\" && Object.keys(input).length === 2;\n}\n\nexports.isEncodingTextInput = isEncodingTextInput;\n\nfunction isContractInput(input) {\n  return (typeof input === \"object\" || typeof input === \"function\") && input !== null && typeof input.address === \"string\" && //we *don't* check anything more for addresses, we'll let the\n  //address wrapper handle that\n  !(\"selector\" in input);\n}\n\nexports.isContractInput = isContractInput;\n\nfunction isFunctionExternalInput(input) {\n  return (typeof input === \"object\" || typeof input === \"function\") && input !== null && \"address\" in input && \"selector\" in input;\n}\n\nexports.isFunctionExternalInput = isFunctionExternalInput;\n\nfunction isWrappedResult(input) {\n  return typeof input === \"object\" && input !== null && typeof input.type === \"object\" && input.type !== null && typeof input.type.typeClass === \"string\" && (input.kind === \"value\" && typeof input.value === \"object\" || input.kind === \"error\" && typeof input.error === \"object\");\n}\n\nexports.isWrappedResult = isWrappedResult;\n\nfunction isUint8ArrayLike(input) {\n  return input instanceof Uint8Array || typeof input === \"object\" && input !== null && typeof input.length === \"number\";\n}\n\nexports.isUint8ArrayLike = isUint8ArrayLike; //hack?\n\nfunction isPlainObject(input) {\n  return typeof input === \"object\" && input !== null;\n}\n\nexports.isPlainObject = isPlainObject;\n\nfunction isBase64(input) {\n  const base64Pattern = /^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{2}([A-Za-z0-9+/]|=)=)?$/; //Vim's syntax highlighting is wrong here\n\n  return Boolean(input.match(base64Pattern));\n}\n\nexports.isBase64 = isBase64;\n\nfunction base64Length(base64) {\n  const [_, endingEquals] = base64.match(/(=*)$/); //note this match always succeeds\n\n  return base64.length * 3 / 4 - endingEquals.length;\n}\n\nexports.base64Length = base64Length;\n\nfunction isHexString(input) {\n  //(with prefix, to be clear)\n  const hexStringPattern = /^0[xX][0-9a-fA-F]*$/;\n  return Boolean(input.match(hexStringPattern));\n}\n\nexports.isHexString = isHexString;\n\nfunction isPrefixlessHexString(input) {\n  const shortHexStringPattern = /^[0-9a-fA-F]*$/;\n  return Boolean(input.match(shortHexStringPattern));\n}\n\nexports.isPrefixlessHexString = isPrefixlessHexString;\n\nfunction isByteString(input) {\n  const byteStringPattern = /^0[xX]([0-9a-fA-F]{2})*$/;\n  return Boolean(input.match(byteStringPattern));\n}\n\nexports.isByteString = isByteString;\n\nfunction isByteStringWithUnderscores(input) {\n  const byteStringWithUnderscoresPattern = /^0[xX](([0-9a-fA-F]{2}_?)*([0-9a-fA-F]{2}))?$/;\n  return Boolean(input.match(byteStringWithUnderscoresPattern));\n}\n\nexports.isByteStringWithUnderscores = isByteStringWithUnderscores;\n\nfunction isBoxedString(input) {\n  //unfortunately, isString has been typed incorrectly.\n  //it should return `input is string|String`, but instead it\n  //incorrectly returns `input is string`.  As such, we have\n  //to work around its incorrect typing here.\n  return (0, isString_1.default)(input) && typeof input !== \"string\";\n}\n\nexports.isBoxedString = isBoxedString;\n\nfunction isBoxedNumber(input) {\n  //see comment on isBoxedString\n  return (0, isNumber_1.default)(input) && typeof input !== \"number\";\n}\n\nexports.isBoxedNumber = isBoxedNumber;\n\nfunction isBoxedBoolean(input) {\n  //see comment on isBoxedString\n  return (0, isBoolean_1.default)(input) && typeof input !== \"boolean\";\n}\n\nexports.isBoxedBoolean = isBoxedBoolean;\n\nfunction isBoxedPrimitive(input) {\n  return isBoxedString(input) || isBoxedNumber(input) || isBoxedBoolean(input);\n}\n\nexports.isBoxedPrimitive = isBoxedPrimitive;\n\nfunction isValidUtf16(input) {\n  try {\n    utf8_1.default.encode(input); //encode but discard :P\n\n    return true;\n  } catch (_a) {\n    return false;\n  }\n}\n\nexports.isValidUtf16 = isValidUtf16;\n\nfunction removeUnderscoresNumeric(numeric) {\n  //if it contains 0x or 0X, treat as hex;\n  //otherwise, treat as non-hex (decimal/octal/binary)\n  return numeric.match(/0x/i) ? removeUnderscoresHex(numeric) : removeUnderscoresNoHex(numeric);\n}\n\nexports.removeUnderscoresNumeric = removeUnderscoresNumeric;\n\nfunction removeUnderscoresNoHex(numeric) {\n  //this would be easy with lookbehind assertions, but those aren't safe to use\n  //in all browsers, so, we're going to have to do things a bit more\n  //manually...\n  return removeUnderscoresWithRegex(numeric, /\\d_\\d/);\n}\n\nexports.removeUnderscoresNoHex = removeUnderscoresNoHex;\n\nfunction removeUnderscoresHex(hex) {\n  //same comment\n  return removeUnderscoresWithRegex(hex, /[\\da-f]_[\\da-f]/i);\n}\n\nexports.removeUnderscoresHex = removeUnderscoresHex; //note: regex should be of the form <A>_<A>, where <A> is a regex that matches\n//precisely one character!  this will not work otherwise!\n\nfunction removeUnderscoresWithRegex(input, regex) {\n  let match;\n\n  while (match = input.match(regex)) {\n    //replace input by the same thing but w/ the underscore removed,\n    //by taking the text before and after the underscore\n    input = input.slice(0, match.index + 1) + input.slice(match.index + 2);\n  }\n\n  return input;\n}","map":{"version":3,"sources":["../../../lib/wrap/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.removeUnderscoresHex = exports.removeUnderscoresNoHex = exports.removeUnderscoresNumeric = exports.isValidUtf16 = exports.isBoxedPrimitive = exports.isBoxedBoolean = exports.isBoxedNumber = exports.isBoxedString = exports.isByteStringWithUnderscores = exports.isByteString = exports.isPrefixlessHexString = exports.isHexString = exports.base64Length = exports.isBase64 = exports.isPlainObject = exports.isUint8ArrayLike = exports.isWrappedResult = exports.isFunctionExternalInput = exports.isContractInput = exports.isEncodingTextInput = exports.isTypeValueInput = exports.isSafeNumber = exports.minValue = exports.maxValue = exports.places = void 0;\nconst big_js_1 = __importDefault(require(\"big.js\"));\nconst Conversion = __importStar(require(\"../conversion\"));\nconst isBoolean_1 = __importDefault(require(\"lodash/isBoolean\")); //recognizes boolean *or* Boolean\nconst isString_1 = __importDefault(require(\"lodash/isString\")); //recognizes string *or* String\nconst isNumber_1 = __importDefault(require(\"lodash/isNumber\")); //recognizes number *or* Number\nconst utf8_1 = __importDefault(require(\"utf8\"));\nfunction places(dataType) {\n    switch (dataType.typeClass) {\n        case \"int\":\n        case \"uint\":\n            return 0;\n        case \"fixed\":\n        case \"ufixed\":\n            return dataType.places;\n    }\n}\nexports.places = places;\nfunction maxValue(dataType) {\n    let bits = dataType.bits;\n    if (dataType.typeClass === \"int\" || dataType.typeClass === \"fixed\") {\n        bits -= 1; //subtract 1 for signed\n    }\n    const maxIntegerValue = new big_js_1.default(2).pow(bits).minus(1);\n    return Conversion.shiftBigDown(maxIntegerValue, places(dataType));\n}\nexports.maxValue = maxValue;\nfunction minValue(dataType) {\n    if (dataType.typeClass === \"uint\" || dataType.typeClass === \"ufixed\") {\n        return new big_js_1.default(0);\n    }\n    const minIntegerValue = new big_js_1.default(0).minus(new big_js_1.default(2).pow(dataType.bits));\n    return Conversion.shiftBigDown(minIntegerValue, places(dataType));\n}\nexports.minValue = minValue;\nfunction isSafeNumber(dataType, input) {\n    const scaledUp = input * 10 ** dataType.places;\n    return (Number.MIN_SAFE_INTEGER <= scaledUp && scaledUp <= Number.MAX_SAFE_INTEGER);\n}\nexports.isSafeNumber = isSafeNumber;\nfunction isTypeValueInput(input) {\n    return (typeof input === \"object\" &&\n        input !== null &&\n        typeof input.type === \"string\" &&\n        \"value\" in input &&\n        Object.keys(input).length === 2);\n}\nexports.isTypeValueInput = isTypeValueInput;\nfunction isEncodingTextInput(input) {\n    return (typeof input === \"object\" &&\n        input !== null &&\n        typeof input.encoding === \"string\" &&\n        typeof input.text === \"string\" &&\n        Object.keys(input).length === 2);\n}\nexports.isEncodingTextInput = isEncodingTextInput;\nfunction isContractInput(input) {\n    return ((typeof input === \"object\" || typeof input === \"function\") &&\n        input !== null &&\n        typeof input.address === \"string\" &&\n        //we *don't* check anything more for addresses, we'll let the\n        //address wrapper handle that\n        !(\"selector\" in input));\n}\nexports.isContractInput = isContractInput;\nfunction isFunctionExternalInput(input) {\n    return ((typeof input === \"object\" || typeof input === \"function\") &&\n        input !== null &&\n        \"address\" in input &&\n        \"selector\" in input);\n}\nexports.isFunctionExternalInput = isFunctionExternalInput;\nfunction isWrappedResult(input) {\n    return (typeof input === \"object\" &&\n        input !== null &&\n        typeof input.type === \"object\" &&\n        input.type !== null &&\n        typeof input.type.typeClass === \"string\" &&\n        ((input.kind === \"value\" && typeof input.value === \"object\") ||\n            (input.kind === \"error\" && typeof input.error === \"object\")));\n}\nexports.isWrappedResult = isWrappedResult;\nfunction isUint8ArrayLike(input) {\n    return (input instanceof Uint8Array ||\n        (typeof input === \"object\" &&\n            input !== null &&\n            typeof input.length === \"number\"));\n}\nexports.isUint8ArrayLike = isUint8ArrayLike;\n//hack?\nfunction isPlainObject(input) {\n    return typeof input === \"object\" && input !== null;\n}\nexports.isPlainObject = isPlainObject;\nfunction isBase64(input) {\n    const base64Pattern = /^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{2}([A-Za-z0-9+/]|=)=)?$/; //Vim's syntax highlighting is wrong here\n    return Boolean(input.match(base64Pattern));\n}\nexports.isBase64 = isBase64;\nfunction base64Length(base64) {\n    const [_, endingEquals] = base64.match(/(=*)$/); //note this match always succeeds\n    return (base64.length * 3) / 4 - endingEquals.length;\n}\nexports.base64Length = base64Length;\nfunction isHexString(input) {\n    //(with prefix, to be clear)\n    const hexStringPattern = /^0[xX][0-9a-fA-F]*$/;\n    return Boolean(input.match(hexStringPattern));\n}\nexports.isHexString = isHexString;\nfunction isPrefixlessHexString(input) {\n    const shortHexStringPattern = /^[0-9a-fA-F]*$/;\n    return Boolean(input.match(shortHexStringPattern));\n}\nexports.isPrefixlessHexString = isPrefixlessHexString;\nfunction isByteString(input) {\n    const byteStringPattern = /^0[xX]([0-9a-fA-F]{2})*$/;\n    return Boolean(input.match(byteStringPattern));\n}\nexports.isByteString = isByteString;\nfunction isByteStringWithUnderscores(input) {\n    const byteStringWithUnderscoresPattern = /^0[xX](([0-9a-fA-F]{2}_?)*([0-9a-fA-F]{2}))?$/;\n    return Boolean(input.match(byteStringWithUnderscoresPattern));\n}\nexports.isByteStringWithUnderscores = isByteStringWithUnderscores;\nfunction isBoxedString(input) {\n    //unfortunately, isString has been typed incorrectly.\n    //it should return `input is string|String`, but instead it\n    //incorrectly returns `input is string`.  As such, we have\n    //to work around its incorrect typing here.\n    return (0, isString_1.default)(input) && typeof input !== \"string\";\n}\nexports.isBoxedString = isBoxedString;\nfunction isBoxedNumber(input) {\n    //see comment on isBoxedString\n    return (0, isNumber_1.default)(input) && typeof input !== \"number\";\n}\nexports.isBoxedNumber = isBoxedNumber;\nfunction isBoxedBoolean(input) {\n    //see comment on isBoxedString\n    return (0, isBoolean_1.default)(input) && typeof input !== \"boolean\";\n}\nexports.isBoxedBoolean = isBoxedBoolean;\nfunction isBoxedPrimitive(input) {\n    return isBoxedString(input) || isBoxedNumber(input) || isBoxedBoolean(input);\n}\nexports.isBoxedPrimitive = isBoxedPrimitive;\nfunction isValidUtf16(input) {\n    try {\n        utf8_1.default.encode(input); //encode but discard :P\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nexports.isValidUtf16 = isValidUtf16;\nfunction removeUnderscoresNumeric(numeric) {\n    //if it contains 0x or 0X, treat as hex;\n    //otherwise, treat as non-hex (decimal/octal/binary)\n    return numeric.match(/0x/i)\n        ? removeUnderscoresHex(numeric)\n        : removeUnderscoresNoHex(numeric);\n}\nexports.removeUnderscoresNumeric = removeUnderscoresNumeric;\nfunction removeUnderscoresNoHex(numeric) {\n    //this would be easy with lookbehind assertions, but those aren't safe to use\n    //in all browsers, so, we're going to have to do things a bit more\n    //manually...\n    return removeUnderscoresWithRegex(numeric, /\\d_\\d/);\n}\nexports.removeUnderscoresNoHex = removeUnderscoresNoHex;\nfunction removeUnderscoresHex(hex) {\n    //same comment\n    return removeUnderscoresWithRegex(hex, /[\\da-f]_[\\da-f]/i);\n}\nexports.removeUnderscoresHex = removeUnderscoresHex;\n//note: regex should be of the form <A>_<A>, where <A> is a regex that matches\n//precisely one character!  this will not work otherwise!\nfunction removeUnderscoresWithRegex(input, regex) {\n    let match;\n    while ((match = input.match(regex))) {\n        //replace input by the same thing but w/ the underscore removed,\n        //by taking the text before and after the underscore\n        input = input.slice(0, match.index + 1) + input.slice(match.index + 2);\n    }\n    return input;\n}\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}