{"ast":null,"code":"import Tokenizer, { QuoteType } from \"./Tokenizer.js\";\nimport { fromCodePoint } from \"entities/lib/decode.js\";\nconst formTags = new Set([\"input\", \"option\", \"optgroup\", \"select\", \"button\", \"datalist\", \"textarea\"]);\nconst pTag = new Set([\"p\"]);\nconst tableSectionTags = new Set([\"thead\", \"tbody\"]);\nconst ddtTags = new Set([\"dd\", \"dt\"]);\nconst rtpTags = new Set([\"rt\", \"rp\"]);\nconst openImpliesClose = new Map([[\"tr\", new Set([\"tr\", \"th\", \"td\"])], [\"th\", new Set([\"th\"])], [\"td\", new Set([\"thead\", \"th\", \"td\"])], [\"body\", new Set([\"head\", \"link\", \"script\"])], [\"li\", new Set([\"li\"])], [\"p\", pTag], [\"h1\", pTag], [\"h2\", pTag], [\"h3\", pTag], [\"h4\", pTag], [\"h5\", pTag], [\"h6\", pTag], [\"select\", formTags], [\"input\", formTags], [\"output\", formTags], [\"button\", formTags], [\"datalist\", formTags], [\"textarea\", formTags], [\"option\", new Set([\"option\"])], [\"optgroup\", new Set([\"optgroup\", \"option\"])], [\"dd\", ddtTags], [\"dt\", ddtTags], [\"address\", pTag], [\"article\", pTag], [\"aside\", pTag], [\"blockquote\", pTag], [\"details\", pTag], [\"div\", pTag], [\"dl\", pTag], [\"fieldset\", pTag], [\"figcaption\", pTag], [\"figure\", pTag], [\"footer\", pTag], [\"form\", pTag], [\"header\", pTag], [\"hr\", pTag], [\"main\", pTag], [\"nav\", pTag], [\"ol\", pTag], [\"pre\", pTag], [\"section\", pTag], [\"table\", pTag], [\"ul\", pTag], [\"rt\", rtpTags], [\"rp\", rtpTags], [\"tbody\", tableSectionTags], [\"tfoot\", tableSectionTags]]);\nconst voidElements = new Set([\"area\", \"base\", \"basefont\", \"br\", \"col\", \"command\", \"embed\", \"frame\", \"hr\", \"img\", \"input\", \"isindex\", \"keygen\", \"link\", \"meta\", \"param\", \"source\", \"track\", \"wbr\"]);\nconst foreignContextElements = new Set([\"math\", \"svg\"]);\nconst htmlIntegrationElements = new Set([\"mi\", \"mo\", \"mn\", \"ms\", \"mtext\", \"annotation-xml\", \"foreignobject\", \"desc\", \"title\"]);\nconst reNameEnd = /\\s|\\//;\nexport class Parser {\n  constructor(cbs) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var _a, _b, _c, _d, _e;\n\n    this.options = options;\n    /** The start index of the last event. */\n\n    this.startIndex = 0;\n    /** The end index of the last event. */\n\n    this.endIndex = 0;\n    /**\n     * Store the start index of the current open tag,\n     * so we can update the start index for attributes.\n     */\n\n    this.openTagStart = 0;\n    this.tagname = \"\";\n    this.attribname = \"\";\n    this.attribvalue = \"\";\n    this.attribs = null;\n    this.stack = [];\n    this.foreignContext = [];\n    this.buffers = [];\n    this.bufferOffset = 0;\n    /** The index of the last written buffer. Used when resuming after a `pause()`. */\n\n    this.writeIndex = 0;\n    /** Indicates whether the parser has finished running / `.end` has been called. */\n\n    this.ended = false;\n    this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};\n    this.lowerCaseTagNames = (_a = options.lowerCaseTags) !== null && _a !== void 0 ? _a : !options.xmlMode;\n    this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;\n    this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer)(this.options, this);\n    (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);\n  } // Tokenizer event handlers\n\n  /** @internal */\n\n\n  ontext(start, endIndex) {\n    var _a, _b;\n\n    const data = this.getSlice(start, endIndex);\n    this.endIndex = endIndex - 1;\n    (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data);\n    this.startIndex = endIndex;\n  }\n  /** @internal */\n\n\n  ontextentity(cp) {\n    var _a, _b;\n    /*\n     * Entities can be emitted on the character, or directly after.\n     * We use the section start here to get accurate indices.\n     */\n\n\n    const idx = this.tokenizer.getSectionStart();\n    this.endIndex = idx - 1;\n    (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, fromCodePoint(cp));\n    this.startIndex = idx;\n  }\n\n  isVoidElement(name) {\n    return !this.options.xmlMode && voidElements.has(name);\n  }\n  /** @internal */\n\n\n  onopentagname(start, endIndex) {\n    this.endIndex = endIndex;\n    let name = this.getSlice(start, endIndex);\n\n    if (this.lowerCaseTagNames) {\n      name = name.toLowerCase();\n    }\n\n    this.emitOpenTag(name);\n  }\n\n  emitOpenTag(name) {\n    var _a, _b, _c, _d;\n\n    this.openTagStart = this.startIndex;\n    this.tagname = name;\n    const impliesClose = !this.options.xmlMode && openImpliesClose.get(name);\n\n    if (impliesClose) {\n      while (this.stack.length > 0 && impliesClose.has(this.stack[this.stack.length - 1])) {\n        const el = this.stack.pop();\n        (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, el, true);\n      }\n    }\n\n    if (!this.isVoidElement(name)) {\n      this.stack.push(name);\n\n      if (foreignContextElements.has(name)) {\n        this.foreignContext.push(true);\n      } else if (htmlIntegrationElements.has(name)) {\n        this.foreignContext.push(false);\n      }\n    }\n\n    (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name);\n    if (this.cbs.onopentag) this.attribs = {};\n  }\n\n  endOpenTag(isImplied) {\n    var _a, _b;\n\n    this.startIndex = this.openTagStart;\n\n    if (this.attribs) {\n      (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs, isImplied);\n      this.attribs = null;\n    }\n\n    if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {\n      this.cbs.onclosetag(this.tagname, true);\n    }\n\n    this.tagname = \"\";\n  }\n  /** @internal */\n\n\n  onopentagend(endIndex) {\n    this.endIndex = endIndex;\n    this.endOpenTag(false); // Set `startIndex` for next node\n\n    this.startIndex = endIndex + 1;\n  }\n  /** @internal */\n\n\n  onclosetag(start, endIndex) {\n    var _a, _b, _c, _d, _e, _f;\n\n    this.endIndex = endIndex;\n    let name = this.getSlice(start, endIndex);\n\n    if (this.lowerCaseTagNames) {\n      name = name.toLowerCase();\n    }\n\n    if (foreignContextElements.has(name) || htmlIntegrationElements.has(name)) {\n      this.foreignContext.pop();\n    }\n\n    if (!this.isVoidElement(name)) {\n      const pos = this.stack.lastIndexOf(name);\n\n      if (pos !== -1) {\n        if (this.cbs.onclosetag) {\n          let count = this.stack.length - pos;\n\n          while (count--) {\n            // We know the stack has sufficient elements.\n            this.cbs.onclosetag(this.stack.pop(), count !== 0);\n          }\n        } else this.stack.length = pos;\n      } else if (!this.options.xmlMode && name === \"p\") {\n        // Implicit open before close\n        this.emitOpenTag(\"p\");\n        this.closeCurrentTag(true);\n      }\n    } else if (!this.options.xmlMode && name === \"br\") {\n      // We can't use `emitOpenTag` for implicit open, as `br` would be implicitly closed.\n      (_b = (_a = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a, \"br\");\n      (_d = (_c = this.cbs).onopentag) === null || _d === void 0 ? void 0 : _d.call(_c, \"br\", {}, true);\n      (_f = (_e = this.cbs).onclosetag) === null || _f === void 0 ? void 0 : _f.call(_e, \"br\", false);\n    } // Set `startIndex` for next node\n\n\n    this.startIndex = endIndex + 1;\n  }\n  /** @internal */\n\n\n  onselfclosingtag(endIndex) {\n    this.endIndex = endIndex;\n\n    if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {\n      this.closeCurrentTag(false); // Set `startIndex` for next node\n\n      this.startIndex = endIndex + 1;\n    } else {\n      // Ignore the fact that the tag is self-closing.\n      this.onopentagend(endIndex);\n    }\n  }\n\n  closeCurrentTag(isOpenImplied) {\n    var _a, _b;\n\n    const name = this.tagname;\n    this.endOpenTag(isOpenImplied); // Self-closing tags will be on the top of the stack\n\n    if (this.stack[this.stack.length - 1] === name) {\n      // If the opening tag isn't implied, the closing tag has to be implied.\n      (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name, !isOpenImplied);\n      this.stack.pop();\n    }\n  }\n  /** @internal */\n\n\n  onattribname(start, endIndex) {\n    this.startIndex = start;\n    const name = this.getSlice(start, endIndex);\n    this.attribname = this.lowerCaseAttributeNames ? name.toLowerCase() : name;\n  }\n  /** @internal */\n\n\n  onattribdata(start, endIndex) {\n    this.attribvalue += this.getSlice(start, endIndex);\n  }\n  /** @internal */\n\n\n  onattribentity(cp) {\n    this.attribvalue += fromCodePoint(cp);\n  }\n  /** @internal */\n\n\n  onattribend(quote, endIndex) {\n    var _a, _b;\n\n    this.endIndex = endIndex;\n    (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote === QuoteType.Double ? '\"' : quote === QuoteType.Single ? \"'\" : quote === QuoteType.NoValue ? undefined : null);\n\n    if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {\n      this.attribs[this.attribname] = this.attribvalue;\n    }\n\n    this.attribvalue = \"\";\n  }\n\n  getInstructionName(value) {\n    const idx = value.search(reNameEnd);\n    let name = idx < 0 ? value : value.substr(0, idx);\n\n    if (this.lowerCaseTagNames) {\n      name = name.toLowerCase();\n    }\n\n    return name;\n  }\n  /** @internal */\n\n\n  ondeclaration(start, endIndex) {\n    this.endIndex = endIndex;\n    const value = this.getSlice(start, endIndex);\n\n    if (this.cbs.onprocessinginstruction) {\n      const name = this.getInstructionName(value);\n      this.cbs.onprocessinginstruction(`!${name}`, `!${value}`);\n    } // Set `startIndex` for next node\n\n\n    this.startIndex = endIndex + 1;\n  }\n  /** @internal */\n\n\n  onprocessinginstruction(start, endIndex) {\n    this.endIndex = endIndex;\n    const value = this.getSlice(start, endIndex);\n\n    if (this.cbs.onprocessinginstruction) {\n      const name = this.getInstructionName(value);\n      this.cbs.onprocessinginstruction(`?${name}`, `?${value}`);\n    } // Set `startIndex` for next node\n\n\n    this.startIndex = endIndex + 1;\n  }\n  /** @internal */\n\n\n  oncomment(start, endIndex, offset) {\n    var _a, _b, _c, _d;\n\n    this.endIndex = endIndex;\n    (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, this.getSlice(start, endIndex - offset));\n    (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c); // Set `startIndex` for next node\n\n    this.startIndex = endIndex + 1;\n  }\n  /** @internal */\n\n\n  oncdata(start, endIndex, offset) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n\n    this.endIndex = endIndex;\n    const value = this.getSlice(start, endIndex - offset);\n\n    if (this.options.xmlMode || this.options.recognizeCDATA) {\n      (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);\n      (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);\n      (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);\n    } else {\n      (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, `[CDATA[${value}]]`);\n      (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);\n    } // Set `startIndex` for next node\n\n\n    this.startIndex = endIndex + 1;\n  }\n  /** @internal */\n\n\n  onend() {\n    var _a, _b;\n\n    if (this.cbs.onclosetag) {\n      // Set the end index for all remaining tags\n      this.endIndex = this.startIndex;\n\n      for (let i = this.stack.length; i > 0; this.cbs.onclosetag(this.stack[--i], true));\n    }\n\n    (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);\n  }\n  /**\n   * Resets the parser to a blank state, ready to parse a new HTML document\n   */\n\n\n  reset() {\n    var _a, _b, _c, _d;\n\n    (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);\n    this.tokenizer.reset();\n    this.tagname = \"\";\n    this.attribname = \"\";\n    this.attribs = null;\n    this.stack.length = 0;\n    this.startIndex = 0;\n    this.endIndex = 0;\n    (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);\n    this.buffers.length = 0;\n    this.bufferOffset = 0;\n    this.writeIndex = 0;\n    this.ended = false;\n  }\n  /**\n   * Resets the parser, then parses a complete document and\n   * pushes it to the handler.\n   *\n   * @param data Document to parse.\n   */\n\n\n  parseComplete(data) {\n    this.reset();\n    this.end(data);\n  }\n\n  getSlice(start, end) {\n    while (start - this.bufferOffset >= this.buffers[0].length) {\n      this.shiftBuffer();\n    }\n\n    let str = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);\n\n    while (end - this.bufferOffset > this.buffers[0].length) {\n      this.shiftBuffer();\n      str += this.buffers[0].slice(0, end - this.bufferOffset);\n    }\n\n    return str;\n  }\n\n  shiftBuffer() {\n    this.bufferOffset += this.buffers[0].length;\n    this.writeIndex--;\n    this.buffers.shift();\n  }\n  /**\n   * Parses a chunk of data and calls the corresponding callbacks.\n   *\n   * @param chunk Chunk to parse.\n   */\n\n\n  write(chunk) {\n    var _a, _b;\n\n    if (this.ended) {\n      (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(\".write() after done!\"));\n      return;\n    }\n\n    this.buffers.push(chunk);\n\n    if (this.tokenizer.running) {\n      this.tokenizer.write(chunk);\n      this.writeIndex++;\n    }\n  }\n  /**\n   * Parses the end of the buffer and clears the stack, calls onend.\n   *\n   * @param chunk Optional final chunk to parse.\n   */\n\n\n  end(chunk) {\n    var _a, _b;\n\n    if (this.ended) {\n      (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, Error(\".end() after done!\"));\n      return;\n    }\n\n    if (chunk) this.write(chunk);\n    this.ended = true;\n    this.tokenizer.end();\n  }\n  /**\n   * Pauses parsing. The parser won't emit events until `resume` is called.\n   */\n\n\n  pause() {\n    this.tokenizer.pause();\n  }\n  /**\n   * Resumes parsing after `pause` was called.\n   */\n\n\n  resume() {\n    this.tokenizer.resume();\n\n    while (this.tokenizer.running && this.writeIndex < this.buffers.length) {\n      this.tokenizer.write(this.buffers[this.writeIndex++]);\n    }\n\n    if (this.ended) this.tokenizer.end();\n  }\n  /**\n   * Alias of `write`, for backwards compatibility.\n   *\n   * @param chunk Chunk to parse.\n   * @deprecated\n   */\n\n\n  parseChunk(chunk) {\n    this.write(chunk);\n  }\n  /**\n   * Alias of `end`, for backwards compatibility.\n   *\n   * @param chunk Optional final chunk to parse.\n   * @deprecated\n   */\n\n\n  done(chunk) {\n    this.end(chunk);\n  }\n\n}","map":{"version":3,"sources":["Parser.ts"],"names":[],"mappings":"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","sourceRoot":"https://raw.githubusercontent.com/fb55/htmlparser2/4763205746cd80120b5d2b69041197a394d24ba9/src/","sourcesContent":["import Tokenizer, { QuoteType } from \"./Tokenizer.js\";\nimport { fromCodePoint } from \"entities/lib/decode.js\";\nconst formTags = new Set([\n    \"input\",\n    \"option\",\n    \"optgroup\",\n    \"select\",\n    \"button\",\n    \"datalist\",\n    \"textarea\",\n]);\nconst pTag = new Set([\"p\"]);\nconst tableSectionTags = new Set([\"thead\", \"tbody\"]);\nconst ddtTags = new Set([\"dd\", \"dt\"]);\nconst rtpTags = new Set([\"rt\", \"rp\"]);\nconst openImpliesClose = new Map([\n    [\"tr\", new Set([\"tr\", \"th\", \"td\"])],\n    [\"th\", new Set([\"th\"])],\n    [\"td\", new Set([\"thead\", \"th\", \"td\"])],\n    [\"body\", new Set([\"head\", \"link\", \"script\"])],\n    [\"li\", new Set([\"li\"])],\n    [\"p\", pTag],\n    [\"h1\", pTag],\n    [\"h2\", pTag],\n    [\"h3\", pTag],\n    [\"h4\", pTag],\n    [\"h5\", pTag],\n    [\"h6\", pTag],\n    [\"select\", formTags],\n    [\"input\", formTags],\n    [\"output\", formTags],\n    [\"button\", formTags],\n    [\"datalist\", formTags],\n    [\"textarea\", formTags],\n    [\"option\", new Set([\"option\"])],\n    [\"optgroup\", new Set([\"optgroup\", \"option\"])],\n    [\"dd\", ddtTags],\n    [\"dt\", ddtTags],\n    [\"address\", pTag],\n    [\"article\", pTag],\n    [\"aside\", pTag],\n    [\"blockquote\", pTag],\n    [\"details\", pTag],\n    [\"div\", pTag],\n    [\"dl\", pTag],\n    [\"fieldset\", pTag],\n    [\"figcaption\", pTag],\n    [\"figure\", pTag],\n    [\"footer\", pTag],\n    [\"form\", pTag],\n    [\"header\", pTag],\n    [\"hr\", pTag],\n    [\"main\", pTag],\n    [\"nav\", pTag],\n    [\"ol\", pTag],\n    [\"pre\", pTag],\n    [\"section\", pTag],\n    [\"table\", pTag],\n    [\"ul\", pTag],\n    [\"rt\", rtpTags],\n    [\"rp\", rtpTags],\n    [\"tbody\", tableSectionTags],\n    [\"tfoot\", tableSectionTags],\n]);\nconst voidElements = new Set([\n    \"area\",\n    \"base\",\n    \"basefont\",\n    \"br\",\n    \"col\",\n    \"command\",\n    \"embed\",\n    \"frame\",\n    \"hr\",\n    \"img\",\n    \"input\",\n    \"isindex\",\n    \"keygen\",\n    \"link\",\n    \"meta\",\n    \"param\",\n    \"source\",\n    \"track\",\n    \"wbr\",\n]);\nconst foreignContextElements = new Set([\"math\", \"svg\"]);\nconst htmlIntegrationElements = new Set([\n    \"mi\",\n    \"mo\",\n    \"mn\",\n    \"ms\",\n    \"mtext\",\n    \"annotation-xml\",\n    \"foreignobject\",\n    \"desc\",\n    \"title\",\n]);\nconst reNameEnd = /\\s|\\//;\nexport class Parser {\n    constructor(cbs, options = {}) {\n        var _a, _b, _c, _d, _e;\n        this.options = options;\n        /** The start index of the last event. */\n        this.startIndex = 0;\n        /** The end index of the last event. */\n        this.endIndex = 0;\n        /**\n         * Store the start index of the current open tag,\n         * so we can update the start index for attributes.\n         */\n        this.openTagStart = 0;\n        this.tagname = \"\";\n        this.attribname = \"\";\n        this.attribvalue = \"\";\n        this.attribs = null;\n        this.stack = [];\n        this.foreignContext = [];\n        this.buffers = [];\n        this.bufferOffset = 0;\n        /** The index of the last written buffer. Used when resuming after a `pause()`. */\n        this.writeIndex = 0;\n        /** Indicates whether the parser has finished running / `.end` has been called. */\n        this.ended = false;\n        this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};\n        this.lowerCaseTagNames = (_a = options.lowerCaseTags) !== null && _a !== void 0 ? _a : !options.xmlMode;\n        this.lowerCaseAttributeNames =\n            (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;\n        this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer)(this.options, this);\n        (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);\n    }\n    // Tokenizer event handlers\n    /** @internal */\n    ontext(start, endIndex) {\n        var _a, _b;\n        const data = this.getSlice(start, endIndex);\n        this.endIndex = endIndex - 1;\n        (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data);\n        this.startIndex = endIndex;\n    }\n    /** @internal */\n    ontextentity(cp) {\n        var _a, _b;\n        /*\n         * Entities can be emitted on the character, or directly after.\n         * We use the section start here to get accurate indices.\n         */\n        const idx = this.tokenizer.getSectionStart();\n        this.endIndex = idx - 1;\n        (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, fromCodePoint(cp));\n        this.startIndex = idx;\n    }\n    isVoidElement(name) {\n        return !this.options.xmlMode && voidElements.has(name);\n    }\n    /** @internal */\n    onopentagname(start, endIndex) {\n        this.endIndex = endIndex;\n        let name = this.getSlice(start, endIndex);\n        if (this.lowerCaseTagNames) {\n            name = name.toLowerCase();\n        }\n        this.emitOpenTag(name);\n    }\n    emitOpenTag(name) {\n        var _a, _b, _c, _d;\n        this.openTagStart = this.startIndex;\n        this.tagname = name;\n        const impliesClose = !this.options.xmlMode && openImpliesClose.get(name);\n        if (impliesClose) {\n            while (this.stack.length > 0 &&\n                impliesClose.has(this.stack[this.stack.length - 1])) {\n                const el = this.stack.pop();\n                (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, el, true);\n            }\n        }\n        if (!this.isVoidElement(name)) {\n            this.stack.push(name);\n            if (foreignContextElements.has(name)) {\n                this.foreignContext.push(true);\n            }\n            else if (htmlIntegrationElements.has(name)) {\n                this.foreignContext.push(false);\n            }\n        }\n        (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name);\n        if (this.cbs.onopentag)\n            this.attribs = {};\n    }\n    endOpenTag(isImplied) {\n        var _a, _b;\n        this.startIndex = this.openTagStart;\n        if (this.attribs) {\n            (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs, isImplied);\n            this.attribs = null;\n        }\n        if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {\n            this.cbs.onclosetag(this.tagname, true);\n        }\n        this.tagname = \"\";\n    }\n    /** @internal */\n    onopentagend(endIndex) {\n        this.endIndex = endIndex;\n        this.endOpenTag(false);\n        // Set `startIndex` for next node\n        this.startIndex = endIndex + 1;\n    }\n    /** @internal */\n    onclosetag(start, endIndex) {\n        var _a, _b, _c, _d, _e, _f;\n        this.endIndex = endIndex;\n        let name = this.getSlice(start, endIndex);\n        if (this.lowerCaseTagNames) {\n            name = name.toLowerCase();\n        }\n        if (foreignContextElements.has(name) ||\n            htmlIntegrationElements.has(name)) {\n            this.foreignContext.pop();\n        }\n        if (!this.isVoidElement(name)) {\n            const pos = this.stack.lastIndexOf(name);\n            if (pos !== -1) {\n                if (this.cbs.onclosetag) {\n                    let count = this.stack.length - pos;\n                    while (count--) {\n                        // We know the stack has sufficient elements.\n                        this.cbs.onclosetag(this.stack.pop(), count !== 0);\n                    }\n                }\n                else\n                    this.stack.length = pos;\n            }\n            else if (!this.options.xmlMode && name === \"p\") {\n                // Implicit open before close\n                this.emitOpenTag(\"p\");\n                this.closeCurrentTag(true);\n            }\n        }\n        else if (!this.options.xmlMode && name === \"br\") {\n            // We can't use `emitOpenTag` for implicit open, as `br` would be implicitly closed.\n            (_b = (_a = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a, \"br\");\n            (_d = (_c = this.cbs).onopentag) === null || _d === void 0 ? void 0 : _d.call(_c, \"br\", {}, true);\n            (_f = (_e = this.cbs).onclosetag) === null || _f === void 0 ? void 0 : _f.call(_e, \"br\", false);\n        }\n        // Set `startIndex` for next node\n        this.startIndex = endIndex + 1;\n    }\n    /** @internal */\n    onselfclosingtag(endIndex) {\n        this.endIndex = endIndex;\n        if (this.options.xmlMode ||\n            this.options.recognizeSelfClosing ||\n            this.foreignContext[this.foreignContext.length - 1]) {\n            this.closeCurrentTag(false);\n            // Set `startIndex` for next node\n            this.startIndex = endIndex + 1;\n        }\n        else {\n            // Ignore the fact that the tag is self-closing.\n            this.onopentagend(endIndex);\n        }\n    }\n    closeCurrentTag(isOpenImplied) {\n        var _a, _b;\n        const name = this.tagname;\n        this.endOpenTag(isOpenImplied);\n        // Self-closing tags will be on the top of the stack\n        if (this.stack[this.stack.length - 1] === name) {\n            // If the opening tag isn't implied, the closing tag has to be implied.\n            (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name, !isOpenImplied);\n            this.stack.pop();\n        }\n    }\n    /** @internal */\n    onattribname(start, endIndex) {\n        this.startIndex = start;\n        const name = this.getSlice(start, endIndex);\n        this.attribname = this.lowerCaseAttributeNames\n            ? name.toLowerCase()\n            : name;\n    }\n    /** @internal */\n    onattribdata(start, endIndex) {\n        this.attribvalue += this.getSlice(start, endIndex);\n    }\n    /** @internal */\n    onattribentity(cp) {\n        this.attribvalue += fromCodePoint(cp);\n    }\n    /** @internal */\n    onattribend(quote, endIndex) {\n        var _a, _b;\n        this.endIndex = endIndex;\n        (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote === QuoteType.Double\n            ? '\"'\n            : quote === QuoteType.Single\n                ? \"'\"\n                : quote === QuoteType.NoValue\n                    ? undefined\n                    : null);\n        if (this.attribs &&\n            !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {\n            this.attribs[this.attribname] = this.attribvalue;\n        }\n        this.attribvalue = \"\";\n    }\n    getInstructionName(value) {\n        const idx = value.search(reNameEnd);\n        let name = idx < 0 ? value : value.substr(0, idx);\n        if (this.lowerCaseTagNames) {\n            name = name.toLowerCase();\n        }\n        return name;\n    }\n    /** @internal */\n    ondeclaration(start, endIndex) {\n        this.endIndex = endIndex;\n        const value = this.getSlice(start, endIndex);\n        if (this.cbs.onprocessinginstruction) {\n            const name = this.getInstructionName(value);\n            this.cbs.onprocessinginstruction(`!${name}`, `!${value}`);\n        }\n        // Set `startIndex` for next node\n        this.startIndex = endIndex + 1;\n    }\n    /** @internal */\n    onprocessinginstruction(start, endIndex) {\n        this.endIndex = endIndex;\n        const value = this.getSlice(start, endIndex);\n        if (this.cbs.onprocessinginstruction) {\n            const name = this.getInstructionName(value);\n            this.cbs.onprocessinginstruction(`?${name}`, `?${value}`);\n        }\n        // Set `startIndex` for next node\n        this.startIndex = endIndex + 1;\n    }\n    /** @internal */\n    oncomment(start, endIndex, offset) {\n        var _a, _b, _c, _d;\n        this.endIndex = endIndex;\n        (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, this.getSlice(start, endIndex - offset));\n        (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);\n        // Set `startIndex` for next node\n        this.startIndex = endIndex + 1;\n    }\n    /** @internal */\n    oncdata(start, endIndex, offset) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n        this.endIndex = endIndex;\n        const value = this.getSlice(start, endIndex - offset);\n        if (this.options.xmlMode || this.options.recognizeCDATA) {\n            (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);\n            (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);\n            (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);\n        }\n        else {\n            (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, `[CDATA[${value}]]`);\n            (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);\n        }\n        // Set `startIndex` for next node\n        this.startIndex = endIndex + 1;\n    }\n    /** @internal */\n    onend() {\n        var _a, _b;\n        if (this.cbs.onclosetag) {\n            // Set the end index for all remaining tags\n            this.endIndex = this.startIndex;\n            for (let i = this.stack.length; i > 0; this.cbs.onclosetag(this.stack[--i], true))\n                ;\n        }\n        (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    /**\n     * Resets the parser to a blank state, ready to parse a new HTML document\n     */\n    reset() {\n        var _a, _b, _c, _d;\n        (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);\n        this.tokenizer.reset();\n        this.tagname = \"\";\n        this.attribname = \"\";\n        this.attribs = null;\n        this.stack.length = 0;\n        this.startIndex = 0;\n        this.endIndex = 0;\n        (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);\n        this.buffers.length = 0;\n        this.bufferOffset = 0;\n        this.writeIndex = 0;\n        this.ended = false;\n    }\n    /**\n     * Resets the parser, then parses a complete document and\n     * pushes it to the handler.\n     *\n     * @param data Document to parse.\n     */\n    parseComplete(data) {\n        this.reset();\n        this.end(data);\n    }\n    getSlice(start, end) {\n        while (start - this.bufferOffset >= this.buffers[0].length) {\n            this.shiftBuffer();\n        }\n        let str = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);\n        while (end - this.bufferOffset > this.buffers[0].length) {\n            this.shiftBuffer();\n            str += this.buffers[0].slice(0, end - this.bufferOffset);\n        }\n        return str;\n    }\n    shiftBuffer() {\n        this.bufferOffset += this.buffers[0].length;\n        this.writeIndex--;\n        this.buffers.shift();\n    }\n    /**\n     * Parses a chunk of data and calls the corresponding callbacks.\n     *\n     * @param chunk Chunk to parse.\n     */\n    write(chunk) {\n        var _a, _b;\n        if (this.ended) {\n            (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(\".write() after done!\"));\n            return;\n        }\n        this.buffers.push(chunk);\n        if (this.tokenizer.running) {\n            this.tokenizer.write(chunk);\n            this.writeIndex++;\n        }\n    }\n    /**\n     * Parses the end of the buffer and clears the stack, calls onend.\n     *\n     * @param chunk Optional final chunk to parse.\n     */\n    end(chunk) {\n        var _a, _b;\n        if (this.ended) {\n            (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, Error(\".end() after done!\"));\n            return;\n        }\n        if (chunk)\n            this.write(chunk);\n        this.ended = true;\n        this.tokenizer.end();\n    }\n    /**\n     * Pauses parsing. The parser won't emit events until `resume` is called.\n     */\n    pause() {\n        this.tokenizer.pause();\n    }\n    /**\n     * Resumes parsing after `pause` was called.\n     */\n    resume() {\n        this.tokenizer.resume();\n        while (this.tokenizer.running &&\n            this.writeIndex < this.buffers.length) {\n            this.tokenizer.write(this.buffers[this.writeIndex++]);\n        }\n        if (this.ended)\n            this.tokenizer.end();\n    }\n    /**\n     * Alias of `write`, for backwards compatibility.\n     *\n     * @param chunk Chunk to parse.\n     * @deprecated\n     */\n    parseChunk(chunk) {\n        this.write(chunk);\n    }\n    /**\n     * Alias of `end`, for backwards compatibility.\n     *\n     * @param chunk Optional final chunk to parse.\n     * @deprecated\n     */\n    done(chunk) {\n        this.end(chunk);\n    }\n}\n//# sourceMappingURL=Parser.js.map"]},"metadata":{},"sourceType":"module"}