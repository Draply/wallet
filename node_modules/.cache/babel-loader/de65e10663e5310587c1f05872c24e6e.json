{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decimalCases = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"codec:wrap:decimal\");\n\nconst dispatch_1 = require(\"./dispatch\");\n\nconst errors_1 = require(\"./errors\");\n\nconst Conversion = __importStar(require(\"../conversion\"));\n\nconst Utils = __importStar(require(\"./utils\"));\n\nconst Messages = __importStar(require(\"./messages\"));\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nconst big_js_1 = __importDefault(require(\"big.js\")); //note: doesn't include UDVT case,\n//or error case\n\n\nconst decimalFromWrappedValueCases = [decimalFromCodecDecimalValue, decimalFromCodecIntegerValue, decimalFromCodecEnumValue];\nconst decimalCasesBasic = [decimalFromNumber, decimalFromString, decimalFromBoxedNumber, decimalFromBoxedString, decimalFromBigint, decimalFromBN, decimalFromBig, ...decimalFromWrappedValueCases, decimalFromCodecUdvtValue, decimalFromCodecEnumError, decimalFromOther //must go last!\n];\nexports.decimalCases = [decimalFromTypeValueInput, ...decimalCasesBasic];\n\nfunction* decimalFromBig(dataType, input, wrapOptions) {\n  if (!Conversion.isBig(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a Big\");\n  }\n\n  const asBig = input.plus(0); //clone\n\n  validate(dataType, asBig, input, wrapOptions.name);\n  return {\n    //IDK why TS is screwing up here\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asBig\n    }\n  };\n}\n\nfunction* decimalFromBN(dataType, input, wrapOptions) {\n  if (!bn_js_1.default.isBN(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a BN\");\n  }\n\n  const asBig = Conversion.toBig(input);\n  validate(dataType, asBig, input, wrapOptions.name);\n  return {\n    //IDK why TS is screwing up here\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asBig\n    }\n  };\n}\n\nfunction* decimalFromBigint(dataType, input, wrapOptions) {\n  if (typeof input !== \"bigint\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a bigint\");\n  }\n\n  const asBig = Conversion.toBig(input);\n  validate(dataType, asBig, input, wrapOptions.name);\n  return {\n    //IDK why TS is screwing up here\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asBig\n    }\n  };\n}\n\nfunction* decimalFromString(dataType, input, wrapOptions) {\n  if (typeof input !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n  }\n\n  const trimmed = input.trim(); //allow whitespace\n\n  const stripped = Utils.removeUnderscoresNoHex(trimmed);\n  let asBig;\n\n  try {\n    asBig = new big_js_1.default(stripped);\n  } catch (_a) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.nonNumericMessage);\n  }\n\n  validate(dataType, asBig, input, wrapOptions.name);\n  return {\n    //IDK why TS is screwing up here\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asBig\n    }\n  };\n}\n\nfunction* decimalFromNumber(dataType, input, wrapOptions) {\n  if (typeof input !== \"number\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a number\");\n  }\n\n  if (!Number.isFinite(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, \"Numeric value is not finite\");\n  }\n\n  if (!Utils.isSafeNumber(dataType, input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, \"Given number is outside the safe range for this data type (possible loss of precision); use a numeric string, bigint, or big number class instead\");\n  }\n\n  const asBig = new big_js_1.default(input);\n  validate(dataType, asBig, input, wrapOptions.name);\n  return {\n    //IDK why TS is screwing up here\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asBig\n    }\n  };\n}\n\nfunction* decimalFromBoxedString(dataType, input, wrapOptions) {\n  if (!Utils.isBoxedString(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a boxed string\");\n  } //unbox and try again\n\n\n  return yield* decimalFromString(dataType, input.valueOf(), wrapOptions);\n}\n\nfunction* decimalFromBoxedNumber(dataType, input, wrapOptions) {\n  if (!Utils.isBoxedNumber(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a boxed number\");\n  } //unbox and try again\n\n\n  return yield* decimalFromNumber(dataType, input.valueOf(), wrapOptions);\n}\n\nfunction* decimalFromCodecDecimalValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n\n  if (input.type.typeClass !== \"fixed\" && input.type.typeClass !== \"ufixed\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n\n  if (!wrapOptions.loose && (input.type.typeClass !== dataType.typeClass || input.type.bits !== dataType.bits || input.type.places !== dataType.places)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n\n  const asBig = input.value.asBig.plus(0); //clone\n\n  validate(dataType, asBig, input, wrapOptions.name);\n  return {\n    //IDK why TS is screwing up here\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asBig\n    }\n  };\n}\n\nfunction* decimalFromCodecIntegerValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n\n  if (input.type.typeClass !== \"int\" && input.type.typeClass !== \"uint\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n\n  if (!wrapOptions.loose) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n\n  const asBig = Conversion.toBig(input.value.asBN);\n  validate(dataType, asBig, input, wrapOptions.name);\n  return {\n    //IDK why TS is screwing up here\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asBig\n    }\n  };\n}\n\nfunction* decimalFromCodecEnumValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n\n  if (input.type.typeClass !== \"enum\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, //only specificity 1 due to EnumError case\n    Messages.errorResultMessage);\n  }\n\n  if (!wrapOptions.loose) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n\n  const asBig = Conversion.toBig(input.value.numericAsBN);\n  validate(dataType, asBig, input, wrapOptions.name);\n  return {\n    //IDK why TS is screwing up here\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asBig\n    }\n  };\n}\n\nfunction* decimalFromCodecEnumError(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n\n  if (input.type.typeClass !== \"enum\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n\n  if (input.kind !== \"error\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Wrapped result was a value rather than an error\");\n  }\n\n  if (!wrapOptions.loose) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n\n  const coercedInput = input; //only one specific kind of error will be allowed\n\n  if (coercedInput.error.kind !== \"EnumOutOfRangeError\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n\n  const asBig = Conversion.toBig(coercedInput.error.rawAsBN);\n  validate(dataType, asBig, input, wrapOptions.name);\n  return {\n    //IDK why TS is screwing up here\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asBig\n    }\n  };\n}\n\nfunction* decimalFromCodecUdvtValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n\n  if (input.type.typeClass !== \"userDefinedValueType\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.wrappedTypeMessage(input.type));\n  }\n\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, wrapOptions, decimalFromWrappedValueCases);\n}\n\nfunction* decimalFromTypeValueInput(dataType, input, wrapOptions) {\n  if (!Utils.isTypeValueInput(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n  }\n\n  if (!input.type.match(/^u?fixed(\\d+(x\\d+)?)?$/) && input.type !== \"decimal\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n  }\n\n  let bits, places;\n  let typeClass;\n\n  if (input.type === \"decimal\") {\n    //vyper's decimal type corresponds to fixed168x10\n    typeClass = \"fixed\";\n    bits = 168;\n    places = 10;\n  } else {\n    const [_0, typeClassTemporary, _2, bitsAsString, _4, placesAsString] = input.type.match(/^(u?fixed)((\\d+)(x(\\d+))?)?$/); //not all of the fields in this match are used, so we discard them into _n variables\n\n    bits = bitsAsString ? Number(bitsAsString) : 128; //defaults to 128\n\n    places = placesAsString ? Number(placesAsString) : 18; //defaults to 18\n\n    typeClass = typeClassTemporary;\n  }\n\n  if (dataType.typeClass !== typeClass || dataType.bits !== bits || dataType.places !== places) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n  } //extract value & try again, with loose option turned on\n\n\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), {\n    loose: true\n  }), decimalCasesBasic);\n}\n\nfunction* decimalFromOther(dataType, input, wrapOptions) {\n  const request = {\n    kind: \"decimal\",\n    input\n  };\n  const response = yield request;\n\n  if (response.kind !== \"decimal\") {\n    throw new errors_1.BadResponseTypeError(request, response);\n  }\n\n  if (response.value === null) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, response.partiallyRecognized ? 5 : 3, response.reason || Messages.unrecognizedNumberMessage(dataType));\n  }\n\n  const asBig = response.value.plus(0); //clone\n\n  validate(dataType, asBig, input, wrapOptions.name);\n  return {\n    //IDK why TS is screwing up here\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asBig\n    }\n  };\n}\n\nfunction validate(dataType, asBig, input, //just for errors\nname //for errors\n) {\n  if (Conversion.countDecimalPlaces(asBig) > dataType.places) {\n    throw new errors_1.TypeMismatchError(dataType, input, name, 5, Messages.tooPreciseMessage(dataType.places, Conversion.countDecimalPlaces(asBig)));\n  }\n\n  if (asBig.gt(Utils.maxValue(dataType)) || asBig.lt(Utils.minValue(dataType))) {\n    throw new errors_1.TypeMismatchError(dataType, input, name, 5, Messages.outOfRangeMessage);\n  }\n}","map":{"version":3,"sources":["../../../lib/wrap/decimal.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decimalCases = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:wrap:decimal\");\nconst dispatch_1 = require(\"./dispatch\");\nconst errors_1 = require(\"./errors\");\nconst Conversion = __importStar(require(\"../conversion\"));\nconst Utils = __importStar(require(\"./utils\"));\nconst Messages = __importStar(require(\"./messages\"));\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst big_js_1 = __importDefault(require(\"big.js\"));\n//note: doesn't include UDVT case,\n//or error case\nconst decimalFromWrappedValueCases = [\n    decimalFromCodecDecimalValue,\n    decimalFromCodecIntegerValue,\n    decimalFromCodecEnumValue\n];\nconst decimalCasesBasic = [\n    decimalFromNumber,\n    decimalFromString,\n    decimalFromBoxedNumber,\n    decimalFromBoxedString,\n    decimalFromBigint,\n    decimalFromBN,\n    decimalFromBig,\n    ...decimalFromWrappedValueCases,\n    decimalFromCodecUdvtValue,\n    decimalFromCodecEnumError,\n    decimalFromOther //must go last!\n];\nexports.decimalCases = [decimalFromTypeValueInput, ...decimalCasesBasic];\nfunction* decimalFromBig(dataType, input, wrapOptions) {\n    if (!Conversion.isBig(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a Big\");\n    }\n    const asBig = input.plus(0); //clone\n    validate(dataType, asBig, input, wrapOptions.name);\n    return {\n        //IDK why TS is screwing up here\n        type: dataType,\n        kind: \"value\",\n        value: {\n            asBig\n        }\n    };\n}\nfunction* decimalFromBN(dataType, input, wrapOptions) {\n    if (!bn_js_1.default.isBN(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a BN\");\n    }\n    const asBig = Conversion.toBig(input);\n    validate(dataType, asBig, input, wrapOptions.name);\n    return {\n        //IDK why TS is screwing up here\n        type: dataType,\n        kind: \"value\",\n        value: {\n            asBig\n        }\n    };\n}\nfunction* decimalFromBigint(dataType, input, wrapOptions) {\n    if (typeof input !== \"bigint\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a bigint\");\n    }\n    const asBig = Conversion.toBig(input);\n    validate(dataType, asBig, input, wrapOptions.name);\n    return {\n        //IDK why TS is screwing up here\n        type: dataType,\n        kind: \"value\",\n        value: {\n            asBig\n        }\n    };\n}\nfunction* decimalFromString(dataType, input, wrapOptions) {\n    if (typeof input !== \"string\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n    }\n    const trimmed = input.trim(); //allow whitespace\n    const stripped = Utils.removeUnderscoresNoHex(trimmed);\n    let asBig;\n    try {\n        asBig = new big_js_1.default(stripped);\n    }\n    catch (_a) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.nonNumericMessage);\n    }\n    validate(dataType, asBig, input, wrapOptions.name);\n    return {\n        //IDK why TS is screwing up here\n        type: dataType,\n        kind: \"value\",\n        value: {\n            asBig\n        }\n    };\n}\nfunction* decimalFromNumber(dataType, input, wrapOptions) {\n    if (typeof input !== \"number\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a number\");\n    }\n    if (!Number.isFinite(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, \"Numeric value is not finite\");\n    }\n    if (!Utils.isSafeNumber(dataType, input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, \"Given number is outside the safe range for this data type (possible loss of precision); use a numeric string, bigint, or big number class instead\");\n    }\n    const asBig = new big_js_1.default(input);\n    validate(dataType, asBig, input, wrapOptions.name);\n    return {\n        //IDK why TS is screwing up here\n        type: dataType,\n        kind: \"value\",\n        value: {\n            asBig\n        }\n    };\n}\nfunction* decimalFromBoxedString(dataType, input, wrapOptions) {\n    if (!Utils.isBoxedString(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a boxed string\");\n    }\n    //unbox and try again\n    return yield* decimalFromString(dataType, input.valueOf(), wrapOptions);\n}\nfunction* decimalFromBoxedNumber(dataType, input, wrapOptions) {\n    if (!Utils.isBoxedNumber(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a boxed number\");\n    }\n    //unbox and try again\n    return yield* decimalFromNumber(dataType, input.valueOf(), wrapOptions);\n}\nfunction* decimalFromCodecDecimalValue(dataType, input, wrapOptions) {\n    if (!Utils.isWrappedResult(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n    }\n    if (input.type.typeClass !== \"fixed\" && input.type.typeClass !== \"ufixed\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n    }\n    if (input.kind !== \"value\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n    }\n    if (!wrapOptions.loose &&\n        (input.type.typeClass !== dataType.typeClass ||\n            input.type.bits !== dataType.bits ||\n            input.type.places !== dataType.places)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n    }\n    const asBig = input.value.asBig.plus(0); //clone\n    validate(dataType, asBig, input, wrapOptions.name);\n    return {\n        //IDK why TS is screwing up here\n        type: dataType,\n        kind: \"value\",\n        value: {\n            asBig\n        }\n    };\n}\nfunction* decimalFromCodecIntegerValue(dataType, input, wrapOptions) {\n    if (!Utils.isWrappedResult(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n    }\n    if (input.type.typeClass !== \"int\" && input.type.typeClass !== \"uint\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n    }\n    if (input.kind !== \"value\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n    }\n    if (!wrapOptions.loose) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n    }\n    const asBig = Conversion.toBig(input.value.asBN);\n    validate(dataType, asBig, input, wrapOptions.name);\n    return {\n        //IDK why TS is screwing up here\n        type: dataType,\n        kind: \"value\",\n        value: {\n            asBig\n        }\n    };\n}\nfunction* decimalFromCodecEnumValue(dataType, input, wrapOptions) {\n    if (!Utils.isWrappedResult(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n    }\n    if (input.type.typeClass !== \"enum\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n    }\n    if (input.kind !== \"value\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, //only specificity 1 due to EnumError case\n        Messages.errorResultMessage);\n    }\n    if (!wrapOptions.loose) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n    }\n    const asBig = Conversion.toBig(input.value.numericAsBN);\n    validate(dataType, asBig, input, wrapOptions.name);\n    return {\n        //IDK why TS is screwing up here\n        type: dataType,\n        kind: \"value\",\n        value: {\n            asBig\n        }\n    };\n}\nfunction* decimalFromCodecEnumError(dataType, input, wrapOptions) {\n    if (!Utils.isWrappedResult(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n    }\n    if (input.type.typeClass !== \"enum\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n    }\n    if (input.kind !== \"error\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Wrapped result was a value rather than an error\");\n    }\n    if (!wrapOptions.loose) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n    }\n    const coercedInput = input;\n    //only one specific kind of error will be allowed\n    if (coercedInput.error.kind !== \"EnumOutOfRangeError\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n    }\n    const asBig = Conversion.toBig(coercedInput.error.rawAsBN);\n    validate(dataType, asBig, input, wrapOptions.name);\n    return {\n        //IDK why TS is screwing up here\n        type: dataType,\n        kind: \"value\",\n        value: {\n            asBig\n        }\n    };\n}\nfunction* decimalFromCodecUdvtValue(dataType, input, wrapOptions) {\n    if (!Utils.isWrappedResult(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n    }\n    if (input.type.typeClass !== \"userDefinedValueType\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.wrappedTypeMessage(input.type));\n    }\n    if (input.kind !== \"value\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n    }\n    return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, wrapOptions, decimalFromWrappedValueCases);\n}\nfunction* decimalFromTypeValueInput(dataType, input, wrapOptions) {\n    if (!Utils.isTypeValueInput(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n    }\n    if (!input.type.match(/^u?fixed(\\d+(x\\d+)?)?$/) && input.type !== \"decimal\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n    }\n    let bits, places;\n    let typeClass;\n    if (input.type === \"decimal\") {\n        //vyper's decimal type corresponds to fixed168x10\n        typeClass = \"fixed\";\n        bits = 168;\n        places = 10;\n    }\n    else {\n        const [_0, typeClassTemporary, _2, bitsAsString, _4, placesAsString] = input.type.match(/^(u?fixed)((\\d+)(x(\\d+))?)?$/);\n        //not all of the fields in this match are used, so we discard them into _n variables\n        bits = bitsAsString ? Number(bitsAsString) : 128; //defaults to 128\n        places = placesAsString ? Number(placesAsString) : 18; //defaults to 18\n        typeClass = typeClassTemporary;\n    }\n    if (dataType.typeClass !== typeClass ||\n        dataType.bits !== bits ||\n        dataType.places !== places) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n    }\n    //extract value & try again, with loose option turned on\n    return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), { loose: true }), decimalCasesBasic);\n}\nfunction* decimalFromOther(dataType, input, wrapOptions) {\n    const request = { kind: \"decimal\", input };\n    const response = yield request;\n    if (response.kind !== \"decimal\") {\n        throw new errors_1.BadResponseTypeError(request, response);\n    }\n    if (response.value === null) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, response.partiallyRecognized ? 5 : 3, response.reason || Messages.unrecognizedNumberMessage(dataType));\n    }\n    const asBig = response.value.plus(0); //clone\n    validate(dataType, asBig, input, wrapOptions.name);\n    return {\n        //IDK why TS is screwing up here\n        type: dataType,\n        kind: \"value\",\n        value: {\n            asBig\n        }\n    };\n}\nfunction validate(dataType, asBig, input, //just for errors\nname //for errors\n) {\n    if (Conversion.countDecimalPlaces(asBig) > dataType.places) {\n        throw new errors_1.TypeMismatchError(dataType, input, name, 5, Messages.tooPreciseMessage(dataType.places, Conversion.countDecimalPlaces(asBig)));\n    }\n    if (asBig.gt(Utils.maxValue(dataType)) ||\n        asBig.lt(Utils.minValue(dataType))) {\n        throw new errors_1.TypeMismatchError(dataType, input, name, 5, Messages.outOfRangeMessage);\n    }\n}\n//# sourceMappingURL=decimal.js.map"]},"metadata":{},"sourceType":"script"}