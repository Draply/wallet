{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.abiEntryHasStorageParameters = exports.abiEntryIsObviouslyIllTyped = exports.topicsCount = exports.definitionMatchesAbi = exports.abisMatch = exports.abiHasPayableFallback = exports.computeSelectors = exports.DEFAULT_CONSTRUCTOR_ABI = exports.abiSelector = exports.abiTupleSignature = exports.abiTypeSignature = exports.abiSignature = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"codec:abi-data:utils\");\n\nconst Ast = __importStar(require(\"../ast\"));\n\nconst abi_utils_1 = require(\"@truffle/abi-utils\");\n\nObject.defineProperty(exports, \"abiSignature\", {\n  enumerable: true,\n  get: function () {\n    return abi_utils_1.abiSignature;\n  }\n});\nObject.defineProperty(exports, \"abiTypeSignature\", {\n  enumerable: true,\n  get: function () {\n    return abi_utils_1.abiTypeSignature;\n  }\n});\nObject.defineProperty(exports, \"abiTupleSignature\", {\n  enumerable: true,\n  get: function () {\n    return abi_utils_1.abiTupleSignature;\n  }\n});\nObject.defineProperty(exports, \"abiSelector\", {\n  enumerable: true,\n  get: function () {\n    return abi_utils_1.abiSelector;\n  }\n});\nexports.DEFAULT_CONSTRUCTOR_ABI = {\n  type: \"constructor\",\n  inputs: [],\n  stateMutability: \"nonpayable\"\n}; //note the return value only includes functions!\n\nfunction computeSelectors(abi) {\n  if (abi === undefined) {\n    return undefined;\n  }\n\n  return Object.assign({}, ...abi.filter(abiEntry => abiEntry.type === \"function\").map(abiEntry => ({\n    [(0, abi_utils_1.abiSelector)(abiEntry)]: abiEntry\n  })));\n}\n\nexports.computeSelectors = computeSelectors; //does this ABI have a payable fallback (or receive) function?\n\nfunction abiHasPayableFallback(abi) {\n  if (abi === undefined) {\n    return undefined;\n  }\n\n  return abi.some(abiEntry => (abiEntry.type === \"fallback\" || abiEntry.type === \"receive\") && abiEntry.stateMutability === \"payable\");\n}\n\nexports.abiHasPayableFallback = abiHasPayableFallback; //note: undefined does not match itself :P\n\nfunction abisMatch(entry1, entry2) {\n  //we'll consider two abi entries to match if they have the same\n  //type, name (if applicable), and inputs (if applicable).\n  //since there's already a signature function, we can just use that.\n  if (!entry1 || !entry2) {\n    return false;\n  }\n\n  if (entry1.type !== entry2.type) {\n    return false;\n  }\n\n  switch (entry1.type) {\n    case \"function\":\n    case \"event\":\n    case \"error\":\n      return (0, abi_utils_1.abiSignature)(entry1) === (0, abi_utils_1.abiSignature)(entry2);\n\n    case \"constructor\":\n      return (0, abi_utils_1.abiTupleSignature)(entry1.inputs) === (0, abi_utils_1.abiTupleSignature)(entry2.inputs);\n\n    case \"fallback\":\n    case \"receive\":\n      return true;\n  }\n}\n\nexports.abisMatch = abisMatch;\n\nfunction definitionMatchesAbi(abiEntry, definition, referenceDeclarations) {\n  try {\n    return abisMatch(abiEntry, Ast.Utils.definitionToAbi(definition, referenceDeclarations));\n  } catch (_) {\n    return false; //if an exception occurs, well, that's not a match!\n  }\n}\n\nexports.definitionMatchesAbi = definitionMatchesAbi;\n\nfunction topicsCount(abiEntry) {\n  let selectorCount = abiEntry.anonymous ? 0 : 1; //if the event is not anonymous, we must account for the selector\n\n  return abiEntry.inputs.filter(_ref => {\n    let {\n      indexed\n    } = _ref;\n    return indexed;\n  }).length + selectorCount;\n}\n\nexports.topicsCount = topicsCount;\n\nfunction abiEntryIsObviouslyIllTyped(abiEntry) {\n  switch (abiEntry.type) {\n    case \"fallback\":\n    case \"receive\":\n      return false;\n\n    case \"constructor\":\n    case \"event\":\n    case \"error\":\n      return abiEntry.inputs.some(abiParameterIsObviouslyIllTyped);\n\n    case \"function\":\n      return abiEntry.inputs.some(abiParameterIsObviouslyIllTyped) || abiEntry.outputs.some(abiParameterIsObviouslyIllTyped);\n  }\n}\n\nexports.abiEntryIsObviouslyIllTyped = abiEntryIsObviouslyIllTyped;\n\nfunction abiParameterIsObviouslyIllTyped(abiParameter) {\n  const legalBaseTypeClasses = [\"uint\", \"int\", \"fixed\", \"ufixed\", \"bool\", \"address\", \"bytes\", \"string\", \"function\", \"tuple\"];\n  const baseTypeClass = abiParameter.type.match(/^([a-z]*)/)[1];\n  const baseTypeClassIsObviouslyWrong = !legalBaseTypeClasses.includes(baseTypeClass);\n\n  if (abiParameter.components) {\n    return abiParameter.components.some(abiParameterIsObviouslyIllTyped) || baseTypeClassIsObviouslyWrong;\n  } else {\n    return baseTypeClassIsObviouslyWrong;\n  }\n}\n\nfunction abiEntryHasStorageParameters(abiEntry) {\n  const isStorage = parameter => parameter.type.endsWith(\" storage\");\n\n  return abiEntry.type === \"function\" && (abiEntry.inputs.some(isStorage) || abiEntry.outputs.some(isStorage)); //Note the lack of recursion!  Storage parameters can only occur at\n  //top level so there's no need to recurse here\n  //(they can also only occur for functions)\n}\n\nexports.abiEntryHasStorageParameters = abiEntryHasStorageParameters;","map":{"version":3,"sources":["../../../lib/abi-data/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.abiEntryHasStorageParameters = exports.abiEntryIsObviouslyIllTyped = exports.topicsCount = exports.definitionMatchesAbi = exports.abisMatch = exports.abiHasPayableFallback = exports.computeSelectors = exports.DEFAULT_CONSTRUCTOR_ABI = exports.abiSelector = exports.abiTupleSignature = exports.abiTypeSignature = exports.abiSignature = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:abi-data:utils\");\nconst Ast = __importStar(require(\"../ast\"));\nconst abi_utils_1 = require(\"@truffle/abi-utils\");\nObject.defineProperty(exports, \"abiSignature\", { enumerable: true, get: function () { return abi_utils_1.abiSignature; } });\nObject.defineProperty(exports, \"abiTypeSignature\", { enumerable: true, get: function () { return abi_utils_1.abiTypeSignature; } });\nObject.defineProperty(exports, \"abiTupleSignature\", { enumerable: true, get: function () { return abi_utils_1.abiTupleSignature; } });\nObject.defineProperty(exports, \"abiSelector\", { enumerable: true, get: function () { return abi_utils_1.abiSelector; } });\nexports.DEFAULT_CONSTRUCTOR_ABI = {\n    type: \"constructor\",\n    inputs: [],\n    stateMutability: \"nonpayable\"\n};\n//note the return value only includes functions!\nfunction computeSelectors(abi) {\n    if (abi === undefined) {\n        return undefined;\n    }\n    return Object.assign({}, ...abi\n        .filter((abiEntry) => abiEntry.type === \"function\")\n        .map((abiEntry) => ({\n        [(0, abi_utils_1.abiSelector)(abiEntry)]: abiEntry\n    })));\n}\nexports.computeSelectors = computeSelectors;\n//does this ABI have a payable fallback (or receive) function?\nfunction abiHasPayableFallback(abi) {\n    if (abi === undefined) {\n        return undefined;\n    }\n    return abi.some(abiEntry => (abiEntry.type === \"fallback\" || abiEntry.type === \"receive\") &&\n        abiEntry.stateMutability === \"payable\");\n}\nexports.abiHasPayableFallback = abiHasPayableFallback;\n//note: undefined does not match itself :P\nfunction abisMatch(entry1, entry2) {\n    //we'll consider two abi entries to match if they have the same\n    //type, name (if applicable), and inputs (if applicable).\n    //since there's already a signature function, we can just use that.\n    if (!entry1 || !entry2) {\n        return false;\n    }\n    if (entry1.type !== entry2.type) {\n        return false;\n    }\n    switch (entry1.type) {\n        case \"function\":\n        case \"event\":\n        case \"error\":\n            return ((0, abi_utils_1.abiSignature)(entry1) ===\n                (0, abi_utils_1.abiSignature)(entry2));\n        case \"constructor\":\n            return ((0, abi_utils_1.abiTupleSignature)(entry1.inputs) ===\n                (0, abi_utils_1.abiTupleSignature)(entry2.inputs));\n        case \"fallback\":\n        case \"receive\":\n            return true;\n    }\n}\nexports.abisMatch = abisMatch;\nfunction definitionMatchesAbi(abiEntry, definition, referenceDeclarations) {\n    try {\n        return abisMatch(abiEntry, Ast.Utils.definitionToAbi(definition, referenceDeclarations));\n    }\n    catch (_) {\n        return false; //if an exception occurs, well, that's not a match!\n    }\n}\nexports.definitionMatchesAbi = definitionMatchesAbi;\nfunction topicsCount(abiEntry) {\n    let selectorCount = abiEntry.anonymous ? 0 : 1; //if the event is not anonymous, we must account for the selector\n    return (abiEntry.inputs.filter(({ indexed }) => indexed).length + selectorCount);\n}\nexports.topicsCount = topicsCount;\nfunction abiEntryIsObviouslyIllTyped(abiEntry) {\n    switch (abiEntry.type) {\n        case \"fallback\":\n        case \"receive\":\n            return false;\n        case \"constructor\":\n        case \"event\":\n        case \"error\":\n            return abiEntry.inputs.some(abiParameterIsObviouslyIllTyped);\n        case \"function\":\n            return (abiEntry.inputs.some(abiParameterIsObviouslyIllTyped) ||\n                abiEntry.outputs.some(abiParameterIsObviouslyIllTyped));\n    }\n}\nexports.abiEntryIsObviouslyIllTyped = abiEntryIsObviouslyIllTyped;\nfunction abiParameterIsObviouslyIllTyped(abiParameter) {\n    const legalBaseTypeClasses = [\n        \"uint\",\n        \"int\",\n        \"fixed\",\n        \"ufixed\",\n        \"bool\",\n        \"address\",\n        \"bytes\",\n        \"string\",\n        \"function\",\n        \"tuple\"\n    ];\n    const baseTypeClass = abiParameter.type.match(/^([a-z]*)/)[1];\n    const baseTypeClassIsObviouslyWrong = !legalBaseTypeClasses.includes(baseTypeClass);\n    if (abiParameter.components) {\n        return (abiParameter.components.some(abiParameterIsObviouslyIllTyped) ||\n            baseTypeClassIsObviouslyWrong);\n    }\n    else {\n        return baseTypeClassIsObviouslyWrong;\n    }\n}\nfunction abiEntryHasStorageParameters(abiEntry) {\n    const isStorage = (parameter) => parameter.type.endsWith(\" storage\");\n    return (abiEntry.type === \"function\" &&\n        (abiEntry.inputs.some(isStorage) || abiEntry.outputs.some(isStorage)));\n    //Note the lack of recursion!  Storage parameters can only occur at\n    //top level so there's no need to recurse here\n    //(they can also only occur for functions)\n}\nexports.abiEntryHasStorageParameters = abiEntryHasStorageParameters;\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}