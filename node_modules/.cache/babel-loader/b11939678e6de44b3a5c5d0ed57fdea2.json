{"ast":null,"code":"import { add64, isEqual64, isStrictlyPositive64, isStrictlySmaller64, substract64, Unit64 } from './_internals/helpers/ArrayInt64.js';\nimport { arrayInt64 } from './_internals/ArrayInt64Arbitrary.js';\nimport { doubleToIndex, indexToDouble } from './_internals/helpers/DoubleHelpers.js';\n\nfunction safeDoubleToIndex(d, constraintsLabel) {\n  if (Number.isNaN(d)) {\n    throw new Error('fc.double constraints.' + constraintsLabel + ' must be a 32-bit float');\n  }\n\n  return doubleToIndex(d);\n}\n\nfunction unmapperDoubleToIndex(value) {\n  if (typeof value !== 'number') throw new Error('Unsupported type');\n  return doubleToIndex(value);\n}\n\nexport function double() {\n  let constraints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    noDefaultInfinity = false,\n    noNaN = false,\n    min = noDefaultInfinity ? -Number.MAX_VALUE : Number.NEGATIVE_INFINITY,\n    max = noDefaultInfinity ? Number.MAX_VALUE : Number.POSITIVE_INFINITY\n  } = constraints;\n  const minIndex = safeDoubleToIndex(min, 'min');\n  const maxIndex = safeDoubleToIndex(max, 'max');\n\n  if (isStrictlySmaller64(maxIndex, minIndex)) {\n    throw new Error('fc.double constraints.min must be smaller or equal to constraints.max');\n  }\n\n  if (noNaN) {\n    return arrayInt64(minIndex, maxIndex).map(indexToDouble, unmapperDoubleToIndex);\n  }\n\n  const positiveMaxIdx = isStrictlyPositive64(maxIndex);\n  const minIndexWithNaN = positiveMaxIdx ? minIndex : substract64(minIndex, Unit64);\n  const maxIndexWithNaN = positiveMaxIdx ? add64(maxIndex, Unit64) : maxIndex;\n  return arrayInt64(minIndexWithNaN, maxIndexWithNaN).map(index => {\n    if (isStrictlySmaller64(maxIndex, index) || isStrictlySmaller64(index, minIndex)) return Number.NaN;else return indexToDouble(index);\n  }, value => {\n    if (typeof value !== 'number') throw new Error('Unsupported type');\n    if (Number.isNaN(value)) return !isEqual64(maxIndex, maxIndexWithNaN) ? maxIndexWithNaN : minIndexWithNaN;\n    return doubleToIndex(value);\n  });\n}","map":{"version":3,"sources":["U:/NFT-Mar/faucet/node_modules/fast-check/lib/esm/arbitrary/double.js"],"names":["add64","isEqual64","isStrictlyPositive64","isStrictlySmaller64","substract64","Unit64","arrayInt64","doubleToIndex","indexToDouble","safeDoubleToIndex","d","constraintsLabel","Number","isNaN","Error","unmapperDoubleToIndex","value","double","constraints","noDefaultInfinity","noNaN","min","MAX_VALUE","NEGATIVE_INFINITY","max","POSITIVE_INFINITY","minIndex","maxIndex","map","positiveMaxIdx","minIndexWithNaN","maxIndexWithNaN","index","NaN"],"mappings":"AAAA,SAASA,KAAT,EAAgBC,SAAhB,EAA2BC,oBAA3B,EAAiDC,mBAAjD,EAAsEC,WAAtE,EAAmFC,MAAnF,QAAkG,oCAAlG;AACA,SAASC,UAAT,QAA2B,qCAA3B;AACA,SAASC,aAAT,EAAwBC,aAAxB,QAA6C,uCAA7C;;AACA,SAASC,iBAAT,CAA2BC,CAA3B,EAA8BC,gBAA9B,EAAgD;AAC5C,MAAIC,MAAM,CAACC,KAAP,CAAaH,CAAb,CAAJ,EAAqB;AACjB,UAAM,IAAII,KAAJ,CAAU,2BAA2BH,gBAA3B,GAA8C,yBAAxD,CAAN;AACH;;AACD,SAAOJ,aAAa,CAACG,CAAD,CAApB;AACH;;AACD,SAASK,qBAAT,CAA+BC,KAA/B,EAAsC;AAClC,MAAI,OAAOA,KAAP,KAAiB,QAArB,EACI,MAAM,IAAIF,KAAJ,CAAU,kBAAV,CAAN;AACJ,SAAOP,aAAa,CAACS,KAAD,CAApB;AACH;;AACD,OAAO,SAASC,MAAT,GAAkC;AAAA,MAAlBC,WAAkB,uEAAJ,EAAI;AACrC,QAAM;AAAEC,IAAAA,iBAAiB,GAAG,KAAtB;AAA6BC,IAAAA,KAAK,GAAG,KAArC;AAA4CC,IAAAA,GAAG,GAAGF,iBAAiB,GAAG,CAACP,MAAM,CAACU,SAAX,GAAuBV,MAAM,CAACW,iBAAjG;AAAoHC,IAAAA,GAAG,GAAGL,iBAAiB,GAAGP,MAAM,CAACU,SAAV,GAAsBV,MAAM,CAACa;AAAxK,MAA+LP,WAArM;AACA,QAAMQ,QAAQ,GAAGjB,iBAAiB,CAACY,GAAD,EAAM,KAAN,CAAlC;AACA,QAAMM,QAAQ,GAAGlB,iBAAiB,CAACe,GAAD,EAAM,KAAN,CAAlC;;AACA,MAAIrB,mBAAmB,CAACwB,QAAD,EAAWD,QAAX,CAAvB,EAA6C;AACzC,UAAM,IAAIZ,KAAJ,CAAU,uEAAV,CAAN;AACH;;AACD,MAAIM,KAAJ,EAAW;AACP,WAAOd,UAAU,CAACoB,QAAD,EAAWC,QAAX,CAAV,CAA+BC,GAA/B,CAAmCpB,aAAnC,EAAkDO,qBAAlD,CAAP;AACH;;AACD,QAAMc,cAAc,GAAG3B,oBAAoB,CAACyB,QAAD,CAA3C;AACA,QAAMG,eAAe,GAAGD,cAAc,GAAGH,QAAH,GAActB,WAAW,CAACsB,QAAD,EAAWrB,MAAX,CAA/D;AACA,QAAM0B,eAAe,GAAGF,cAAc,GAAG7B,KAAK,CAAC2B,QAAD,EAAWtB,MAAX,CAAR,GAA6BsB,QAAnE;AACA,SAAOrB,UAAU,CAACwB,eAAD,EAAkBC,eAAlB,CAAV,CAA6CH,GAA7C,CAAkDI,KAAD,IAAW;AAC/D,QAAI7B,mBAAmB,CAACwB,QAAD,EAAWK,KAAX,CAAnB,IAAwC7B,mBAAmB,CAAC6B,KAAD,EAAQN,QAAR,CAA/D,EACI,OAAOd,MAAM,CAACqB,GAAd,CADJ,KAGI,OAAOzB,aAAa,CAACwB,KAAD,CAApB;AACP,GALM,EAKHhB,KAAD,IAAW;AACV,QAAI,OAAOA,KAAP,KAAiB,QAArB,EACI,MAAM,IAAIF,KAAJ,CAAU,kBAAV,CAAN;AACJ,QAAIF,MAAM,CAACC,KAAP,CAAaG,KAAb,CAAJ,EACI,OAAO,CAACf,SAAS,CAAC0B,QAAD,EAAWI,eAAX,CAAV,GAAwCA,eAAxC,GAA0DD,eAAjE;AACJ,WAAOvB,aAAa,CAACS,KAAD,CAApB;AACH,GAXM,CAAP;AAYH","sourcesContent":["import { add64, isEqual64, isStrictlyPositive64, isStrictlySmaller64, substract64, Unit64, } from './_internals/helpers/ArrayInt64.js';\nimport { arrayInt64 } from './_internals/ArrayInt64Arbitrary.js';\nimport { doubleToIndex, indexToDouble } from './_internals/helpers/DoubleHelpers.js';\nfunction safeDoubleToIndex(d, constraintsLabel) {\n    if (Number.isNaN(d)) {\n        throw new Error('fc.double constraints.' + constraintsLabel + ' must be a 32-bit float');\n    }\n    return doubleToIndex(d);\n}\nfunction unmapperDoubleToIndex(value) {\n    if (typeof value !== 'number')\n        throw new Error('Unsupported type');\n    return doubleToIndex(value);\n}\nexport function double(constraints = {}) {\n    const { noDefaultInfinity = false, noNaN = false, min = noDefaultInfinity ? -Number.MAX_VALUE : Number.NEGATIVE_INFINITY, max = noDefaultInfinity ? Number.MAX_VALUE : Number.POSITIVE_INFINITY, } = constraints;\n    const minIndex = safeDoubleToIndex(min, 'min');\n    const maxIndex = safeDoubleToIndex(max, 'max');\n    if (isStrictlySmaller64(maxIndex, minIndex)) {\n        throw new Error('fc.double constraints.min must be smaller or equal to constraints.max');\n    }\n    if (noNaN) {\n        return arrayInt64(minIndex, maxIndex).map(indexToDouble, unmapperDoubleToIndex);\n    }\n    const positiveMaxIdx = isStrictlyPositive64(maxIndex);\n    const minIndexWithNaN = positiveMaxIdx ? minIndex : substract64(minIndex, Unit64);\n    const maxIndexWithNaN = positiveMaxIdx ? add64(maxIndex, Unit64) : maxIndex;\n    return arrayInt64(minIndexWithNaN, maxIndexWithNaN).map((index) => {\n        if (isStrictlySmaller64(maxIndex, index) || isStrictlySmaller64(index, minIndex))\n            return Number.NaN;\n        else\n            return indexToDouble(index);\n    }, (value) => {\n        if (typeof value !== 'number')\n            throw new Error('Unsupported type');\n        if (Number.isNaN(value))\n            return !isEqual64(maxIndex, maxIndexWithNaN) ? maxIndexWithNaN : minIndexWithNaN;\n        return doubleToIndex(value);\n    });\n}\n"]},"metadata":{},"sourceType":"module"}