{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isMoreSpecific = exports.isMoreSpecificMultiple = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"codec:wrap:priority\");\n\nconst Format = __importStar(require(\"../format\"));\n\nconst utils_1 = require(\"./utils\"); //is input 1 more specific than input 2? (nonstrict)\n\n\nfunction isMoreSpecificMultiple(types1, types2, userDefinedTypes) {\n  //just wrap the types in tuples and defer to isMoreSpecific()\n  const combinedType1 = {\n    typeClass: \"tuple\",\n    memberTypes: types1\n  };\n  const combinedType2 = {\n    typeClass: \"tuple\",\n    memberTypes: types2\n  };\n  return isMoreSpecific(combinedType1, combinedType2, userDefinedTypes, true); //that last flag is so we ignore variable names at top level\n}\n\nexports.isMoreSpecificMultiple = isMoreSpecificMultiple; //is input 1 more specific than input 2?\n//(this is nonstrict)\n\nfunction isMoreSpecific(type1, type2, userDefinedTypes) {\n  let ignoreComponentNames = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  //udvts get priority of underlying type!\n  if (type1.typeClass === \"userDefinedValueType\") {\n    type1 = getUnderlyingType(type1, userDefinedTypes);\n  }\n\n  if (type2.typeClass === \"userDefinedValueType\") {\n    type2 = getUnderlyingType(type2, userDefinedTypes);\n  }\n\n  const typeClasses = [[\"options\"], [\"array\"], [\"struct\", \"tuple\"], [\"address\", \"contract\"], [\"bytes\"], [\"function\"], [\"uint\", \"int\", \"fixed\", \"ufixed\"], [\"enum\"], [\"string\"], [\"bool\"]]; //for each type, what's the first one it counts as?\n\n  const index1 = typeClasses.findIndex(classes => classes.includes(type1.typeClass));\n  const index2 = typeClasses.findIndex(classes => classes.includes(type2.typeClass)); //NOTE: I am assuming neither will be -1!\n  //If either is, something has gone very wrong!\n\n  if (index1 < index2) {\n    return true;\n  } else if (index2 < index1) {\n    return false;\n  } //otherwise, indices are equal, defer to tiebreaker\n\n\n  switch (type1.typeClass) {\n    case \"options\":\n      return isMoreSpecificOptions(type1, type2);\n\n    case \"address\":\n    case \"contract\":\n      return isMoreSpecificAddress(type1, type2);\n\n    case \"function\":\n      return isMoreSpecificFunction( //we haven't actually checked visibility, so we'll have to coerce\n      type1, type2, userDefinedTypes);\n\n    case \"array\":\n      return isMoreSpecificArray(type1, type2, userDefinedTypes);\n\n    case \"bytes\":\n      return isMoreSpecificBytes(type1, type2);\n\n    case \"uint\":\n    case \"int\":\n    case \"fixed\":\n    case \"ufixed\":\n      return isMoreSpecificNumeric(type1, type2);\n\n    case \"enum\":\n      return isMoreSpecificEnum(type1, type2);\n\n    case \"string\":\n      return isMoreSpecificString(type1, type2);\n\n    case \"struct\":\n    case \"tuple\":\n      return isMoreSpecificTuple(type1, type2, userDefinedTypes, ignoreComponentNames);\n\n    case \"bool\":\n      return isMoreSpecificBool(type1, type2);\n  }\n}\n\nexports.isMoreSpecific = isMoreSpecific;\n\nfunction isMoreSpecificAddress(type1, type2) {\n  //address payable more specific than address\n  //contract types more specific than address\n  //*payable* contract types more specific than address payable\n  if (type1.typeClass === \"address\" && type2.typeClass === \"address\") {\n    if (type1.kind === \"specific\" && type2.kind === \"specific\") {\n      return type1.payable || !type2.payable;\n    } else if (type2.kind === \"general\") {\n      //specific is more specific than general :P\n      return true;\n    }\n  }\n\n  if (type1.typeClass === \"contract\" && type2.typeClass === \"contract\") {\n    if (type1.kind === \"native\" && type2.kind === \"native\") {\n      return type1.id === type2.id;\n    } //foreign contract types will always be incomparable, I guess?\n    //(they shouldn't come up here anyway)\n\n  }\n\n  if (type1.typeClass === \"contract\" && type2.typeClass === \"address\") {\n    return type2.kind === \"general\" || type2.kind === \"specific\" && !type2.payable || type2.kind === \"specific\" && type1.payable;\n  }\n\n  return false; //otherwise\n}\n\nfunction isMoreSpecificBytes(type1, type2) {\n  //static more specific than dynamic, with shorter\n  //lengths more specific than longer ones\n  return type1.kind === \"dynamic\" && type2.kind === \"dynamic\" || type1.kind === \"static\" && type2.kind === \"dynamic\" || type1.kind === \"static\" && type2.kind === \"static\" && type1.length <= type2.length;\n}\n\nfunction isMoreSpecificNumeric(type1, type2) {\n  return (0, utils_1.maxValue)(type1).lte((0, utils_1.maxValue)(type2)) && (0, utils_1.minValue)(type1).gte((0, utils_1.minValue)(type2)) && (0, utils_1.places)(type1) <= (0, utils_1.places)(type2) && //note: I don't know whether this final bit is actually necessary\n  //since we don't actually know yet whether fixedNx0 will be legal\n  !((type1.typeClass === \"fixed\" || type1.typeClass === \"ufixed\") && (type2.typeClass === \"int\" || type2.typeClass === \"uint\"));\n}\n\nfunction isMoreSpecificEnum(type1, type2) {\n  //different enum types are incomparable\n  return type1.id === type2.id;\n}\n\nfunction isMoreSpecificString(_type1, _type2) {\n  //only one string type\n  return true;\n}\n\nfunction isMoreSpecificArray(type1, type2, userDefinedTypes) {\n  //static is more specific than dynamic, but\n  //different static lengths are incomparable\n  const moreSpecificLength = type1.kind === \"dynamic\" && type2.kind === \"dynamic\" || type1.kind === \"static\" && type2.kind === \"dynamic\" || type1.kind === \"static\" && type2.kind === \"static\" && type1.length.eq(type2.length); //length and types must both be more specific\n\n  return moreSpecificLength && isMoreSpecific(type1.baseType, type2.baseType, userDefinedTypes);\n}\n\nfunction isMoreSpecificFunction(type1, type2, userDefinedTypes) {\n  switch (type2.kind) {\n    case \"general\":\n      return true;\n\n    case \"specific\":\n      switch (type1.kind) {\n        case \"general\":\n          return false;\n\n        case \"specific\":\n          //now: if they're both specific...\n          //(this case doesn't really matter, but let's do it anyway)\n          if (!isMutabilityMoreSpecific(type1.mutability, type2.mutability)) {\n            return false;\n          }\n\n          if (type1.outputParameterTypes.length !== type2.outputParameterTypes.length) {\n            return false;\n          }\n\n          for (let i = 0; i < type1.outputParameterTypes.length; i++) {\n            if (!isMoreSpecific(type1.outputParameterTypes[i], type2.outputParameterTypes[i], userDefinedTypes)) {\n              return false;\n            }\n          }\n\n          if (type1.inputParameterTypes.length !== type2.inputParameterTypes.length) {\n            return false;\n          }\n\n          for (let i = 0; i < type1.inputParameterTypes.length; i++) {\n            if (!isMoreSpecific( //swapped for contravariance, I guess...?\n            type2.inputParameterTypes[i], type1.inputParameterTypes[i], userDefinedTypes)) {\n              return false;\n            }\n          }\n\n          return true;\n      }\n\n  }\n}\n\nfunction isMutabilityMoreSpecific(mutability1, mutability2) {\n  //pure <= view <= nonpayable, payable <= nonpayable\n  return mutability1 === mutability2 || mutability1 === \"pure\" && mutability2 !== \"payable\" || mutability2 === \"nonpayable\";\n}\n\nfunction isMoreSpecificTuple(type1, type2, userDefinedTypes) {\n  let ignoreComponentNames = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  debug(\"type1: %O\", type1);\n  debug(\"type2: %O\", type2);\n  const fullType1 = Format.Types.fullType(type1, userDefinedTypes);\n  const fullType2 = Format.Types.fullType(type2, userDefinedTypes);\n  const types1 = fullType1.memberTypes.map(member => member.type);\n  const types2 = fullType2.memberTypes.map(member => member.type); //lengths must match\n\n  if (types1.length !== types2.length) {\n    return false;\n  } //individual types must satisfy isMoreSpecific\n\n\n  for (let i = 0; i < types1.length; i++) {\n    //note we do *not* pass along the ignoreComponentNames flag\n    if (!isMoreSpecific(types1[i], types2[i], userDefinedTypes)) {\n      return false;\n    }\n  }\n\n  if (!ignoreComponentNames) {\n    debug(\"checking by name\"); //if this flag is not set, *and* the component names match,\n    //(and all exist)\n    //then compare by component names in addition to by position\n\n    let names1 = fullType1.memberTypes.map(member => member.name);\n    let names2 = fullType2.memberTypes.map(member => member.name); //we just created these via a map so it's OK to sort in-place\n\n    names1.sort();\n    names2.sort();\n    let namesEqual = true;\n\n    for (let i = 0; i < names1.length; i++) {\n      if (!names1[i] || !names2[i] || names1[i] !== names2[i]) {\n        namesEqual = false;\n        break;\n      }\n    }\n\n    if (namesEqual) {\n      debug(\"names equal\");\n\n      for (let i = 0; i < types1.length; i++) {\n        const type1 = types1[i];\n        const name = fullType1.memberTypes[i].name;\n        const type2 = fullType2.memberTypes.find(_ref => {\n          let {\n            name: name2\n          } = _ref;\n          return name2 === name;\n        }).type;\n        debug(\"name: %s\", name);\n        debug(\"type1: %O\", type1);\n        debug(\"type2: %O\", type2);\n\n        if (!isMoreSpecific(type1, type2, userDefinedTypes)) {\n          debug(\"returning false\");\n          return false;\n        }\n      }\n\n      debug(\"name check ok\");\n    }\n  }\n\n  return true; //I was going to make structs more specific than their underlying\n  //tuples, and different equivalent structs incomparable, but I\n  //couldn't find a good way to do that, so whatever, they're all\n  //just equivalent, it won't come up\n}\n\nfunction isMoreSpecificOptions(_type1, _type2) {\n  //only one options type\n  return true;\n}\n\nfunction isMoreSpecificBool(_type1, _type2) {\n  //only one boolean type\n  return true;\n}\n\nfunction getUnderlyingType(udvtType, userDefinedTypes) {\n  return Format.Types.fullType(udvtType, userDefinedTypes).underlyingType;\n}","map":{"version":3,"sources":["../../../lib/wrap/priority.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isMoreSpecific = exports.isMoreSpecificMultiple = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:wrap:priority\");\nconst Format = __importStar(require(\"../format\"));\nconst utils_1 = require(\"./utils\");\n//is input 1 more specific than input 2? (nonstrict)\nfunction isMoreSpecificMultiple(types1, types2, userDefinedTypes) {\n    //just wrap the types in tuples and defer to isMoreSpecific()\n    const combinedType1 = {\n        typeClass: \"tuple\",\n        memberTypes: types1\n    };\n    const combinedType2 = {\n        typeClass: \"tuple\",\n        memberTypes: types2\n    };\n    return isMoreSpecific(combinedType1, combinedType2, userDefinedTypes, true);\n    //that last flag is so we ignore variable names at top level\n}\nexports.isMoreSpecificMultiple = isMoreSpecificMultiple;\n//is input 1 more specific than input 2?\n//(this is nonstrict)\nfunction isMoreSpecific(type1, type2, userDefinedTypes, ignoreComponentNames = false //this flag is *not* applied recursively!\n) {\n    //udvts get priority of underlying type!\n    if (type1.typeClass === \"userDefinedValueType\") {\n        type1 = getUnderlyingType(type1, userDefinedTypes);\n    }\n    if (type2.typeClass === \"userDefinedValueType\") {\n        type2 = getUnderlyingType(type2, userDefinedTypes);\n    }\n    const typeClasses = [\n        [\"options\"],\n        [\"array\"],\n        [\"struct\", \"tuple\"],\n        [\"address\", \"contract\"],\n        [\"bytes\"],\n        [\"function\"],\n        [\"uint\", \"int\", \"fixed\", \"ufixed\"],\n        [\"enum\"],\n        [\"string\"],\n        [\"bool\"]\n    ];\n    //for each type, what's the first one it counts as?\n    const index1 = typeClasses.findIndex(classes => classes.includes(type1.typeClass));\n    const index2 = typeClasses.findIndex(classes => classes.includes(type2.typeClass));\n    //NOTE: I am assuming neither will be -1!\n    //If either is, something has gone very wrong!\n    if (index1 < index2) {\n        return true;\n    }\n    else if (index2 < index1) {\n        return false;\n    }\n    //otherwise, indices are equal, defer to tiebreaker\n    switch (type1.typeClass) {\n        case \"options\":\n            return isMoreSpecificOptions(type1, type2);\n        case \"address\":\n        case \"contract\":\n            return isMoreSpecificAddress(type1, type2);\n        case \"function\":\n            return isMoreSpecificFunction(\n            //we haven't actually checked visibility, so we'll have to coerce\n            type1, type2, userDefinedTypes);\n        case \"array\":\n            return isMoreSpecificArray(type1, type2, userDefinedTypes);\n        case \"bytes\":\n            return isMoreSpecificBytes(type1, type2);\n        case \"uint\":\n        case \"int\":\n        case \"fixed\":\n        case \"ufixed\":\n            return isMoreSpecificNumeric(type1, type2);\n        case \"enum\":\n            return isMoreSpecificEnum(type1, type2);\n        case \"string\":\n            return isMoreSpecificString(type1, type2);\n        case \"struct\":\n        case \"tuple\":\n            return isMoreSpecificTuple(type1, type2, userDefinedTypes, ignoreComponentNames);\n        case \"bool\":\n            return isMoreSpecificBool(type1, type2);\n    }\n}\nexports.isMoreSpecific = isMoreSpecific;\nfunction isMoreSpecificAddress(type1, type2) {\n    //address payable more specific than address\n    //contract types more specific than address\n    //*payable* contract types more specific than address payable\n    if (type1.typeClass === \"address\" && type2.typeClass === \"address\") {\n        if (type1.kind === \"specific\" && type2.kind === \"specific\") {\n            return type1.payable || !type2.payable;\n        }\n        else if (type2.kind === \"general\") {\n            //specific is more specific than general :P\n            return true;\n        }\n    }\n    if (type1.typeClass === \"contract\" && type2.typeClass === \"contract\") {\n        if (type1.kind === \"native\" && type2.kind === \"native\") {\n            return type1.id === type2.id;\n        } //foreign contract types will always be incomparable, I guess?\n        //(they shouldn't come up here anyway)\n    }\n    if (type1.typeClass === \"contract\" && type2.typeClass === \"address\") {\n        return (type2.kind === \"general\" ||\n            (type2.kind === \"specific\" && !type2.payable) ||\n            (type2.kind === \"specific\" && type1.payable));\n    }\n    return false; //otherwise\n}\nfunction isMoreSpecificBytes(type1, type2) {\n    //static more specific than dynamic, with shorter\n    //lengths more specific than longer ones\n    return ((type1.kind === \"dynamic\" && type2.kind === \"dynamic\") ||\n        (type1.kind === \"static\" && type2.kind === \"dynamic\") ||\n        (type1.kind === \"static\" &&\n            type2.kind === \"static\" &&\n            type1.length <= type2.length));\n}\nfunction isMoreSpecificNumeric(type1, type2) {\n    return ((0, utils_1.maxValue)(type1).lte((0, utils_1.maxValue)(type2)) &&\n        (0, utils_1.minValue)(type1).gte((0, utils_1.minValue)(type2)) &&\n        (0, utils_1.places)(type1) <= (0, utils_1.places)(type2) &&\n        //note: I don't know whether this final bit is actually necessary\n        //since we don't actually know yet whether fixedNx0 will be legal\n        !((type1.typeClass === \"fixed\" || type1.typeClass === \"ufixed\") &&\n            (type2.typeClass === \"int\" || type2.typeClass === \"uint\")));\n}\nfunction isMoreSpecificEnum(type1, type2) {\n    //different enum types are incomparable\n    return type1.id === type2.id;\n}\nfunction isMoreSpecificString(_type1, _type2) {\n    //only one string type\n    return true;\n}\nfunction isMoreSpecificArray(type1, type2, userDefinedTypes) {\n    //static is more specific than dynamic, but\n    //different static lengths are incomparable\n    const moreSpecificLength = (type1.kind === \"dynamic\" && type2.kind === \"dynamic\") ||\n        (type1.kind === \"static\" && type2.kind === \"dynamic\") ||\n        (type1.kind === \"static\" &&\n            type2.kind === \"static\" &&\n            type1.length.eq(type2.length));\n    //length and types must both be more specific\n    return (moreSpecificLength &&\n        isMoreSpecific(type1.baseType, type2.baseType, userDefinedTypes));\n}\nfunction isMoreSpecificFunction(type1, type2, userDefinedTypes) {\n    switch (type2.kind) {\n        case \"general\":\n            return true;\n        case \"specific\":\n            switch (type1.kind) {\n                case \"general\":\n                    return false;\n                case \"specific\":\n                    //now: if they're both specific...\n                    //(this case doesn't really matter, but let's do it anyway)\n                    if (!isMutabilityMoreSpecific(type1.mutability, type2.mutability)) {\n                        return false;\n                    }\n                    if (type1.outputParameterTypes.length !==\n                        type2.outputParameterTypes.length) {\n                        return false;\n                    }\n                    for (let i = 0; i < type1.outputParameterTypes.length; i++) {\n                        if (!isMoreSpecific(type1.outputParameterTypes[i], type2.outputParameterTypes[i], userDefinedTypes)) {\n                            return false;\n                        }\n                    }\n                    if (type1.inputParameterTypes.length !==\n                        type2.inputParameterTypes.length) {\n                        return false;\n                    }\n                    for (let i = 0; i < type1.inputParameterTypes.length; i++) {\n                        if (!isMoreSpecific(\n                        //swapped for contravariance, I guess...?\n                        type2.inputParameterTypes[i], type1.inputParameterTypes[i], userDefinedTypes)) {\n                            return false;\n                        }\n                    }\n                    return true;\n            }\n    }\n}\nfunction isMutabilityMoreSpecific(mutability1, mutability2) {\n    //pure <= view <= nonpayable, payable <= nonpayable\n    return (mutability1 === mutability2 ||\n        (mutability1 === \"pure\" && mutability2 !== \"payable\") ||\n        mutability2 === \"nonpayable\");\n}\nfunction isMoreSpecificTuple(type1, type2, userDefinedTypes, ignoreComponentNames = false) {\n    debug(\"type1: %O\", type1);\n    debug(\"type2: %O\", type2);\n    const fullType1 = Format.Types.fullType(type1, userDefinedTypes);\n    const fullType2 = Format.Types.fullType(type2, userDefinedTypes);\n    const types1 = (fullType1.memberTypes).map(member => member.type);\n    const types2 = (fullType2.memberTypes).map(member => member.type);\n    //lengths must match\n    if (types1.length !== types2.length) {\n        return false;\n    }\n    //individual types must satisfy isMoreSpecific\n    for (let i = 0; i < types1.length; i++) {\n        //note we do *not* pass along the ignoreComponentNames flag\n        if (!isMoreSpecific(types1[i], types2[i], userDefinedTypes)) {\n            return false;\n        }\n    }\n    if (!ignoreComponentNames) {\n        debug(\"checking by name\");\n        //if this flag is not set, *and* the component names match,\n        //(and all exist)\n        //then compare by component names in addition to by position\n        let names1 = (fullType1.memberTypes).map(member => member.name);\n        let names2 = (fullType2.memberTypes).map(member => member.name);\n        //we just created these via a map so it's OK to sort in-place\n        names1.sort();\n        names2.sort();\n        let namesEqual = true;\n        for (let i = 0; i < names1.length; i++) {\n            if (!names1[i] || !names2[i] || names1[i] !== names2[i]) {\n                namesEqual = false;\n                break;\n            }\n        }\n        if (namesEqual) {\n            debug(\"names equal\");\n            for (let i = 0; i < types1.length; i++) {\n                const type1 = types1[i];\n                const name = fullType1.memberTypes[i].name;\n                const type2 = fullType2.memberTypes.find(({ name: name2 }) => name2 === name).type;\n                debug(\"name: %s\", name);\n                debug(\"type1: %O\", type1);\n                debug(\"type2: %O\", type2);\n                if (!isMoreSpecific(type1, type2, userDefinedTypes)) {\n                    debug(\"returning false\");\n                    return false;\n                }\n            }\n            debug(\"name check ok\");\n        }\n    }\n    return true;\n    //I was going to make structs more specific than their underlying\n    //tuples, and different equivalent structs incomparable, but I\n    //couldn't find a good way to do that, so whatever, they're all\n    //just equivalent, it won't come up\n}\nfunction isMoreSpecificOptions(_type1, _type2) {\n    //only one options type\n    return true;\n}\nfunction isMoreSpecificBool(_type1, _type2) {\n    //only one boolean type\n    return true;\n}\nfunction getUnderlyingType(udvtType, userDefinedTypes) {\n    return (Format.Types.fullType(udvtType, userDefinedTypes)).underlyingType;\n}\n//# sourceMappingURL=priority.js.map"]},"metadata":{},"sourceType":"script"}