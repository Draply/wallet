{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.functionExternalCases = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"codec:wrap:function\");\n\nconst dispatch_1 = require(\"./dispatch\");\n\nconst errors_1 = require(\"./errors\");\n\nconst Messages = __importStar(require(\"./messages\"));\n\nconst Utils = __importStar(require(\"./utils\"));\n\nconst EvmUtils = __importStar(require(\"../evm/utils\"));\n\nconst web3_utils_1 = __importDefault(require(\"web3-utils\"));\n\nconst address_1 = require(\"./address\");\n\nconst bytes_1 = require(\"./bytes\");\n\nconst functionExternalCasesBasic = [functionFromFunctionExternalInput, functionFromHexString, functionFromCodecFunctionExternalValue, functionFailureCase];\nexports.functionExternalCases = [functionFromTypeValueInput, ...functionExternalCasesBasic];\n\nfunction* functionFromFunctionExternalInput(dataType, input, wrapOptions) {\n  if (!Utils.isFunctionExternalInput(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not an object with address & selector\");\n  }\n\n  const wrappedAddress = yield* (0, dispatch_1.wrapWithCases)({\n    typeClass: \"address\",\n    kind: \"general\"\n  }, input.address, Object.assign(Object.assign({}, wrapOptions), {\n    name: `${wrapOptions.name}.address`,\n    specificityFloor: 5\n  }), address_1.addressCases);\n  const address = wrappedAddress.value.asAddress;\n  const wrappedSelector = yield* (0, dispatch_1.wrapWithCases)({\n    typeClass: \"bytes\",\n    kind: \"static\",\n    length: 4\n  }, input.selector, Object.assign(Object.assign({}, wrapOptions), {\n    name: `${wrapOptions.name}.selector`,\n    specificityFloor: 5\n  }), bytes_1.bytesCases);\n  const selector = wrappedSelector.value.asHex; //note validation & normalization have already been performed\n\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: {\n      kind: \"unknown\",\n      contract: {\n        kind: \"unknown\",\n        address\n      },\n      selector\n    }\n  };\n}\n\nfunction* functionFromCodecFunctionExternalValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n\n  if (input.type.typeClass !== \"function\" || input.type.visibility !== \"external\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n\n  const coercedInput = input;\n  const address = coercedInput.value.contract.address;\n  const selector = coercedInput.value.selector; //we can skip validation & normalization here\n\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: {\n      kind: \"unknown\",\n      contract: {\n        kind: \"unknown\",\n        address\n      },\n      selector\n    }\n  };\n}\n\nfunction* functionFromHexString(dataType, input, wrapOptions) {\n  if (typeof input !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n  }\n\n  if (!Utils.isByteString(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, \"Input was a string, but not a valid even-length hex string\");\n  }\n\n  if (input.length !== 2 + 2 * (EvmUtils.ADDRESS_SIZE + EvmUtils.SELECTOR_SIZE)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrongLengthMessage(\"external function was given as a string but\", EvmUtils.ADDRESS_SIZE + EvmUtils.SELECTOR_SIZE, (input.length - 2) / 2));\n  }\n\n  let address = input.slice(0, EvmUtils.ADDRESS_SIZE * 2 + 2).toLowerCase();\n  const selector = \"0x\" + input.slice(EvmUtils.ADDRESS_SIZE * 2 + 2).toLowerCase(); //address & selector must now have the correct length, and we are deliberately *not*\n  //checking the checksum on address in this case.  So, the only thing remaining\n  //to do is to normalize address.\n\n  address = web3_utils_1.default.toChecksumAddress(address); //...and return\n\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: {\n      kind: \"unknown\",\n      contract: {\n        kind: \"unknown\",\n        address\n      },\n      selector\n    }\n  };\n}\n\nfunction* functionFromTypeValueInput(dataType, input, wrapOptions) {\n  if (!Utils.isTypeValueInput(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n  }\n\n  if (input.type !== \"function\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n  } //extract value & try again, with loose option turned on\n\n\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), {\n    loose: true\n  }), functionExternalCasesBasic);\n}\n\nfunction* functionFailureCase(dataType, input, wrapOptions) {\n  throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, \"Input should be one of: an object with address and selector; a 24-byte hex string; a type/value pair; or a wrapped external function\");\n}","map":{"version":3,"sources":["../../../lib/wrap/function.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.functionExternalCases = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:wrap:function\");\nconst dispatch_1 = require(\"./dispatch\");\nconst errors_1 = require(\"./errors\");\nconst Messages = __importStar(require(\"./messages\"));\nconst Utils = __importStar(require(\"./utils\"));\nconst EvmUtils = __importStar(require(\"../evm/utils\"));\nconst web3_utils_1 = __importDefault(require(\"web3-utils\"));\nconst address_1 = require(\"./address\");\nconst bytes_1 = require(\"./bytes\");\nconst functionExternalCasesBasic = [\n    functionFromFunctionExternalInput,\n    functionFromHexString,\n    functionFromCodecFunctionExternalValue,\n    functionFailureCase\n];\nexports.functionExternalCases = [functionFromTypeValueInput, ...functionExternalCasesBasic];\nfunction* functionFromFunctionExternalInput(dataType, input, wrapOptions) {\n    if (!Utils.isFunctionExternalInput(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not an object with address & selector\");\n    }\n    const wrappedAddress = (yield* (0, dispatch_1.wrapWithCases)({ typeClass: \"address\", kind: \"general\" }, input.address, Object.assign(Object.assign({}, wrapOptions), { name: `${wrapOptions.name}.address`, specificityFloor: 5 }), address_1.addressCases));\n    const address = wrappedAddress.value.asAddress;\n    const wrappedSelector = yield* (0, dispatch_1.wrapWithCases)({ typeClass: \"bytes\", kind: \"static\", length: 4 }, input.selector, Object.assign(Object.assign({}, wrapOptions), { name: `${wrapOptions.name}.selector`, specificityFloor: 5 }), bytes_1.bytesCases);\n    const selector = wrappedSelector.value.asHex;\n    //note validation & normalization have already been performed\n    return {\n        type: dataType,\n        kind: \"value\",\n        value: {\n            kind: \"unknown\",\n            contract: {\n                kind: \"unknown\",\n                address\n            },\n            selector\n        }\n    };\n}\nfunction* functionFromCodecFunctionExternalValue(dataType, input, wrapOptions) {\n    if (!Utils.isWrappedResult(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n    }\n    if (input.type.typeClass !== \"function\" ||\n        input.type.visibility !== \"external\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n    }\n    if (input.kind !== \"value\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n    }\n    const coercedInput = input;\n    const address = coercedInput.value.contract.address;\n    const selector = coercedInput.value.selector;\n    //we can skip validation & normalization here\n    return {\n        type: dataType,\n        kind: \"value\",\n        value: {\n            kind: \"unknown\",\n            contract: {\n                kind: \"unknown\",\n                address\n            },\n            selector\n        }\n    };\n}\nfunction* functionFromHexString(dataType, input, wrapOptions) {\n    if (typeof input !== \"string\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n    }\n    if (!Utils.isByteString(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, \"Input was a string, but not a valid even-length hex string\");\n    }\n    if (input.length !==\n        2 + 2 * (EvmUtils.ADDRESS_SIZE + EvmUtils.SELECTOR_SIZE)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrongLengthMessage(\"external function was given as a string but\", EvmUtils.ADDRESS_SIZE + EvmUtils.SELECTOR_SIZE, (input.length - 2) / 2));\n    }\n    let address = input\n        .slice(0, EvmUtils.ADDRESS_SIZE * 2 + 2)\n        .toLowerCase();\n    const selector = \"0x\" + input.slice(EvmUtils.ADDRESS_SIZE * 2 + 2).toLowerCase();\n    //address & selector must now have the correct length, and we are deliberately *not*\n    //checking the checksum on address in this case.  So, the only thing remaining\n    //to do is to normalize address.\n    address = web3_utils_1.default.toChecksumAddress(address);\n    //...and return\n    return {\n        type: dataType,\n        kind: \"value\",\n        value: {\n            kind: \"unknown\",\n            contract: {\n                kind: \"unknown\",\n                address\n            },\n            selector\n        }\n    };\n}\nfunction* functionFromTypeValueInput(dataType, input, wrapOptions) {\n    if (!Utils.isTypeValueInput(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n    }\n    if (input.type !== \"function\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n    }\n    //extract value & try again, with loose option turned on\n    return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), { loose: true }), functionExternalCasesBasic);\n}\nfunction* functionFailureCase(dataType, input, wrapOptions) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, \"Input should be one of: an object with address and selector; a 24-byte hex string; a type/value pair; or a wrapped external function\");\n}\n//# sourceMappingURL=function.js.map"]},"metadata":{},"sourceType":"script"}