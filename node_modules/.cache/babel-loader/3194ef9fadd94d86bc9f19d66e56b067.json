{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findRepeatCompilationIds = exports.infoToCompilations = exports.findCompilationAndContract = exports.collectUserDefinedTypesAndTaggedOutputs = exports.simpleShimSourceMap = exports.getContractNode = exports.shimContracts = exports.shimArtifacts = exports.shimCompilation = exports.shimCompilations = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"codec:compilations:utils\");\n\nconst Ast = __importStar(require(\"../ast\"));\n\nconst compile_common_1 = require(\"@truffle/compile-common\");\n\nconst Format = __importStar(require(\"../format\"));\n\nconst errors_1 = require(\"../errors\");\n\nfunction shimCompilations(inputCompilations) {\n  let shimmedCompilationIdPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"shimmedcompilation\";\n  return inputCompilations.map((compilation, compilationIndex) => shimCompilation(compilation, `${shimmedCompilationIdPrefix}Number(${compilationIndex})`));\n}\n\nexports.shimCompilations = shimCompilations;\n\nfunction shimCompilation(inputCompilation) {\n  let shimmedCompilationId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"shimmedcompilation\";\n  return Object.assign(Object.assign({}, shimContracts(inputCompilation.contracts, {\n    files: inputCompilation.sourceIndexes,\n    sources: inputCompilation.sources,\n    shimmedCompilationId,\n    compiler: inputCompilation.compiler\n  })), {\n    compiler: inputCompilation.compiler\n  });\n}\n\nexports.shimCompilation = shimCompilation;\n/**\n * wrapper around shimContracts that just returns\n * the result in a one-element array (keeping the old name\n * shimArtifacts for compatibility)\n */\n\nfunction shimArtifacts(artifacts, files) {\n  let shimmedCompilationId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"shimmedcompilation\";\n  return [shimContracts(artifacts, {\n    files,\n    shimmedCompilationId\n  })];\n}\n\nexports.shimArtifacts = shimArtifacts;\n/**\n * shims a bunch of contracts (\"artifacts\", though not necessarily)\n * to a compilation.  usually used via one of the above functions.\n * Note: if you pass in options.sources, options.files will be ignored.\n * Note: if you pass in options.sources, sources will not have\n * compiler set unless you also pass in options.compiler; in this case\n * you should set that up separately, as in shimCompilation().\n */\n\nfunction shimContracts(artifacts) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    files,\n    sources: inputSources\n  } = options;\n  const shimmedCompilationId = options.shimmedCompilationId || \"shimmedcompilation\";\n  let contracts = [];\n  let sources = [];\n  let unreliableSourceOrder = false;\n\n  for (let artifact of artifacts) {\n    let {\n      contractName,\n      bytecode,\n      sourceMap,\n      deployedBytecode,\n      deployedSourceMap,\n      immutableReferences,\n      sourcePath,\n      source,\n      ast,\n      abi,\n      compiler,\n      generatedSources,\n      deployedGeneratedSources,\n      metadata\n    } = artifact;\n\n    if (artifact.contract_name) {\n      //just in case\n      contractName = artifact.contract_name; //dunno what's up w/ the type of contract_name, but it needs coercing\n    }\n\n    debug(\"contractName: %s\", contractName);\n    let contractObject = {\n      contractName,\n      bytecode,\n      sourceMap,\n      deployedBytecode,\n      deployedSourceMap,\n      immutableReferences,\n      abi,\n      generatedSources: normalizeGeneratedSources(generatedSources, compiler),\n      deployedGeneratedSources: normalizeGeneratedSources(deployedGeneratedSources, compiler),\n      compiler\n    };\n    let sourceObject = {\n      sourcePath,\n      source,\n      ast: ast,\n      compiler,\n      language: inferLanguage(ast, compiler, sourcePath)\n    }; //ast needs to be coerced because schema doesn't quite match our types here...\n\n    if (metadata) {\n      try {\n        const parsedMetadata = JSON.parse(metadata); //sorry\n\n        const settings = parsedMetadata.settings;\n        const viaIR = settings.viaIR;\n        contractObject.settings = {\n          viaIR\n        };\n        sourceObject.settings = {\n          viaIR\n        };\n      } catch (_a) {//if metadata doesn't parse, or we hit undefineds, ignore it\n      }\n    } //if files or sources was passed, trust that to determine the source index\n    //(assuming we have a sourcePath! currently it will be absent when dealing with\n    //Solidity versions <0.4.9; presumably we will fix this if we ever properly\n    //support versions that old, but for now this is necessary to get debug -x to work)\n\n\n    if ((files || inputSources) && sourcePath) {\n      //note: we never set the unreliableSourceOrder flag in this branch;\n      //we just trust files/sources.  If this info is bad, then, uh, too bad.\n      debug(\"inputSources: %O\", inputSources);\n      debug(\"files: %O\", files);\n      debug(\"sourcePath: %O\", sourcePath);\n      const index = inputSources ? inputSources.findIndex(source => source.sourcePath === sourcePath) : files.indexOf(sourcePath);\n\n      if (!inputSources) {\n        //if inputSources was passed, we'll handle this separately below\n        sourceObject.id = index.toString(); //HACK\n\n        sources[index] = sourceObject;\n      }\n\n      debug(\"files || inputSources; index: %d\", index);\n      contractObject.primarySourceId = index.toString(); //HACK\n    } else {\n      //if neither was passed, attempt to determine it from the ast\n      let index;\n      let needsAdding;\n\n      if (sourceObject.ast) {\n        //note: this works for both Solidity and Vyper\n        index = sourceIndexForAst(sourceObject.ast); //sourceObject.ast for typing reasons\n      } else if (compiler && compiler.name === \"vyper\") {\n        index = 0; //if it's Vyper but there's no AST, we can\n        //assume that it was compiled alone and therefore has index 0\n      } //if that didn't work, try the source map\n\n\n      if (index === undefined && (sourceMap || deployedSourceMap)) {\n        const sourceMapString = simpleShimSourceMap(deployedSourceMap || sourceMap);\n        index = extractPrimarySource(sourceMapString);\n      } //else leave undefined for now\n\n\n      ({\n        index,\n        needsAdding,\n        unreliableSourceOrder\n      } = getIndexToAddAt(sourceObject, index, sources, unreliableSourceOrder));\n\n      if (needsAdding) {\n        //if we're in this case, inputSources was not passed\n        sourceObject.id = index.toString(); //HACK\n\n        sources[index] = sourceObject;\n        debug(\"else; index: %d\", index);\n      } //whether needed adding or not, set the source ID on the contract object\n\n\n      contractObject.primarySourceId = index.toString(); //HACK\n\n      debug(\"(no index unless mentioned)\");\n    }\n\n    contracts.push(contractObject);\n  } //now: check for id overlap with internal sources\n  //(don't bother if inputSources or files was passed)\n\n\n  if (!inputSources && !files) {\n    for (let contract of contracts) {\n      const {\n        generatedSources,\n        deployedGeneratedSources\n      } = contract;\n\n      for (let index in generatedSources) {\n        if (index in sources) {\n          unreliableSourceOrder = true;\n        }\n      }\n\n      for (let index in deployedGeneratedSources) {\n        if (index in sources) {\n          unreliableSourceOrder = true;\n        }\n      }\n    }\n  }\n\n  let compiler;\n\n  if (options.compiler) {\n    compiler = options.compiler;\n  } else if (!unreliableSourceOrder && contracts.length > 0) {\n    //if things were actually compiled together, we should just be able\n    //to pick an arbitrary one\n    compiler = contracts[0].compiler;\n  }\n\n  let settings; //we'll do the same thing with settings\n\n  if (options.settings) {\n    settings = options.settings;\n  } else if (!unreliableSourceOrder && contracts.length > 0) {\n    //if things were actually compiled together, we should just be able\n    //to pick an arbitrary one\n    settings = contracts[0].settings;\n  } //if input sources was passed, set up the sources object directly :)\n\n\n  if (inputSources) {\n    sources = inputSources.map((_ref, index) => {\n      let {\n        sourcePath,\n        contents: source,\n        ast,\n        language\n      } = _ref;\n      return {\n        sourcePath,\n        source,\n        ast: ast,\n        language,\n        id: index.toString(),\n        compiler //redundant but let's include it\n\n      };\n    });\n  }\n\n  return {\n    id: shimmedCompilationId,\n    unreliableSourceOrder,\n    sources,\n    contracts,\n    compiler,\n    settings\n  };\n}\n\nexports.shimContracts = shimContracts; //note: this works for Vyper too!\n\nfunction sourceIndexForAst(ast) {\n  if (Array.isArray(ast)) {\n    //special handling for old Vyper versions\n    ast = ast[0];\n  }\n\n  if (!ast) {\n    return undefined;\n  }\n\n  return parseInt(ast.src.split(\":\")[2]); //src is given as start:length:file.\n  //we want just the file.\n}\n\nfunction getContractNode(contract, compilation) {\n  const {\n    contractName,\n    sourceMap,\n    deployedSourceMap,\n    primarySourceId\n  } = contract;\n  const {\n    unreliableSourceOrder,\n    sources\n  } = compilation;\n  let sourcesToCheck; //we will attempt to locate the primary source;\n  //if we can't find it, we'll just check every source in this\n  //compilation.\n\n  if (primarySourceId !== undefined) {\n    sourcesToCheck = [sources.find(source => source && source.id === primarySourceId)];\n  } else if (!unreliableSourceOrder && (deployedSourceMap || sourceMap)) {\n    const sourceMapString = simpleShimSourceMap(deployedSourceMap || sourceMap);\n    let sourceId = extractPrimarySource(sourceMapString);\n    sourcesToCheck = [sources[sourceId]];\n  } else {\n    //WARNING: if we end up in this case, we could get the wrong contract!\n    //(but we shouldn't end up here)\n    sourcesToCheck = sources;\n  }\n\n  return sourcesToCheck.reduce((foundNode, source) => {\n    if (foundNode || !source) {\n      return foundNode;\n    }\n\n    if (!source.ast || source.language !== \"Solidity\") {\n      //ignore non-Solidity ASTs for now, we don't support them yet\n      return undefined;\n    }\n\n    return source.ast.nodes.find(node => node.nodeType === \"ContractDefinition\" && node.name === contractName);\n  }, undefined);\n}\n\nexports.getContractNode = getContractNode;\n/**\n * extract the primary source from a source map\n * (i.e., the source for the first instruction, found\n * between the second and third colons)\n */\n\nfunction extractPrimarySource(sourceMap) {\n  if (!sourceMap) {\n    //HACK?\n    return 0; //in this case (e.g. a Vyper contract with an old-style\n    //source map) we infer that it was compiled by itself\n  }\n\n  return parseInt(sourceMap.match(/^[^:]*:[^:]*:([^:]*):/)[1] || \"0\");\n}\n\nfunction normalizeGeneratedSources(generatedSources, compiler) {\n  if (!generatedSources) {\n    return [];\n  }\n\n  if (!isGeneratedSources(generatedSources)) {\n    return generatedSources; //if already normalizeed, leave alone\n  }\n\n  let sources = []; //output\n\n  for (let source of generatedSources) {\n    sources[source.id] = {\n      id: source.id.toString(),\n      sourcePath: source.name,\n      source: source.contents,\n      //ast needs to be coerced because schema doesn't quite match our types here...\n      ast: source.ast,\n      compiler: compiler,\n      language: source.language\n    };\n  }\n\n  return sources;\n} //HACK\n\n\nfunction isGeneratedSources(sources) {\n  //note: for some reason arr.includes(undefined) returns true on sparse arrays\n  //if sources.length === 0, it's ambiguous; we'll exclude it as not needing normalization\n  return sources.length > 0 && !sources.includes(undefined) && (sources[0].contents !== undefined || sources[0].name !== undefined);\n} //HACK, maybe?\n\n\nfunction inferLanguage(ast, compiler, sourcePath) {\n  if (ast) {\n    if (ast.nodeType === \"SourceUnit\") {\n      return \"Solidity\";\n    } else if (ast.nodeType && ast.nodeType.startsWith(\"Yul\")) {\n      //Every Yul source I've seen has YulBlock as the root, but\n      //I'm not sure that that's *always* the case\n      return \"Yul\";\n    } else if (Array.isArray(ast) || ast.ast_type === \"Module\") {\n      return \"Vyper\";\n    }\n  } else if (compiler) {\n    if (compiler.name === \"vyper\") {\n      return \"Vyper\";\n    } else if (compiler.name === \"solc\") {\n      //assuming sources compiled with solc without sourcePath are Solidity\n      if (sourcePath && sourcePath.endsWith(\".yul\")) {\n        return \"Yul\";\n      } else {\n        return \"Solidity\";\n      }\n    } else {\n      return undefined;\n    }\n  } else {\n    return undefined;\n  }\n}\n\nfunction getIndexToAddAt(sourceObject, index, sources, unreliableSourceOrder) {\n  debug(\"sourcePath: %s\", sourceObject.sourcePath);\n  debug(\"given index: %d\", index);\n  debug(\"sources: %o\", sources.map(source => source.sourcePath)); //first: is this already there? only add it if it's not.\n  //(we determine this by sourcePath if present, and the actual source\n  //contents if not)\n\n  const existingIndex = sources.findIndex(existingSource => existingSource && ( //findIndex treats absent as undefined, so we need this guard\n  // (array may be sparse)\n  existingSource.sourcePath === sourceObject.sourcePath || !sourceObject.sourcePath && !existingSource.sourcePath && existingSource.source === sourceObject.source));\n\n  if (existingIndex === -1) {\n    //it's not already there, let's add it\n    if (unreliableSourceOrder || index === undefined || index in sources) {\n      //if we can't add it at the correct spot, set the\n      //unreliable source order flag\n      debug(\"collision!\");\n      unreliableSourceOrder = true;\n    }\n\n    if (unreliableSourceOrder) {\n      //in case of unreliable source order, we'll ignore what indices\n      //things are *supposed* to have and just append things to the end\n      index = sources.length;\n    } //otherwise, just leave things alone\n\n\n    return {\n      index,\n      needsAdding: true,\n      unreliableSourceOrder\n    };\n  } else {\n    debug(\"already present, not adding\");\n    return {\n      index: existingIndex,\n      needsAdding: false,\n      unreliableSourceOrder\n    };\n  }\n}\n/**\n * convert Vyper source maps to solidity ones\n * (note we won't bother handling the case where the compressed\n * version doesn't exist; that will have to wait for a later version)\n */\n\n\nfunction simpleShimSourceMap(sourceMap) {\n  if (sourceMap === undefined) {\n    return undefined; //undefined case\n  } else if (typeof sourceMap === \"object\") {\n    return sourceMap.pc_pos_map_compressed; //Vyper object case\n  } else {\n    try {\n      return JSON.parse(sourceMap).pc_pos_map_compressed; //Vyper JSON case\n    } catch (_) {\n      return sourceMap; //Solidity case\n    }\n  }\n}\n\nexports.simpleShimSourceMap = simpleShimSourceMap;\n/**\n * collects user defined types & tagged outputs for a given set of compilations,\n * returning both the definition nodes and (for the types) the type objects\n *\n * \"Tagged outputs\" means user-defined things that are output by a contract\n * (not input to a contract), and which are distinguished by (potentially\n * ambiguous) selectors.  So, events and custom errors are tagged outputs.\n * Function arguments are not tagged outputs (they're not outputs).\n * Return values are not tagged outputs (they don't have a selector).\n * Built-in errors (Error(string) and Panic(uint))... OK I guess those could\n * be considered tagged outputs, but we're only looking at user-defined ones\n * here.\n */\n\nfunction collectUserDefinedTypesAndTaggedOutputs(compilations) {\n  let references = {};\n  let types = {};\n\n  for (const compilation of compilations) {\n    references[compilation.id] = {};\n    types[compilation.id] = {\n      compiler: compilation.compiler,\n      types: {}\n    };\n\n    for (const source of compilation.sources) {\n      if (!source) {\n        continue; //remember, sources could be empty if shimmed!\n      }\n\n      const {\n        ast,\n        compiler,\n        language\n      } = source;\n\n      if (language === \"Solidity\" && ast) {\n        //don't check Yul or Vyper sources!\n        for (const node of ast.nodes) {\n          if (node.nodeType === \"StructDefinition\" || node.nodeType === \"EnumDefinition\" || node.nodeType === \"UserDefinedValueTypeDefinition\" || node.nodeType === \"ContractDefinition\") {\n            references[compilation.id][node.id] = node; //we don't have all the references yet, but we actually don't need them :)\n\n            const dataType = Ast.Import.definitionToStoredType(node, compilation.id, compiler, references[compilation.id]);\n            types[compilation.id].types[dataType.id] = dataType;\n          } else if (node.nodeType === \"EventDefinition\" || node.nodeType === \"ErrorDefinition\") {\n            references[compilation.id][node.id] = node;\n          }\n\n          if (node.nodeType === \"ContractDefinition\") {\n            for (const subNode of node.nodes) {\n              if (subNode.nodeType === \"StructDefinition\" || subNode.nodeType === \"EnumDefinition\" || subNode.nodeType === \"UserDefinedValueTypeDefinition\") {\n                references[compilation.id][subNode.id] = subNode; //we don't have all the references yet, but we only need the\n                //reference to the defining contract, which we just added above!\n\n                const dataType = Ast.Import.definitionToStoredType(subNode, compilation.id, compiler, references[compilation.id]);\n                types[compilation.id].types[dataType.id] = dataType;\n              } else if (subNode.nodeType === \"EventDefinition\" || subNode.nodeType === \"ErrorDefinition\") {\n                references[compilation.id][subNode.id] = subNode;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return {\n    definitions: references,\n    typesByCompilation: types,\n    types: Format.Types.forgetCompilations(types)\n  };\n}\n\nexports.collectUserDefinedTypesAndTaggedOutputs = collectUserDefinedTypesAndTaggedOutputs;\n/**\n * Given a list of compilations, and an artifact appearing in one\n * of those compilations, finds the compilation and the corresponding\n * contract object\n * (these may be undefined if they can't be found)\n */\n\nfunction findCompilationAndContract(compilations, artifact) {\n  const deployedBytecode = compile_common_1.Shims.NewToLegacy.forBytecode(artifact.deployedBytecode);\n  const bytecode = compile_common_1.Shims.NewToLegacy.forBytecode(artifact.bytecode);\n  let firstNameMatch;\n  let multipleNameMatches = false;\n\n  for (const compilation of compilations) {\n    for (const contract of compilation.contracts) {\n      const nameMatches = contract.contractName === (artifact.contractName || artifact.contract_name);\n\n      if (nameMatches) {\n        if (bytecode) {\n          if (compile_common_1.Shims.NewToLegacy.forBytecode(contract.bytecode) === bytecode) {\n            return {\n              compilation,\n              contract\n            };\n          }\n        } else if (deployedBytecode) {\n          if (compile_common_1.Shims.NewToLegacy.forBytecode(contract.deployedBytecode) === deployedBytecode) {\n            return {\n              compilation,\n              contract\n            };\n          }\n        } else if (!firstNameMatch) {\n          //if we have a name match, but no bytecode to go by, record this one.\n          //if it turns out to be the only one, we'll return it later.\n          firstNameMatch = {\n            compilation,\n            contract\n          };\n        } else if (!multipleNameMatches) {\n          //on the other hand, if there *is* an existing name match already,\n          //record that we've got multiple.\n          multipleNameMatches = true;\n        }\n      }\n    }\n  } //once the loop is done, if we haven't returned a bytecode match,\n  //check if we've got a unique name match, and return it if so\n\n\n  if (firstNameMatch && !multipleNameMatches) {\n    return firstNameMatch;\n  } //otherwise, if there's no bytecode match, and either no name match\n  //or multiple name matches, just return a default fallback\n\n\n  const defaultContract = {\n    contractName: artifact.contractName || artifact.contract_name,\n    abi: artifact.abi\n  };\n  const defaultCompilation = {\n    id: \"defaultCompilation\",\n    sources: [],\n    contracts: [defaultContract]\n  };\n  return {\n    compilation: defaultCompilation,\n    contract: defaultContract\n  };\n}\n\nexports.findCompilationAndContract = findCompilationAndContract;\n\nfunction projectInfoIsCodecStyle(info) {\n  return Boolean(info.compilations);\n}\n\nfunction projectInfoIsCommonStyle(info) {\n  return Boolean(info.commonCompilations);\n}\n\nfunction projectInfoIsArtifacts(info) {\n  return Boolean(info.artifacts);\n}\n\nfunction infoToCompilations(projectInfo, nonceString) {\n  if (!projectInfo) {\n    throw new errors_1.NoProjectInfoError();\n  }\n\n  if (projectInfoIsCodecStyle(projectInfo)) {\n    return projectInfo.compilations;\n  } else if (projectInfoIsCommonStyle(projectInfo)) {\n    return shimCompilations(projectInfo.commonCompilations, nonceString);\n  } else if (projectInfoIsArtifacts(projectInfo)) {\n    return shimArtifacts(projectInfo.artifacts, undefined, nonceString);\n  }\n}\n\nexports.infoToCompilations = infoToCompilations;\n\nfunction findRepeatCompilationIds(compilations) {\n  let repeats = new Set();\n\n  for (let i = 0; i < compilations.length; i++) {\n    for (let j = i + 1; j < compilations.length; j++) {\n      if (compilations[i].id === compilations[j].id) {\n        repeats.add(compilations[i].id);\n      }\n    }\n  }\n\n  return repeats;\n}\n\nexports.findRepeatCompilationIds = findRepeatCompilationIds;","map":{"version":3,"sources":["../../../lib/compilations/utils.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAA,OAAA,GAAA,eAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AACA,MAAM,KAAK,GAAG,CAAA,GAAA,OAAA,CAAA,OAAA,EAAY,0BAAZ,CAAd;;AAGA,MAAA,GAAA,GAAA,YAAA,CAAA,OAAA,CAAA,QAAA,CAAA,CAAA;;AAOA,MAAA,gBAAA,GAAA,OAAA,CAAA,yBAAA,CAAA;;AACA,MAAA,MAAA,GAAA,YAAA,CAAA,OAAA,CAAA,WAAA,CAAA,CAAA;;AAWA,MAAA,QAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;AAEA,SAAgB,gBAAhB,CACE,iBADF,EAEmD;AAAA,MAAjD,0BAAiD,uEAApB,oBAAoB;AAEjD,SAAO,iBAAiB,CAAC,GAAlB,CAAsB,CAAC,WAAD,EAAc,gBAAd,KAC3B,eAAe,CACb,WADa,EAEb,GAAG,0BAA0B,UAAU,gBAAgB,GAF1C,CADV,CAAP;AAMD;;AAVD,OAAA,CAAA,gBAAA,GAAA,gBAAA;;AAYA,SAAgB,eAAhB,CACE,gBADF,EAE6C;AAAA,MAA3C,oBAA2C,uEAApB,oBAAoB;AAE3C,SAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACK,aAAa,CAAC,gBAAgB,CAAC,SAAlB,EAA6B;AAC3C,IAAA,KAAK,EAAE,gBAAgB,CAAC,aADmB;AAE3C,IAAA,OAAO,EAAE,gBAAgB,CAAC,OAFiB;AAG3C,IAAA,oBAH2C;AAI3C,IAAA,QAAQ,EAAE,gBAAgB,CAAC;AAJgB,GAA7B,CADlB,CAAA,EAMI;AACF,IAAA,QAAQ,EAAE,gBAAgB,CAAC;AADzB,GANJ,CAAA;AASD;;AAbD,OAAA,CAAA,eAAA,GAAA,eAAA;AAeA;;;;AAIG;;AACH,SAAgB,aAAhB,CACE,SADF,EAEE,KAFF,EAG6C;AAAA,MAA3C,oBAA2C,uEAApB,oBAAoB;AAE3C,SAAO,CAAC,aAAa,CAAC,SAAD,EAAY;AAAE,IAAA,KAAF;AAAS,IAAA;AAAT,GAAZ,CAAd,CAAP;AACD;;AAND,OAAA,CAAA,aAAA,GAAA,aAAA;AAqBA;;;;;;;AAOG;;AACH,SAAgB,aAAhB,CACE,SADF,EAEkC;AAAA,MAAhC,OAAgC,uEAAF,EAAE;AAEhC,QAAM;AAAE,IAAA,KAAF;AAAS,IAAA,OAAO,EAAE;AAAlB,MAAmC,OAAzC;AACA,QAAM,oBAAoB,GACxB,OAAO,CAAC,oBAAR,IAAgC,oBADlC;AAEA,MAAI,SAAS,GAAe,EAA5B;AACA,MAAI,OAAO,GAAa,EAAxB;AACA,MAAI,qBAAqB,GAAY,KAArC;;AAEA,OAAK,IAAI,QAAT,IAAqB,SAArB,EAAgC;AAC9B,QAAI;AACF,MAAA,YADE;AAEF,MAAA,QAFE;AAGF,MAAA,SAHE;AAIF,MAAA,gBAJE;AAKF,MAAA,iBALE;AAMF,MAAA,mBANE;AAOF,MAAA,UAPE;AAQF,MAAA,MARE;AASF,MAAA,GATE;AAUF,MAAA,GAVE;AAWF,MAAA,QAXE;AAYF,MAAA,gBAZE;AAaF,MAAA,wBAbE;AAcF,MAAA;AAdE,QAeA,QAfJ;;AAiBA,QAAe,QAAS,CAAC,aAAzB,EAAwC;AACtC;AACA,MAAA,YAAY,GAAsB,QAAS,CAAC,aAA5C,CAFsC,CAGtC;AACD;;AAED,IAAA,KAAK,CAAC,kBAAD,EAAqB,YAArB,CAAL;AAEA,QAAI,cAAc,GAAa;AAC7B,MAAA,YAD6B;AAE7B,MAAA,QAF6B;AAG7B,MAAA,SAH6B;AAI7B,MAAA,gBAJ6B;AAK7B,MAAA,iBAL6B;AAM7B,MAAA,mBAN6B;AAO7B,MAAA,GAP6B;AAQ7B,MAAA,gBAAgB,EAAE,yBAAyB,CAAC,gBAAD,EAAmB,QAAnB,CARd;AAS7B,MAAA,wBAAwB,EAAE,yBAAyB,CACjD,wBADiD,EAEjD,QAFiD,CATtB;AAa7B,MAAA;AAb6B,KAA/B;AAgBA,QAAI,YAAY,GAAW;AACzB,MAAA,UADyB;AAEzB,MAAA,MAFyB;AAGzB,MAAA,GAAG,EAAW,GAHW;AAIzB,MAAA,QAJyB;AAKzB,MAAA,QAAQ,EAAE,aAAa,CAAU,GAAV,EAAe,QAAf,EAAyB,UAAzB;AALE,KAA3B,CA1C8B,CAiD9B;;AAEA,QAAI,QAAJ,EAAc;AACZ,UAAI;AACF,cAAM,cAAc,GAAQ,IAAI,CAAC,KAAL,CAAW,QAAX,CAA5B,CADE,CACgD;;AAClD,cAAM,QAAQ,GAAsB,cAAc,CAAC,QAAnD;AACA,cAAM,KAAK,GAAG,QAAQ,CAAC,KAAvB;AACA,QAAA,cAAc,CAAC,QAAf,GAA0B;AAAE,UAAA;AAAF,SAA1B;AACA,QAAA,YAAY,CAAC,QAAb,GAAwB;AAAE,UAAA;AAAF,SAAxB;AACD,OAND,CAME,OAAA,EAAA,EAAM,CACN;AACD;AACF,KA7D6B,CA+D9B;AACA;AACA;AACA;;;AACA,QAAI,CAAC,KAAK,IAAI,YAAV,KAA2B,UAA/B,EAA2C;AACzC;AACA;AACA,MAAA,KAAK,CAAC,kBAAD,EAAqB,YAArB,CAAL;AACA,MAAA,KAAK,CAAC,WAAD,EAAc,KAAd,CAAL;AACA,MAAA,KAAK,CAAC,gBAAD,EAAmB,UAAnB,CAAL;AACA,YAAM,KAAK,GAAG,YAAY,GACtB,YAAY,CAAC,SAAb,CAAuB,MAAM,IAAI,MAAM,CAAC,UAAP,KAAsB,UAAvD,CADsB,GAEtB,KAAK,CAAC,OAAN,CAAc,UAAd,CAFJ;;AAGA,UAAI,CAAC,YAAL,EAAmB;AACjB;AACA,QAAA,YAAY,CAAC,EAAb,GAAkB,KAAK,CAAC,QAAN,EAAlB,CAFiB,CAEmB;;AACpC,QAAA,OAAO,CAAC,KAAD,CAAP,GAAiB,YAAjB;AACD;;AACD,MAAA,KAAK,CAAC,kCAAD,EAAqC,KAArC,CAAL;AACA,MAAA,cAAc,CAAC,eAAf,GAAiC,KAAK,CAAC,QAAN,EAAjC,CAfyC,CAeU;AACpD,KAhBD,MAgBO;AACL;AACA,UAAI,KAAJ;AACA,UAAI,WAAJ;;AACA,UAAI,YAAY,CAAC,GAAjB,EAAsB;AACpB;AACA,QAAA,KAAK,GAAG,iBAAiB,CAAC,YAAY,CAAC,GAAd,CAAzB,CAFoB,CAEyB;AAC9C,OAHD,MAGO,IAAI,QAAQ,IAAI,QAAQ,CAAC,IAAT,KAAkB,OAAlC,EAA2C;AAChD,QAAA,KAAK,GAAG,CAAR,CADgD,CACrC;AACX;AACD,OAVI,CAWL;;;AACA,UAAI,KAAK,KAAK,SAAV,KAAwB,SAAS,IAAI,iBAArC,CAAJ,EAA6D;AAC3D,cAAM,eAAe,GAAG,mBAAmB,CACzC,iBAAiB,IAAI,SADoB,CAA3C;AAGA,QAAA,KAAK,GAAG,oBAAoB,CAAC,eAAD,CAA5B;AACD,OAjBI,CAkBL;;;AACA,OAAC;AAAE,QAAA,KAAF;AAAS,QAAA,WAAT;AAAsB,QAAA;AAAtB,UAAgD,eAAe,CAC9D,YAD8D,EAE9D,KAF8D,EAG9D,OAH8D,EAI9D,qBAJ8D,CAAhE;;AAMA,UAAI,WAAJ,EAAiB;AACf;AACA,QAAA,YAAY,CAAC,EAAb,GAAkB,KAAK,CAAC,QAAN,EAAlB,CAFe,CAEqB;;AACpC,QAAA,OAAO,CAAC,KAAD,CAAP,GAAiB,YAAjB;AACA,QAAA,KAAK,CAAC,iBAAD,EAAoB,KAApB,CAAL;AACD,OA9BI,CA+BL;;;AACA,MAAA,cAAc,CAAC,eAAf,GAAiC,KAAK,CAAC,QAAN,EAAjC,CAhCK,CAgC8C;;AACnD,MAAA,KAAK,CAAC,6BAAD,CAAL;AACD;;AAED,IAAA,SAAS,CAAC,IAAV,CAAe,cAAf;AACD,GAjI+B,CAmIhC;AACA;;;AACA,MAAI,CAAC,YAAD,IAAiB,CAAC,KAAtB,EAA6B;AAC3B,SAAK,IAAI,QAAT,IAAqB,SAArB,EAAgC;AAC9B,YAAM;AAAE,QAAA,gBAAF;AAAoB,QAAA;AAApB,UAAiD,QAAvD;;AACA,WAAK,IAAI,KAAT,IAAkB,gBAAlB,EAAoC;AAClC,YAAI,KAAK,IAAI,OAAb,EAAsB;AACpB,UAAA,qBAAqB,GAAG,IAAxB;AACD;AACF;;AACD,WAAK,IAAI,KAAT,IAAkB,wBAAlB,EAA4C;AAC1C,YAAI,KAAK,IAAI,OAAb,EAAsB;AACpB,UAAA,qBAAqB,GAAG,IAAxB;AACD;AACF;AACF;AACF;;AAED,MAAI,QAAJ;;AACA,MAAI,OAAO,CAAC,QAAZ,EAAsB;AACpB,IAAA,QAAQ,GAAG,OAAO,CAAC,QAAnB;AACD,GAFD,MAEO,IAAI,CAAC,qBAAD,IAA0B,SAAS,CAAC,MAAV,GAAmB,CAAjD,EAAoD;AACzD;AACA;AACA,IAAA,QAAQ,GAAG,SAAS,CAAC,CAAD,CAAT,CAAa,QAAxB;AACD;;AAED,MAAI,QAAJ,CA9JgC,CA8JC;;AACjC,MAAI,OAAO,CAAC,QAAZ,EAAsB;AACpB,IAAA,QAAQ,GAAG,OAAO,CAAC,QAAnB;AACD,GAFD,MAEO,IAAI,CAAC,qBAAD,IAA0B,SAAS,CAAC,MAAV,GAAmB,CAAjD,EAAoD;AACzD;AACA;AACA,IAAA,QAAQ,GAAG,SAAS,CAAC,CAAD,CAAT,CAAa,QAAxB;AACD,GArK+B,CAuKhC;;;AACA,MAAI,YAAJ,EAAkB;AAChB,IAAA,OAAO,GAAG,YAAY,CAAC,GAAb,CACR,OAAkD,KAAlD;AAAA,UAAC;AAAE,QAAA,UAAF;AAAc,QAAA,QAAQ,EAAE,MAAxB;AAAgC,QAAA,GAAhC;AAAqC,QAAA;AAArC,OAAD;AAAA,aAA6D;AAC3D,QAAA,UAD2D;AAE3D,QAAA,MAF2D;AAG3D,QAAA,GAAG,EAAW,GAH6C;AAI3D,QAAA,QAJ2D;AAK3D,QAAA,EAAE,EAAE,KAAK,CAAC,QAAN,EALuD;AAM3D,QAAA,QAN2D,CAMlD;;AANkD,OAA7D;AAAA,KADQ,CAAV;AAUD;;AAED,SAAO;AACL,IAAA,EAAE,EAAE,oBADC;AAEL,IAAA,qBAFK;AAGL,IAAA,OAHK;AAIL,IAAA,SAJK;AAKL,IAAA,QALK;AAML,IAAA;AANK,GAAP;AAQD;;AA/LD,OAAA,CAAA,aAAA,GAAA,aAAA,C,CAiMA;;AACA,SAAS,iBAAT,CAA2B,GAA3B,EAAuC;AACrC,MAAI,KAAK,CAAC,OAAN,CAAc,GAAd,CAAJ,EAAwB;AACtB;AACA,IAAA,GAAG,GAAG,GAAG,CAAC,CAAD,CAAT;AACD;;AACD,MAAI,CAAC,GAAL,EAAU;AACR,WAAO,SAAP;AACD;;AACD,SAAO,QAAQ,CAAC,GAAG,CAAC,GAAJ,CAAQ,KAAR,CAAc,GAAd,EAAmB,CAAnB,CAAD,CAAf,CARqC,CASrC;AACA;AACD;;AAED,SAAgB,eAAhB,CACE,QADF,EAEE,WAFF,EAE0B;AAExB,QAAM;AAAE,IAAA,YAAF;AAAgB,IAAA,SAAhB;AAA2B,IAAA,iBAA3B;AAA8C,IAAA;AAA9C,MACJ,QADF;AAEA,QAAM;AAAE,IAAA,qBAAF;AAAyB,IAAA;AAAzB,MAAqC,WAA3C;AAEA,MAAI,cAAJ,CANwB,CAQxB;AACA;AACA;;AACA,MAAI,eAAe,KAAK,SAAxB,EAAmC;AACjC,IAAA,cAAc,GAAG,CACf,OAAO,CAAC,IAAR,CAAa,MAAM,IAAI,MAAM,IAAI,MAAM,CAAC,EAAP,KAAc,eAA/C,CADe,CAAjB;AAGD,GAJD,MAIO,IAAI,CAAC,qBAAD,KAA2B,iBAAiB,IAAI,SAAhD,CAAJ,EAAgE;AACrE,UAAM,eAAe,GAAG,mBAAmB,CAAC,iBAAiB,IAAI,SAAtB,CAA3C;AACA,QAAI,QAAQ,GAAG,oBAAoB,CAAC,eAAD,CAAnC;AACA,IAAA,cAAc,GAAG,CAAC,OAAO,CAAC,QAAD,CAAR,CAAjB;AACD,GAJM,MAIA;AACL;AACA;AACA,IAAA,cAAc,GAAG,OAAjB;AACD;;AAED,SAAO,cAAc,CAAC,MAAf,CAAsB,CAAC,SAAD,EAAqB,MAArB,KAAuC;AAClE,QAAI,SAAS,IAAI,CAAC,MAAlB,EAA0B;AACxB,aAAO,SAAP;AACD;;AACD,QAAI,CAAC,MAAM,CAAC,GAAR,IAAe,MAAM,CAAC,QAAP,KAAoB,UAAvC,EAAmD;AACjD;AACA,aAAO,SAAP;AACD;;AACD,WAAO,MAAM,CAAC,GAAP,CAAW,KAAX,CAAiB,IAAjB,CACL,IAAI,IACF,IAAI,CAAC,QAAL,KAAkB,oBAAlB,IAA0C,IAAI,CAAC,IAAL,KAAc,YAFrD,CAAP;AAID,GAZM,EAYJ,SAZI,CAAP;AAaD;;AAxCD,OAAA,CAAA,eAAA,GAAA,eAAA;AA0CA;;;;AAIG;;AACH,SAAS,oBAAT,CAA8B,SAA9B,EAA2D;AACzD,MAAI,CAAC,SAAL,EAAgB;AACd;AACA,WAAO,CAAP,CAFc,CAEJ;AACV;AACD;;AACD,SAAO,QAAQ,CAAC,SAAS,CAAC,KAAV,CAAgB,uBAAhB,EAAyC,CAAzC,KAA+C,GAAhD,CAAf;AACD;;AAED,SAAS,yBAAT,CACE,gBADF,EAEE,QAFF,EAEoC;AAElC,MAAI,CAAC,gBAAL,EAAuB;AACrB,WAAO,EAAP;AACD;;AACD,MAAI,CAAC,kBAAkB,CAAC,gBAAD,CAAvB,EAA2C;AACzC,WAAO,gBAAP,CADyC,CAChB;AAC1B;;AACD,MAAI,OAAO,GAAG,EAAd,CARkC,CAQhB;;AAClB,OAAK,IAAI,MAAT,IAAmB,gBAAnB,EAAqC;AACnC,IAAA,OAAO,CAAC,MAAM,CAAC,EAAR,CAAP,GAAqB;AACnB,MAAA,EAAE,EAAE,MAAM,CAAC,EAAP,CAAU,QAAV,EADe;AAEnB,MAAA,UAAU,EAAE,MAAM,CAAC,IAFA;AAGnB,MAAA,MAAM,EAAE,MAAM,CAAC,QAHI;AAInB;AACA,MAAA,GAAG,EAAW,MAAM,CAAC,GALF;AAMnB,MAAA,QAAQ,EAAE,QANS;AAOnB,MAAA,QAAQ,EAAE,MAAM,CAAC;AAPE,KAArB;AASD;;AACD,SAAO,OAAP;AACD,C,CAED;;;AACA,SAAS,kBAAT,CACE,OADF,EACsC;AAEpC;AACA;AACA,SACE,OAAO,CAAC,MAAR,GAAiB,CAAjB,IACA,CAAC,OAAO,CAAC,QAAR,CAAiB,SAAjB,CADD,KAEoB,OAAQ,CAAC,CAAD,CAAR,CAAY,QAAZ,KAAyB,SAAzB,IACC,OAAQ,CAAC,CAAD,CAAR,CAAY,IAAZ,KAAqB,SAH1C,CADF;AAMD,C,CAED;;;AACA,SAAS,aAAT,CACE,GADF,EAEE,QAFF,EAGE,UAHF,EAGoB;AAElB,MAAI,GAAJ,EAAS;AACP,QAAI,GAAG,CAAC,QAAJ,KAAiB,YAArB,EAAmC;AACjC,aAAO,UAAP;AACD,KAFD,MAEO,IAAI,GAAG,CAAC,QAAJ,IAAgB,GAAG,CAAC,QAAJ,CAAa,UAAb,CAAwB,KAAxB,CAApB,EAAoD;AACzD;AACA;AACA,aAAO,KAAP;AACD,KAJM,MAIA,IAAI,KAAK,CAAC,OAAN,CAAc,GAAd,KAAsB,GAAG,CAAC,QAAJ,KAAiB,QAA3C,EAAqD;AAC1D,aAAO,OAAP;AACD;AACF,GAVD,MAUO,IAAI,QAAJ,EAAc;AACnB,QAAI,QAAQ,CAAC,IAAT,KAAkB,OAAtB,EAA+B;AAC7B,aAAO,OAAP;AACD,KAFD,MAEO,IAAI,QAAQ,CAAC,IAAT,KAAkB,MAAtB,EAA8B;AACnC;AACA,UAAI,UAAU,IAAI,UAAU,CAAC,QAAX,CAAoB,MAApB,CAAlB,EAA+C;AAC7C,eAAO,KAAP;AACD,OAFD,MAEO;AACL,eAAO,UAAP;AACD;AACF,KAPM,MAOA;AACL,aAAO,SAAP;AACD;AACF,GAbM,MAaA;AACL,WAAO,SAAP;AACD;AACF;;AAED,SAAS,eAAT,CACE,YADF,EAEE,KAFF,EAGE,OAHF,EAIE,qBAJF,EAIgC;AAE9B,EAAA,KAAK,CAAC,gBAAD,EAAmB,YAAY,CAAC,UAAhC,CAAL;AACA,EAAA,KAAK,CAAC,iBAAD,EAAoB,KAApB,CAAL;AACA,EAAA,KAAK,CACH,aADG,EAEH,OAAO,CAAC,GAAR,CAAY,MAAM,IAAI,MAAM,CAAC,UAA7B,CAFG,CAAL,CAJ8B,CAQ9B;AACA;AACA;;AACA,QAAM,aAAa,GAAG,OAAO,CAAC,SAAR,CACpB,cAAc,IACZ,cAAc,MAAI;AAClB;AACC,EAAA,cAAc,CAAC,UAAf,KAA8B,YAAY,CAAC,UAA3C,IACE,CAAC,YAAY,CAAC,UAAd,IACC,CAAC,cAAc,CAAC,UADjB,IAEC,cAAc,CAAC,MAAf,KAA0B,YAAY,CAAC,MAL7B,CAFI,CAAtB;;AASA,MAAI,aAAa,KAAK,CAAC,CAAvB,EAA0B;AACxB;AACA,QAAI,qBAAqB,IAAI,KAAK,KAAK,SAAnC,IAAgD,KAAK,IAAI,OAA7D,EAAsE;AACpE;AACA;AACA,MAAA,KAAK,CAAC,YAAD,CAAL;AACA,MAAA,qBAAqB,GAAG,IAAxB;AACD;;AACD,QAAI,qBAAJ,EAA2B;AACzB;AACA;AACA,MAAA,KAAK,GAAG,OAAO,CAAC,MAAhB;AACD,KAZuB,CAaxB;;;AACA,WAAO;AACL,MAAA,KADK;AAEL,MAAA,WAAW,EAAE,IAFR;AAGL,MAAA;AAHK,KAAP;AAKD,GAnBD,MAmBO;AACL,IAAA,KAAK,CAAC,6BAAD,CAAL;AACA,WAAO;AACL,MAAA,KAAK,EAAE,aADF;AAEL,MAAA,WAAW,EAAE,KAFR;AAGL,MAAA;AAHK,KAAP;AAKD;AACF;AAED;;;;AAIG;;;AACH,SAAgB,mBAAhB,CACE,SADF,EACoC;AAElC,MAAI,SAAS,KAAK,SAAlB,EAA6B;AAC3B,WAAO,SAAP,CAD2B,CACT;AACnB,GAFD,MAEO,IAAI,OAAO,SAAP,KAAqB,QAAzB,EAAmC;AACxC,WAAO,SAAS,CAAC,qBAAjB,CADwC,CACA;AACzC,GAFM,MAEA;AACL,QAAI;AACF,aAAO,IAAI,CAAC,KAAL,CAAW,SAAX,EAAsB,qBAA7B,CADE,CACkD;AACrD,KAFD,CAEE,OAAO,CAAP,EAAU;AACV,aAAO,SAAP,CADU,CACQ;AACnB;AACF;AACF;;AAdD,OAAA,CAAA,mBAAA,GAAA,mBAAA;AAgBA;;;;;;;;;;;;AAYG;;AACH,SAAgB,uCAAhB,CACE,YADF,EAC6B;AAM3B,MAAI,UAAU,GAA0C,EAAxD;AACA,MAAI,KAAK,GAAyC,EAAlD;;AACA,OAAK,MAAM,WAAX,IAA0B,YAA1B,EAAwC;AACtC,IAAA,UAAU,CAAC,WAAW,CAAC,EAAb,CAAV,GAA6B,EAA7B;AACA,IAAA,KAAK,CAAC,WAAW,CAAC,EAAb,CAAL,GAAwB;AACtB,MAAA,QAAQ,EAAE,WAAW,CAAC,QADA;AAEtB,MAAA,KAAK,EAAE;AAFe,KAAxB;;AAIA,SAAK,MAAM,MAAX,IAAqB,WAAW,CAAC,OAAjC,EAA0C;AACxC,UAAI,CAAC,MAAL,EAAa;AACX,iBADW,CACD;AACX;;AACD,YAAM;AAAE,QAAA,GAAF;AAAO,QAAA,QAAP;AAAiB,QAAA;AAAjB,UAA8B,MAApC;;AACA,UAAI,QAAQ,KAAK,UAAb,IAA2B,GAA/B,EAAoC;AAClC;AACA,aAAK,MAAM,IAAX,IAAmB,GAAG,CAAC,KAAvB,EAA8B;AAC5B,cACE,IAAI,CAAC,QAAL,KAAkB,kBAAlB,IACA,IAAI,CAAC,QAAL,KAAkB,gBADlB,IAEA,IAAI,CAAC,QAAL,KAAkB,gCAFlB,IAGA,IAAI,CAAC,QAAL,KAAkB,oBAJpB,EAKE;AACA,YAAA,UAAU,CAAC,WAAW,CAAC,EAAb,CAAV,CAA2B,IAAI,CAAC,EAAhC,IAAsC,IAAtC,CADA,CAEA;;AACA,kBAAM,QAAQ,GAAG,GAAG,CAAC,MAAJ,CAAW,sBAAX,CACf,IADe,EAEf,WAAW,CAAC,EAFG,EAGf,QAHe,EAIf,UAAU,CAAC,WAAW,CAAC,EAAb,CAJK,CAAjB;AAMA,YAAA,KAAK,CAAC,WAAW,CAAC,EAAb,CAAL,CAAsB,KAAtB,CAA4B,QAAQ,CAAC,EAArC,IAA2C,QAA3C;AACD,WAfD,MAeO,IACL,IAAI,CAAC,QAAL,KAAkB,iBAAlB,IACA,IAAI,CAAC,QAAL,KAAkB,iBAFb,EAGL;AACA,YAAA,UAAU,CAAC,WAAW,CAAC,EAAb,CAAV,CAA2B,IAAI,CAAC,EAAhC,IAAsC,IAAtC;AACD;;AACD,cAAI,IAAI,CAAC,QAAL,KAAkB,oBAAtB,EAA4C;AAC1C,iBAAK,MAAM,OAAX,IAAsB,IAAI,CAAC,KAA3B,EAAkC;AAChC,kBACE,OAAO,CAAC,QAAR,KAAqB,kBAArB,IACA,OAAO,CAAC,QAAR,KAAqB,gBADrB,IAEA,OAAO,CAAC,QAAR,KAAqB,gCAHvB,EAIE;AACA,gBAAA,UAAU,CAAC,WAAW,CAAC,EAAb,CAAV,CAA2B,OAAO,CAAC,EAAnC,IAAyC,OAAzC,CADA,CAEA;AACA;;AACA,sBAAM,QAAQ,GAAG,GAAG,CAAC,MAAJ,CAAW,sBAAX,CACf,OADe,EAEf,WAAW,CAAC,EAFG,EAGf,QAHe,EAIf,UAAU,CAAC,WAAW,CAAC,EAAb,CAJK,CAAjB;AAMA,gBAAA,KAAK,CAAC,WAAW,CAAC,EAAb,CAAL,CAAsB,KAAtB,CAA4B,QAAQ,CAAC,EAArC,IAA2C,QAA3C;AACD,eAfD,MAeO,IACL,OAAO,CAAC,QAAR,KAAqB,iBAArB,IACA,OAAO,CAAC,QAAR,KAAqB,iBAFhB,EAGL;AACA,gBAAA,UAAU,CAAC,WAAW,CAAC,EAAb,CAAV,CAA2B,OAAO,CAAC,EAAnC,IAAyC,OAAzC;AACD;AACF;AACF;AACF;AACF;AACF;AACF;;AACD,SAAO;AACL,IAAA,WAAW,EAAE,UADR;AAEL,IAAA,kBAAkB,EAAE,KAFf;AAGL,IAAA,KAAK,EAAE,MAAM,CAAC,KAAP,CAAa,kBAAb,CAAgC,KAAhC;AAHF,GAAP;AAKD;;AA9ED,OAAA,CAAA,uCAAA,GAAA,uCAAA;AAgFA;;;;;AAKG;;AACH,SAAgB,0BAAhB,CACE,YADF,EAEE,QAFF,EAEoB;AAElB,QAAM,gBAAgB,GAAG,gBAAA,CAAA,KAAA,CAAM,WAAN,CAAkB,WAAlB,CACvB,QAAQ,CAAC,gBADc,CAAzB;AAGA,QAAM,QAAQ,GAAG,gBAAA,CAAA,KAAA,CAAM,WAAN,CAAkB,WAAlB,CAA8B,QAAQ,CAAC,QAAvC,CAAjB;AAEA,MAAI,cAAJ;AACA,MAAI,mBAAmB,GAAY,KAAnC;;AACA,OAAK,MAAM,WAAX,IAA0B,YAA1B,EAAwC;AACtC,SAAK,MAAM,QAAX,IAAuB,WAAW,CAAC,SAAnC,EAA8C;AAC5C,YAAM,WAAW,GACf,QAAQ,CAAC,YAAT,MACC,QAAQ,CAAC,YAAT,IAAiC,QAAQ,CAAC,aAD3C,CADF;;AAGA,UAAI,WAAJ,EAAiB;AACf,YAAI,QAAJ,EAAc;AACZ,cAAI,gBAAA,CAAA,KAAA,CAAM,WAAN,CAAkB,WAAlB,CAA8B,QAAQ,CAAC,QAAvC,MAAqD,QAAzD,EAAmE;AACjE,mBAAO;AAAE,cAAA,WAAF;AAAe,cAAA;AAAf,aAAP;AACD;AACF,SAJD,MAIO,IAAI,gBAAJ,EAAsB;AAC3B,cACE,gBAAA,CAAA,KAAA,CAAM,WAAN,CAAkB,WAAlB,CAA8B,QAAQ,CAAC,gBAAvC,MACA,gBAFF,EAGE;AACA,mBAAO;AAAE,cAAA,WAAF;AAAe,cAAA;AAAf,aAAP;AACD;AACF,SAPM,MAOA,IAAI,CAAC,cAAL,EAAqB;AAC1B;AACA;AACA,UAAA,cAAc,GAAG;AAAE,YAAA,WAAF;AAAe,YAAA;AAAf,WAAjB;AACD,SAJM,MAIA,IAAI,CAAC,mBAAL,EAA0B;AAC/B;AACA;AACA,UAAA,mBAAmB,GAAG,IAAtB;AACD;AACF;AACF;AACF,GArCiB,CAsClB;AACA;;;AACA,MAAI,cAAc,IAAI,CAAC,mBAAvB,EAA4C;AAC1C,WAAO,cAAP;AACD,GA1CiB,CA2ClB;AACA;;;AACA,QAAM,eAAe,GAAG;AACtB,IAAA,YAAY,EAAE,QAAQ,CAAC,YAAT,IAAiC,QAAQ,CAAC,aADlC;AAEtB,IAAA,GAAG,EAAE,QAAQ,CAAC;AAFQ,GAAxB;AAIA,QAAM,kBAAkB,GAAG;AACzB,IAAA,EAAE,EAAE,oBADqB;AAEzB,IAAA,OAAO,EAAE,EAFgB;AAGzB,IAAA,SAAS,EAAE,CAAC,eAAD;AAHc,GAA3B;AAKA,SAAO;AACL,IAAA,WAAW,EAAE,kBADR;AAEL,IAAA,QAAQ,EAAE;AAFL,GAAP;AAID;;AA5DD,OAAA,CAAA,0BAAA,GAAA,0BAAA;;AA8DA,SAAS,uBAAT,CACE,IADF,EACmB;AAEjB,SAAO,OAAO,CAA2B,IAAK,CAAC,YAAjC,CAAd;AACD;;AAED,SAAS,wBAAT,CACE,IADF,EACmB;AAEjB,SAAO,OAAO,CAAqB,IAAK,CAAC,kBAA3B,CAAd;AACD;;AAED,SAAS,sBAAT,CACE,IADF,EACmB;AAEjB,SAAO,OAAO,CAAwB,IAAK,CAAC,SAA9B,CAAd;AACD;;AAED,SAAgB,kBAAhB,CACE,WADF,EAEE,WAFF,EAEsB;AAEpB,MAAI,CAAC,WAAL,EAAkB;AAChB,UAAM,IAAI,QAAA,CAAA,kBAAJ,EAAN;AACD;;AACD,MAAI,uBAAuB,CAAC,WAAD,CAA3B,EAA0C;AACxC,WAAO,WAAW,CAAC,YAAnB;AACD,GAFD,MAEO,IAAI,wBAAwB,CAAC,WAAD,CAA5B,EAA2C;AAChD,WAAO,gBAAgB,CAAC,WAAW,CAAC,kBAAb,EAAiC,WAAjC,CAAvB;AACD,GAFM,MAEA,IAAI,sBAAsB,CAAC,WAAD,CAA1B,EAAyC;AAC9C,WAAO,aAAa,CAAC,WAAW,CAAC,SAAb,EAAwB,SAAxB,EAAmC,WAAnC,CAApB;AACD;AACF;;AAdD,OAAA,CAAA,kBAAA,GAAA,kBAAA;;AAgBA,SAAgB,wBAAhB,CACE,YADF,EAC6B;AAE3B,MAAI,OAAO,GAAgB,IAAI,GAAJ,EAA3B;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,YAAY,CAAC,MAAjC,EAAyC,CAAC,EAA1C,EAA8C;AAC5C,SAAK,IAAI,CAAC,GAAG,CAAC,GAAG,CAAjB,EAAoB,CAAC,GAAG,YAAY,CAAC,MAArC,EAA6C,CAAC,EAA9C,EAAkD;AAChD,UAAI,YAAY,CAAC,CAAD,CAAZ,CAAgB,EAAhB,KAAuB,YAAY,CAAC,CAAD,CAAZ,CAAgB,EAA3C,EAA+C;AAC7C,QAAA,OAAO,CAAC,GAAR,CAAY,YAAY,CAAC,CAAD,CAAZ,CAAgB,EAA5B;AACD;AACF;AACF;;AACD,SAAO,OAAP;AACD;;AAZD,OAAA,CAAA,wBAAA,GAAA,wBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.findRepeatCompilationIds = exports.infoToCompilations = exports.findCompilationAndContract = exports.collectUserDefinedTypesAndTaggedOutputs = exports.simpleShimSourceMap = exports.getContractNode = exports.shimContracts = exports.shimArtifacts = exports.shimCompilation = exports.shimCompilations = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:compilations:utils\");\nconst Ast = __importStar(require(\"../ast\"));\nconst compile_common_1 = require(\"@truffle/compile-common\");\nconst Format = __importStar(require(\"../format\"));\nconst errors_1 = require(\"../errors\");\nfunction shimCompilations(inputCompilations, shimmedCompilationIdPrefix = \"shimmedcompilation\") {\n    return inputCompilations.map((compilation, compilationIndex) => shimCompilation(compilation, `${shimmedCompilationIdPrefix}Number(${compilationIndex})`));\n}\nexports.shimCompilations = shimCompilations;\nfunction shimCompilation(inputCompilation, shimmedCompilationId = \"shimmedcompilation\") {\n    return Object.assign(Object.assign({}, shimContracts(inputCompilation.contracts, {\n        files: inputCompilation.sourceIndexes,\n        sources: inputCompilation.sources,\n        shimmedCompilationId,\n        compiler: inputCompilation.compiler\n    })), { compiler: inputCompilation.compiler });\n}\nexports.shimCompilation = shimCompilation;\n/**\n * wrapper around shimContracts that just returns\n * the result in a one-element array (keeping the old name\n * shimArtifacts for compatibility)\n */\nfunction shimArtifacts(artifacts, files, shimmedCompilationId = \"shimmedcompilation\") {\n    return [shimContracts(artifacts, { files, shimmedCompilationId })];\n}\nexports.shimArtifacts = shimArtifacts;\n/**\n * shims a bunch of contracts (\"artifacts\", though not necessarily)\n * to a compilation.  usually used via one of the above functions.\n * Note: if you pass in options.sources, options.files will be ignored.\n * Note: if you pass in options.sources, sources will not have\n * compiler set unless you also pass in options.compiler; in this case\n * you should set that up separately, as in shimCompilation().\n */\nfunction shimContracts(artifacts, options = {}) {\n    const { files, sources: inputSources } = options;\n    const shimmedCompilationId = options.shimmedCompilationId || \"shimmedcompilation\";\n    let contracts = [];\n    let sources = [];\n    let unreliableSourceOrder = false;\n    for (let artifact of artifacts) {\n        let { contractName, bytecode, sourceMap, deployedBytecode, deployedSourceMap, immutableReferences, sourcePath, source, ast, abi, compiler, generatedSources, deployedGeneratedSources, metadata } = artifact;\n        if (artifact.contract_name) {\n            //just in case\n            contractName = artifact.contract_name;\n            //dunno what's up w/ the type of contract_name, but it needs coercing\n        }\n        debug(\"contractName: %s\", contractName);\n        let contractObject = {\n            contractName,\n            bytecode,\n            sourceMap,\n            deployedBytecode,\n            deployedSourceMap,\n            immutableReferences,\n            abi,\n            generatedSources: normalizeGeneratedSources(generatedSources, compiler),\n            deployedGeneratedSources: normalizeGeneratedSources(deployedGeneratedSources, compiler),\n            compiler\n        };\n        let sourceObject = {\n            sourcePath,\n            source,\n            ast: ast,\n            compiler,\n            language: inferLanguage(ast, compiler, sourcePath)\n        };\n        //ast needs to be coerced because schema doesn't quite match our types here...\n        if (metadata) {\n            try {\n                const parsedMetadata = JSON.parse(metadata); //sorry\n                const settings = parsedMetadata.settings;\n                const viaIR = settings.viaIR;\n                contractObject.settings = { viaIR };\n                sourceObject.settings = { viaIR };\n            }\n            catch (_a) {\n                //if metadata doesn't parse, or we hit undefineds, ignore it\n            }\n        }\n        //if files or sources was passed, trust that to determine the source index\n        //(assuming we have a sourcePath! currently it will be absent when dealing with\n        //Solidity versions <0.4.9; presumably we will fix this if we ever properly\n        //support versions that old, but for now this is necessary to get debug -x to work)\n        if ((files || inputSources) && sourcePath) {\n            //note: we never set the unreliableSourceOrder flag in this branch;\n            //we just trust files/sources.  If this info is bad, then, uh, too bad.\n            debug(\"inputSources: %O\", inputSources);\n            debug(\"files: %O\", files);\n            debug(\"sourcePath: %O\", sourcePath);\n            const index = inputSources\n                ? inputSources.findIndex(source => source.sourcePath === sourcePath)\n                : files.indexOf(sourcePath);\n            if (!inputSources) {\n                //if inputSources was passed, we'll handle this separately below\n                sourceObject.id = index.toString(); //HACK\n                sources[index] = sourceObject;\n            }\n            debug(\"files || inputSources; index: %d\", index);\n            contractObject.primarySourceId = index.toString(); //HACK\n        }\n        else {\n            //if neither was passed, attempt to determine it from the ast\n            let index;\n            let needsAdding;\n            if (sourceObject.ast) {\n                //note: this works for both Solidity and Vyper\n                index = sourceIndexForAst(sourceObject.ast); //sourceObject.ast for typing reasons\n            }\n            else if (compiler && compiler.name === \"vyper\") {\n                index = 0; //if it's Vyper but there's no AST, we can\n                //assume that it was compiled alone and therefore has index 0\n            }\n            //if that didn't work, try the source map\n            if (index === undefined && (sourceMap || deployedSourceMap)) {\n                const sourceMapString = simpleShimSourceMap(deployedSourceMap || sourceMap);\n                index = extractPrimarySource(sourceMapString);\n            }\n            //else leave undefined for now\n            ({ index, needsAdding, unreliableSourceOrder } = getIndexToAddAt(sourceObject, index, sources, unreliableSourceOrder));\n            if (needsAdding) {\n                //if we're in this case, inputSources was not passed\n                sourceObject.id = index.toString(); //HACK\n                sources[index] = sourceObject;\n                debug(\"else; index: %d\", index);\n            }\n            //whether needed adding or not, set the source ID on the contract object\n            contractObject.primarySourceId = index.toString(); //HACK\n            debug(\"(no index unless mentioned)\");\n        }\n        contracts.push(contractObject);\n    }\n    //now: check for id overlap with internal sources\n    //(don't bother if inputSources or files was passed)\n    if (!inputSources && !files) {\n        for (let contract of contracts) {\n            const { generatedSources, deployedGeneratedSources } = contract;\n            for (let index in generatedSources) {\n                if (index in sources) {\n                    unreliableSourceOrder = true;\n                }\n            }\n            for (let index in deployedGeneratedSources) {\n                if (index in sources) {\n                    unreliableSourceOrder = true;\n                }\n            }\n        }\n    }\n    let compiler;\n    if (options.compiler) {\n        compiler = options.compiler;\n    }\n    else if (!unreliableSourceOrder && contracts.length > 0) {\n        //if things were actually compiled together, we should just be able\n        //to pick an arbitrary one\n        compiler = contracts[0].compiler;\n    }\n    let settings; //we'll do the same thing with settings\n    if (options.settings) {\n        settings = options.settings;\n    }\n    else if (!unreliableSourceOrder && contracts.length > 0) {\n        //if things were actually compiled together, we should just be able\n        //to pick an arbitrary one\n        settings = contracts[0].settings;\n    }\n    //if input sources was passed, set up the sources object directly :)\n    if (inputSources) {\n        sources = inputSources.map(({ sourcePath, contents: source, ast, language }, index) => ({\n            sourcePath,\n            source,\n            ast: ast,\n            language,\n            id: index.toString(),\n            compiler //redundant but let's include it\n        }));\n    }\n    return {\n        id: shimmedCompilationId,\n        unreliableSourceOrder,\n        sources,\n        contracts,\n        compiler,\n        settings\n    };\n}\nexports.shimContracts = shimContracts;\n//note: this works for Vyper too!\nfunction sourceIndexForAst(ast) {\n    if (Array.isArray(ast)) {\n        //special handling for old Vyper versions\n        ast = ast[0];\n    }\n    if (!ast) {\n        return undefined;\n    }\n    return parseInt(ast.src.split(\":\")[2]);\n    //src is given as start:length:file.\n    //we want just the file.\n}\nfunction getContractNode(contract, compilation) {\n    const { contractName, sourceMap, deployedSourceMap, primarySourceId } = contract;\n    const { unreliableSourceOrder, sources } = compilation;\n    let sourcesToCheck;\n    //we will attempt to locate the primary source;\n    //if we can't find it, we'll just check every source in this\n    //compilation.\n    if (primarySourceId !== undefined) {\n        sourcesToCheck = [\n            sources.find(source => source && source.id === primarySourceId)\n        ];\n    }\n    else if (!unreliableSourceOrder && (deployedSourceMap || sourceMap)) {\n        const sourceMapString = simpleShimSourceMap(deployedSourceMap || sourceMap);\n        let sourceId = extractPrimarySource(sourceMapString);\n        sourcesToCheck = [sources[sourceId]];\n    }\n    else {\n        //WARNING: if we end up in this case, we could get the wrong contract!\n        //(but we shouldn't end up here)\n        sourcesToCheck = sources;\n    }\n    return sourcesToCheck.reduce((foundNode, source) => {\n        if (foundNode || !source) {\n            return foundNode;\n        }\n        if (!source.ast || source.language !== \"Solidity\") {\n            //ignore non-Solidity ASTs for now, we don't support them yet\n            return undefined;\n        }\n        return source.ast.nodes.find(node => node.nodeType === \"ContractDefinition\" && node.name === contractName);\n    }, undefined);\n}\nexports.getContractNode = getContractNode;\n/**\n * extract the primary source from a source map\n * (i.e., the source for the first instruction, found\n * between the second and third colons)\n */\nfunction extractPrimarySource(sourceMap) {\n    if (!sourceMap) {\n        //HACK?\n        return 0; //in this case (e.g. a Vyper contract with an old-style\n        //source map) we infer that it was compiled by itself\n    }\n    return parseInt(sourceMap.match(/^[^:]*:[^:]*:([^:]*):/)[1] || \"0\");\n}\nfunction normalizeGeneratedSources(generatedSources, compiler) {\n    if (!generatedSources) {\n        return [];\n    }\n    if (!isGeneratedSources(generatedSources)) {\n        return generatedSources; //if already normalizeed, leave alone\n    }\n    let sources = []; //output\n    for (let source of generatedSources) {\n        sources[source.id] = {\n            id: source.id.toString(),\n            sourcePath: source.name,\n            source: source.contents,\n            //ast needs to be coerced because schema doesn't quite match our types here...\n            ast: source.ast,\n            compiler: compiler,\n            language: source.language\n        };\n    }\n    return sources;\n}\n//HACK\nfunction isGeneratedSources(sources) {\n    //note: for some reason arr.includes(undefined) returns true on sparse arrays\n    //if sources.length === 0, it's ambiguous; we'll exclude it as not needing normalization\n    return (sources.length > 0 &&\n        !sources.includes(undefined) &&\n        (sources[0].contents !== undefined ||\n            sources[0].name !== undefined));\n}\n//HACK, maybe?\nfunction inferLanguage(ast, compiler, sourcePath) {\n    if (ast) {\n        if (ast.nodeType === \"SourceUnit\") {\n            return \"Solidity\";\n        }\n        else if (ast.nodeType && ast.nodeType.startsWith(\"Yul\")) {\n            //Every Yul source I've seen has YulBlock as the root, but\n            //I'm not sure that that's *always* the case\n            return \"Yul\";\n        }\n        else if (Array.isArray(ast) || ast.ast_type === \"Module\") {\n            return \"Vyper\";\n        }\n    }\n    else if (compiler) {\n        if (compiler.name === \"vyper\") {\n            return \"Vyper\";\n        }\n        else if (compiler.name === \"solc\") {\n            //assuming sources compiled with solc without sourcePath are Solidity\n            if (sourcePath && sourcePath.endsWith(\".yul\")) {\n                return \"Yul\";\n            }\n            else {\n                return \"Solidity\";\n            }\n        }\n        else {\n            return undefined;\n        }\n    }\n    else {\n        return undefined;\n    }\n}\nfunction getIndexToAddAt(sourceObject, index, sources, unreliableSourceOrder) {\n    debug(\"sourcePath: %s\", sourceObject.sourcePath);\n    debug(\"given index: %d\", index);\n    debug(\"sources: %o\", sources.map(source => source.sourcePath));\n    //first: is this already there? only add it if it's not.\n    //(we determine this by sourcePath if present, and the actual source\n    //contents if not)\n    const existingIndex = sources.findIndex(existingSource => existingSource && //findIndex treats absent as undefined, so we need this guard\n        // (array may be sparse)\n        (existingSource.sourcePath === sourceObject.sourcePath ||\n            (!sourceObject.sourcePath &&\n                !existingSource.sourcePath &&\n                existingSource.source === sourceObject.source)));\n    if (existingIndex === -1) {\n        //it's not already there, let's add it\n        if (unreliableSourceOrder || index === undefined || index in sources) {\n            //if we can't add it at the correct spot, set the\n            //unreliable source order flag\n            debug(\"collision!\");\n            unreliableSourceOrder = true;\n        }\n        if (unreliableSourceOrder) {\n            //in case of unreliable source order, we'll ignore what indices\n            //things are *supposed* to have and just append things to the end\n            index = sources.length;\n        }\n        //otherwise, just leave things alone\n        return {\n            index,\n            needsAdding: true,\n            unreliableSourceOrder\n        };\n    }\n    else {\n        debug(\"already present, not adding\");\n        return {\n            index: existingIndex,\n            needsAdding: false,\n            unreliableSourceOrder\n        };\n    }\n}\n/**\n * convert Vyper source maps to solidity ones\n * (note we won't bother handling the case where the compressed\n * version doesn't exist; that will have to wait for a later version)\n */\nfunction simpleShimSourceMap(sourceMap) {\n    if (sourceMap === undefined) {\n        return undefined; //undefined case\n    }\n    else if (typeof sourceMap === \"object\") {\n        return sourceMap.pc_pos_map_compressed; //Vyper object case\n    }\n    else {\n        try {\n            return JSON.parse(sourceMap).pc_pos_map_compressed; //Vyper JSON case\n        }\n        catch (_) {\n            return sourceMap; //Solidity case\n        }\n    }\n}\nexports.simpleShimSourceMap = simpleShimSourceMap;\n/**\n * collects user defined types & tagged outputs for a given set of compilations,\n * returning both the definition nodes and (for the types) the type objects\n *\n * \"Tagged outputs\" means user-defined things that are output by a contract\n * (not input to a contract), and which are distinguished by (potentially\n * ambiguous) selectors.  So, events and custom errors are tagged outputs.\n * Function arguments are not tagged outputs (they're not outputs).\n * Return values are not tagged outputs (they don't have a selector).\n * Built-in errors (Error(string) and Panic(uint))... OK I guess those could\n * be considered tagged outputs, but we're only looking at user-defined ones\n * here.\n */\nfunction collectUserDefinedTypesAndTaggedOutputs(compilations) {\n    let references = {};\n    let types = {};\n    for (const compilation of compilations) {\n        references[compilation.id] = {};\n        types[compilation.id] = {\n            compiler: compilation.compiler,\n            types: {}\n        };\n        for (const source of compilation.sources) {\n            if (!source) {\n                continue; //remember, sources could be empty if shimmed!\n            }\n            const { ast, compiler, language } = source;\n            if (language === \"Solidity\" && ast) {\n                //don't check Yul or Vyper sources!\n                for (const node of ast.nodes) {\n                    if (node.nodeType === \"StructDefinition\" ||\n                        node.nodeType === \"EnumDefinition\" ||\n                        node.nodeType === \"UserDefinedValueTypeDefinition\" ||\n                        node.nodeType === \"ContractDefinition\") {\n                        references[compilation.id][node.id] = node;\n                        //we don't have all the references yet, but we actually don't need them :)\n                        const dataType = Ast.Import.definitionToStoredType(node, compilation.id, compiler, references[compilation.id]);\n                        types[compilation.id].types[dataType.id] = dataType;\n                    }\n                    else if (node.nodeType === \"EventDefinition\" ||\n                        node.nodeType === \"ErrorDefinition\") {\n                        references[compilation.id][node.id] = node;\n                    }\n                    if (node.nodeType === \"ContractDefinition\") {\n                        for (const subNode of node.nodes) {\n                            if (subNode.nodeType === \"StructDefinition\" ||\n                                subNode.nodeType === \"EnumDefinition\" ||\n                                subNode.nodeType === \"UserDefinedValueTypeDefinition\") {\n                                references[compilation.id][subNode.id] = subNode;\n                                //we don't have all the references yet, but we only need the\n                                //reference to the defining contract, which we just added above!\n                                const dataType = Ast.Import.definitionToStoredType(subNode, compilation.id, compiler, references[compilation.id]);\n                                types[compilation.id].types[dataType.id] = dataType;\n                            }\n                            else if (subNode.nodeType === \"EventDefinition\" ||\n                                subNode.nodeType === \"ErrorDefinition\") {\n                                references[compilation.id][subNode.id] = subNode;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return {\n        definitions: references,\n        typesByCompilation: types,\n        types: Format.Types.forgetCompilations(types)\n    };\n}\nexports.collectUserDefinedTypesAndTaggedOutputs = collectUserDefinedTypesAndTaggedOutputs;\n/**\n * Given a list of compilations, and an artifact appearing in one\n * of those compilations, finds the compilation and the corresponding\n * contract object\n * (these may be undefined if they can't be found)\n */\nfunction findCompilationAndContract(compilations, artifact) {\n    const deployedBytecode = compile_common_1.Shims.NewToLegacy.forBytecode(artifact.deployedBytecode);\n    const bytecode = compile_common_1.Shims.NewToLegacy.forBytecode(artifact.bytecode);\n    let firstNameMatch;\n    let multipleNameMatches = false;\n    for (const compilation of compilations) {\n        for (const contract of compilation.contracts) {\n            const nameMatches = contract.contractName ===\n                (artifact.contractName || artifact.contract_name);\n            if (nameMatches) {\n                if (bytecode) {\n                    if (compile_common_1.Shims.NewToLegacy.forBytecode(contract.bytecode) === bytecode) {\n                        return { compilation, contract };\n                    }\n                }\n                else if (deployedBytecode) {\n                    if (compile_common_1.Shims.NewToLegacy.forBytecode(contract.deployedBytecode) ===\n                        deployedBytecode) {\n                        return { compilation, contract };\n                    }\n                }\n                else if (!firstNameMatch) {\n                    //if we have a name match, but no bytecode to go by, record this one.\n                    //if it turns out to be the only one, we'll return it later.\n                    firstNameMatch = { compilation, contract };\n                }\n                else if (!multipleNameMatches) {\n                    //on the other hand, if there *is* an existing name match already,\n                    //record that we've got multiple.\n                    multipleNameMatches = true;\n                }\n            }\n        }\n    }\n    //once the loop is done, if we haven't returned a bytecode match,\n    //check if we've got a unique name match, and return it if so\n    if (firstNameMatch && !multipleNameMatches) {\n        return firstNameMatch;\n    }\n    //otherwise, if there's no bytecode match, and either no name match\n    //or multiple name matches, just return a default fallback\n    const defaultContract = {\n        contractName: artifact.contractName || artifact.contract_name,\n        abi: artifact.abi\n    };\n    const defaultCompilation = {\n        id: \"defaultCompilation\",\n        sources: [],\n        contracts: [defaultContract]\n    };\n    return {\n        compilation: defaultCompilation,\n        contract: defaultContract\n    };\n}\nexports.findCompilationAndContract = findCompilationAndContract;\nfunction projectInfoIsCodecStyle(info) {\n    return Boolean(info.compilations);\n}\nfunction projectInfoIsCommonStyle(info) {\n    return Boolean(info.commonCompilations);\n}\nfunction projectInfoIsArtifacts(info) {\n    return Boolean(info.artifacts);\n}\nfunction infoToCompilations(projectInfo, nonceString) {\n    if (!projectInfo) {\n        throw new errors_1.NoProjectInfoError();\n    }\n    if (projectInfoIsCodecStyle(projectInfo)) {\n        return projectInfo.compilations;\n    }\n    else if (projectInfoIsCommonStyle(projectInfo)) {\n        return shimCompilations(projectInfo.commonCompilations, nonceString);\n    }\n    else if (projectInfoIsArtifacts(projectInfo)) {\n        return shimArtifacts(projectInfo.artifacts, undefined, nonceString);\n    }\n}\nexports.infoToCompilations = infoToCompilations;\nfunction findRepeatCompilationIds(compilations) {\n    let repeats = new Set();\n    for (let i = 0; i < compilations.length; i++) {\n        for (let j = i + 1; j < compilations.length; j++) {\n            if (compilations[i].id === compilations[j].id) {\n                repeats.add(compilations[i].id);\n            }\n        }\n    }\n    return repeats;\n}\nexports.findRepeatCompilationIds = findRepeatCompilationIds;\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}