{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.formatFunctionLike = exports.ReturndataDecodingInspector = exports.LogDecodingInspector = exports.containsDeliberateReadError = exports.CalldataDecodingInspector = exports.nativizeEventArgs = exports.nativizeReturn = exports.nativize = exports.nativizeAccessList = exports.unsafeNativizeVariables = exports.unsafeNativize = exports.ResultInspector = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"codec:export\");\n\nconst os_1 = __importDefault(require(\"os\"));\n\nconst util_1 = __importDefault(require(\"util\"));\n\nconst Format = __importStar(require(\"./format\"));\n\nconst Conversion = __importStar(require(\"./conversion\"));\n\nconst inspect_1 = require(\"./format/utils/inspect\");\n\nObject.defineProperty(exports, \"ResultInspector\", {\n  enumerable: true,\n  get: function () {\n    return inspect_1.ResultInspector;\n  }\n});\nObject.defineProperty(exports, \"unsafeNativize\", {\n  enumerable: true,\n  get: function () {\n    return inspect_1.unsafeNativize;\n  }\n});\nObject.defineProperty(exports, \"unsafeNativizeVariables\", {\n  enumerable: true,\n  get: function () {\n    return inspect_1.unsafeNativizeVariables;\n  }\n});\nObject.defineProperty(exports, \"nativizeAccessList\", {\n  enumerable: true,\n  get: function () {\n    return inspect_1.nativizeAccessList;\n  }\n});\n/**\n * This function is similar to\n * [[Format.Utils.Inspect.unsafeNativize|unsafeNativize]], but is intended to\n * be safe, and also allows for different output formats.  The only currently\n * supported format is \"ethers\", which is intended to match the way that\n * Truffle Contract currently returns values (based on the Ethers decoder).  As\n * such, it only handles ABI types, and in addition does not handle the types\n * fixed, ufixed, or function.  Note that in these cases it returns `undefined`\n * rather than throwing, as we want this function to be used in contexts where\n * it had better not throw.  It also does not handle circularities, for similar\n * reasons.\n *\n * To handle numeric types, this function takes an optional numberFormatter\n * option that tells it how to handle numbers; this function should take a\n * BigInt as input.  By default, this function will be the identity, and so\n * numbers will be represented as BigInts.\n *\n * Note that this function begins by calling abify, so out-of-range enums (that\n * aren't so out-of-range as to be padding errors) will not return `undefined`.\n * Out-of-range booleans similarly will return true rather than `undefined`.\n * However, other range errors may return `undefined`; this may technically be a\n * slight incompatibility with existing behavior, but should not be relevant\n * except in quite unusual cases.\n *\n * In order to match the behavior for tuples, tuples will be transformed into\n * arrays, but named entries will additionally be keyed by name.  Moreover,\n * indexed variables of reference type will be nativized to an undecoded hex\n * string.\n */\n\nfunction nativize(result) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  const numberFormatter = options.numberFormatter || (x => x);\n\n  const format = options.format || \"ethers\";\n\n  switch (format) {\n    case \"ethers\":\n      return ethersCompatibleNativize(result, numberFormatter);\n  }\n}\n\nexports.nativize = nativize;\n\nfunction ethersCompatibleNativize(result) {\n  let numberFormatter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x => x;\n\n  //note: the original version of this function began by calling abify,\n  //but we don't do that here because abify requires a userDefinedTypes\n  //parameter and we don't want that.\n  //However, it only needs that to handle getting the types right.  Since\n  //we don't care about that here, we instead do away with abify and handle\n  //such matters ourselves (which is less convenient, yeah).\n  switch (result.kind) {\n    case \"error\":\n      switch (result.error.kind) {\n        case \"IndexedReferenceTypeError\":\n          //strictly speaking for arrays ethers will fail to decode\n          //rather than do this, but, eh\n          return result.error.raw;\n\n        case \"EnumOutOfRangeError\":\n          return numberFormatter(Conversion.toBigInt(result.error.rawAsBN));\n\n        default:\n          return undefined;\n      }\n\n    case \"value\":\n      switch (result.type.typeClass) {\n        case \"uint\":\n        case \"int\":\n          const asBN = result.value.asBN;\n          return numberFormatter(Conversion.toBigInt(asBN));\n\n        case \"enum\":\n          const numericAsBN = result.value.numericAsBN;\n          return numberFormatter(Conversion.toBigInt(numericAsBN));\n\n        case \"bool\":\n          return result.value.asBoolean;\n\n        case \"bytes\":\n          const asHex = result.value.asHex;\n          return asHex !== \"0x\" ? asHex : null;\n\n        case \"address\":\n          return result.value.asAddress;\n\n        case \"contract\":\n          return result.value.address;\n\n        case \"string\":\n          {\n            const coercedResult = result;\n\n            switch (coercedResult.value.kind) {\n              case \"valid\":\n                return coercedResult.value.asString;\n\n              case \"malformed\":\n                // this will turn malformed utf-8 into replacement characters (U+FFFD) (WARNING)\n                // note we need to cut off the 0x prefix\n                return Buffer.from(coercedResult.value.asHex.slice(2), \"hex\").toString();\n            }\n          }\n\n        case \"userDefinedValueType\":\n          return ethersCompatibleNativize(result.value, numberFormatter);\n\n        case \"array\":\n          return result.value.map(value => ethersCompatibleNativize(value, numberFormatter));\n\n        case \"tuple\":\n        case \"struct\":\n          //in this case, we need the result to be an array, but also\n          //to have the field names (where extant) as keys\n          const nativized = [];\n          const pairs = result.value;\n\n          for (const {\n            name,\n            value\n          } of pairs) {\n            const nativizedValue = ethersCompatibleNativize(value, numberFormatter);\n            nativized.push(nativizedValue);\n\n            if (name) {\n              nativized[name] = nativizedValue;\n            }\n          }\n\n          return nativized;\n\n        case \"function\":\n          switch (result.type.visibility) {\n            case \"external\":\n              const coercedResult = result; //ethers per se doesn't handle this, but web3's hacked version will\n              //sometimes decode these as just a bytes24, so let's do that\n\n              return coercedResult.value.contract.address.toLowerCase() + coercedResult.value.selector.slice(2);\n\n            case \"internal\":\n              return undefined;\n          }\n\n        case \"fixed\":\n        case \"ufixed\":\n        default:\n          return undefined;\n      }\n\n  }\n}\n/**\n * This function is similar to [[nativize]], but takes\n * a [[ReturndataDecoding]].  If there's only one returned value, it\n * will be run through compatibleNativize but otherwise unaltered;\n * otherwise the results will be put in an object.\n *\n * Note that if the ReturndataDecoding is not a [[ReturnDecoding]],\n * this will just return `undefined`.\n */\n\n\nfunction nativizeReturn(decoding) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  const numberFormatter = options.numberFormatter || (x => x);\n\n  const format = options.format || \"ethers\";\n\n  switch (format) {\n    case \"ethers\":\n      return ethersCompatibleNativizeReturn(decoding, numberFormatter);\n  }\n}\n\nexports.nativizeReturn = nativizeReturn;\n\nfunction ethersCompatibleNativizeReturn(decoding) {\n  let numberFormatter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x => x;\n\n  if (decoding.kind !== \"return\") {\n    return undefined;\n  }\n\n  if (decoding.arguments.length === 1) {\n    return ethersCompatibleNativize(decoding.arguments[0].value, numberFormatter);\n  }\n\n  const result = {};\n\n  for (let i = 0; i < decoding.arguments.length; i++) {\n    const {\n      name,\n      value\n    } = decoding.arguments[i];\n    const nativized = ethersCompatibleNativize(value, numberFormatter);\n    result[i] = nativized;\n\n    if (name) {\n      result[name] = nativized;\n    }\n  }\n\n  return result;\n}\n/**\n * This function is similar to [[compatibleNativize]], but takes\n * a [[LogDecoding]], and puts the results in an object.  Note\n * that this does not return the entire event info, but just the\n * `args` for the event.\n */\n\n\nfunction nativizeEventArgs(decoding) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  const numberFormatter = options.numberFormatter || (x => x);\n\n  const format = options.format || \"ethers\";\n\n  switch (format) {\n    case \"ethers\":\n      return ethersCompatibleNativizeEventArgs(decoding, numberFormatter);\n  }\n}\n\nexports.nativizeEventArgs = nativizeEventArgs;\n\nfunction ethersCompatibleNativizeEventArgs(decoding) {\n  let numberFormatter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x => x;\n  const result = {};\n\n  for (let i = 0; i < decoding.arguments.length; i++) {\n    const {\n      name,\n      value\n    } = decoding.arguments[i];\n    const nativized = ethersCompatibleNativize(value, numberFormatter);\n    result[i] = nativized;\n\n    if (name) {\n      result[name] = nativized;\n    }\n  } //note: if you have an argument named __length__, what ethers\n  //actually does is... weird.  we're just going to do this instead,\n  //which is simpler and probably more useful, even if it's not strictly\n  //the same (I *seriously* doubt anyone was relying on the old behavior,\n  //because it's, uh, not very useful)\n\n\n  result.__length__ = decoding.arguments.length;\n  return result;\n}\n/**\n * Similar to [[ResultInspector]], but for a [[CalldataDecoding]].\n * See [[ResultInspector]] for more information.\n */\n\n\nclass CalldataDecodingInspector {\n  constructor(decoding) {\n    this.decoding = decoding;\n  }\n  /**\n   * @dev non-standard alternative interface name used by browser-util-inspect\n   *      package\n   */\n\n\n  inspect(depth, options) {\n    return this[util_1.default.inspect.custom].bind(this)(depth, options);\n  }\n\n  [util_1.default.inspect.custom](depth, options) {\n    switch (this.decoding.kind) {\n      case \"function\":\n        const fullName = `${this.decoding.class.typeName}.${this.decoding.abi.name}`;\n\n        if (this.decoding.interpretations.multicall) {\n          return formatMulticall(fullName, this.decoding.interpretations.multicall, options);\n        } else if (this.decoding.interpretations.aggregate) {\n          return formatAggregate(fullName, this.decoding.interpretations.aggregate, options);\n        } else if (this.decoding.interpretations.tryAggregate) {\n          const {\n            requireSuccess,\n            calls\n          } = this.decoding.interpretations.tryAggregate;\n          return formatAggregate(fullName, calls, options, \"requireSuccess\", options.stylize(requireSuccess.toString(), \"number\"));\n        } else if (this.decoding.interpretations.deadlinedMulticall) {\n          const {\n            deadline,\n            calls: decodings\n          } = this.decoding.interpretations.deadlinedMulticall;\n          return formatMulticall(fullName, decodings, options, \"deadline\", options.stylize(deadline.toString(), \"number\"));\n        } else if (this.decoding.interpretations.specifiedBlockhashMulticall) {\n          const {\n            specifiedBlockhash,\n            calls: decodings\n          } = this.decoding.interpretations.specifiedBlockhashMulticall;\n          return formatMulticall(fullName, decodings, options, \"previousBlockhash\", options.stylize(specifiedBlockhash, \"number\"));\n        }\n\n        return formatFunctionLike(fullName, this.decoding.arguments, options);\n\n      case \"constructor\":\n        return formatFunctionLike(`new ${this.decoding.class.typeName}`, this.decoding.arguments, options);\n\n      case \"message\":\n        const {\n          data,\n          abi\n        } = this.decoding; //we'll set up a value and inspect that :)\n\n        const codecValue = {\n          kind: \"value\",\n          type: {\n            typeClass: \"bytes\",\n            kind: \"dynamic\"\n          },\n          value: {\n            asHex: data\n          }\n        };\n\n        if (abi) {\n          return formatFunctionLike(`${this.decoding.class.typeName}.${abi.type}`, [{\n            value: codecValue\n          }], options, true // we don't need to see the type here!\n          );\n        } else {\n          return `Sent raw data to ${this.decoding.class.typeName}: ${util_1.default.inspect(new inspect_1.ResultInspector(codecValue), options)}`;\n        }\n\n      case \"unknown\":\n        return \"Receiving contract could not be identified.\";\n\n      case \"create\":\n        return \"Created contract could not be identified.\";\n    }\n  }\n\n}\n\nexports.CalldataDecodingInspector = CalldataDecodingInspector;\n\nfunction containsDeliberateReadError(result) {\n  switch (result.kind) {\n    case \"value\":\n      switch (result.type.typeClass) {\n        case \"struct\":\n          //this is currently only intended for use with storage variables, so I\n          //won't bother with handling tuple, magic, options\n          return result.value.some(_ref => {\n            let {\n              value\n            } = _ref;\n            return containsDeliberateReadError(value);\n          });\n\n        case \"array\":\n          return result.value.some(containsDeliberateReadError);\n\n        case \"mapping\":\n          return result.value.some(_ref2 => {\n            let {\n              value\n            } = _ref2;\n            return containsDeliberateReadError(value);\n          });\n\n        default:\n          return false;\n      }\n\n    case \"error\":\n      switch (result.error.kind) {\n        case \"StorageNotSuppliedError\":\n        case \"CodeNotSuppliedError\":\n          return true;\n\n        default:\n          return false;\n      }\n\n  }\n}\n\nexports.containsDeliberateReadError = containsDeliberateReadError;\n/**\n * Similar to [[ResultInspector]], but for a [[LogDecoding]].\n * See [[ResultInspector]] for more information.\n */\n\nclass LogDecodingInspector {\n  constructor(decoding) {\n    this.decoding = decoding;\n  }\n  /**\n   * @dev non-standard alternative interface name used by browser-util-inspect\n   *      package\n   */\n\n\n  inspect(depth, options) {\n    return this[util_1.default.inspect.custom].bind(this)(depth, options);\n  }\n\n  [util_1.default.inspect.custom](depth, options) {\n    const className = this.decoding.definedIn ? this.decoding.definedIn.typeName : this.decoding.class.typeName;\n    const eventName = this.decoding.abi.name;\n    const fullName = `${className}.${eventName}`;\n\n    switch (this.decoding.kind) {\n      case \"event\":\n        return formatFunctionLike(fullName, this.decoding.arguments, options);\n\n      case \"anonymous\":\n        return formatFunctionLike(`<anonymous> ${fullName}`, this.decoding.arguments, options);\n    }\n  }\n\n}\n\nexports.LogDecodingInspector = LogDecodingInspector;\n/**\n * Similar to [[ResultInspector]], but for a [[ReturndataDecoding]].\n * See [[ResultInspector]] for more information.\n */\n\nclass ReturndataDecodingInspector {\n  constructor(decoding) {\n    this.decoding = decoding;\n  }\n  /**\n   * @dev non-standard alternative interface name used by browser-util-inspect\n   *      package\n   */\n\n\n  inspect(depth, options) {\n    return this[util_1.default.inspect.custom].bind(this)(depth, options);\n  }\n\n  [util_1.default.inspect.custom](depth, options) {\n    switch (this.decoding.kind) {\n      case \"return\":\n        return formatFunctionLike(\"Returned values: \", this.decoding.arguments, options);\n\n      case \"returnmessage\":\n        const {\n          data\n        } = this.decoding; //we'll just set up a value and inspect that :)\n\n        const codecValue = {\n          kind: \"value\",\n          type: {\n            typeClass: \"bytes\",\n            kind: \"dynamic\"\n          },\n          value: {\n            asHex: data\n          }\n        };\n        const dataString = util_1.default.inspect(new inspect_1.ResultInspector(codecValue), options);\n        return `Returned raw data: ${dataString}`;\n\n      case \"selfdestruct\":\n        return \"The contract self-destructed.\";\n\n      case \"failure\":\n        return \"The transaction reverted without a message.\";\n\n      case \"revert\":\n        const name = this.decoding.definedIn ? `${this.decoding.definedIn.typeName}.${this.decoding.abi.name}` : this.decoding.abi.name;\n        return formatFunctionLike(`Error thrown:${os_1.default.EOL}${name}`, this.decoding.arguments, options);\n\n      case \"bytecode\":\n        //this one gets custom handling :P\n        const contractKind = this.decoding.class.contractKind || \"contract\";\n        const firstLine = this.decoding.address !== undefined ? `Returned bytecode for a ${contractKind} ${this.decoding.class.typeName} at ${this.decoding.address}.` : `Returned bytecode for a ${contractKind} ${this.decoding.class.typeName}.`;\n\n        if (this.decoding.immutables && this.decoding.immutables.length > 0) {\n          const prefixes = this.decoding.immutables.map(_ref3 => {\n            let {\n              name,\n              class: {\n                typeName\n              }\n            } = _ref3;\n            return `${typeName}.${name}: `;\n          });\n          const maxLength = Math.max(...prefixes.map(prefix => prefix.length));\n          const paddedPrefixes = prefixes.map(prefix => prefix.padStart(maxLength));\n          const formattedValues = this.decoding.immutables.map((value, index) => {\n            const prefix = paddedPrefixes[index];\n            const formatted = indentExcludingFirstLine(util_1.default.inspect(new inspect_1.ResultInspector(value.value), options), maxLength);\n            return prefix + formatted;\n          });\n          return `Immutable values:${os_1.default.EOL}${formattedValues.join(os_1.default.EOL)}`;\n        } else {\n          return firstLine;\n        }\n\n      case \"unknownbytecode\":\n        return \"Bytecode was returned, but it could not be identified.\";\n    }\n  }\n\n}\n\nexports.ReturndataDecodingInspector = ReturndataDecodingInspector; //copied from TestRunner, but simplified for our purposes :)\n\nfunction indentArray(input, indentation) {\n  return input.map(line => \" \".repeat(indentation) + line);\n}\n\nfunction indentExcludingFirstLine(input, indentation) {\n  const lines = input.split(/\\r?\\n/);\n  return [lines[0], ...indentArray(lines.slice(1), indentation)].join(os_1.default.EOL);\n}\n\nfunction indentMiddleLines(input, indentation) {\n  const lines = input.split(/\\r?\\n/);\n\n  if (lines.length < 2) {\n    return input;\n  }\n\n  return [lines[0], ...indentArray(lines.slice(1, -1), indentation), lines[lines.length - 1]].join(os_1.default.EOL);\n} //used for formatting things that look like function calls:\n//events (including anonymous events), identifiable transactions,\n//and revert messages\n//\"header\" param should include everything before the initial parenthesis\n\n/**\n * @hidden\n */\n\n\nfunction formatFunctionLike(header, values, options) {\n  let suppressType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  let indent = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 2;\n\n  if (values.length === 0) {\n    return `${header}()`;\n  }\n\n  let formattedValues = values.map((_ref4, index) => {\n    let {\n      name,\n      indexed,\n      value\n    } = _ref4;\n    const namePrefix = name ? `${name}: ` : \"\";\n    const indexedPrefix = indexed ? \"<indexed> \" : \"\";\n    const prefix = namePrefix + indexedPrefix;\n    const displayValue = util_1.default.inspect(new inspect_1.ResultInspector(value), options);\n    const typeString = suppressType ? \"\" : ` (type: ${Format.Types.typeStringWithoutLocation(value.type)})`;\n    return indentMiddleLines(prefix + displayValue + typeString + (index < values.length - 1 ? \",\" : \"\"), indent);\n  });\n  return indentMiddleLines(`${header}(${os_1.default.EOL}${formattedValues.join(os_1.default.EOL)}${os_1.default.EOL})`, indent);\n}\n\nexports.formatFunctionLike = formatFunctionLike;\n\nfunction formatMulticall(fullName, decodings, options, additionalParameterName, additionalParameterValue) {\n  if (decodings.length === 0) {\n    return `${fullName}()`;\n  }\n\n  const indent = 2;\n  let formattedDecodings = decodings.map((decoding, index) => {\n    const formattedDecoding = decoding === null ? \"<decoding error>\" : util_1.default.inspect(new CalldataDecodingInspector(decoding), options);\n    return formattedDecoding + (index < decodings.length - 1 ? \",\" : \"\");\n  });\n\n  if (additionalParameterName) {\n    formattedDecodings.unshift(`${additionalParameterName}: ${additionalParameterValue},`);\n  }\n\n  return indentMiddleLines(`${fullName}(${os_1.default.EOL}${formattedDecodings.join(os_1.default.EOL)}${os_1.default.EOL})`, indent);\n}\n\nfunction formatAggregate(fullName, calls, options, additionalParameterName, additionalParameterValue) {\n  if (calls.length === 0) {\n    return `${fullName}()`;\n  }\n\n  const indent = 2;\n  let formattedCalls = calls.map((_ref5, index) => {\n    let {\n      address,\n      decoding\n    } = _ref5;\n    const formattedCall = decoding === null ? \"<decoding error>\" : util_1.default.inspect(new CalldataDecodingInspector(decoding), options).replace(\".\", `(${options.stylize(address, \"number\")}).`); //HACK: splice in the address\n\n    return formattedCall + (index < calls.length - 1 ? \",\" : \"\");\n  });\n\n  if (additionalParameterName) {\n    formattedCalls.unshift(`${additionalParameterName}: ${additionalParameterValue},`);\n  }\n\n  return indentMiddleLines(`${fullName}(${os_1.default.EOL}${formattedCalls.join(os_1.default.EOL)}${os_1.default.EOL})`, indent);\n}","map":{"version":3,"sources":["../../lib/export.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.formatFunctionLike = exports.ReturndataDecodingInspector = exports.LogDecodingInspector = exports.containsDeliberateReadError = exports.CalldataDecodingInspector = exports.nativizeEventArgs = exports.nativizeReturn = exports.nativize = exports.nativizeAccessList = exports.unsafeNativizeVariables = exports.unsafeNativize = exports.ResultInspector = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:export\");\nconst os_1 = __importDefault(require(\"os\"));\nconst util_1 = __importDefault(require(\"util\"));\nconst Format = __importStar(require(\"./format\"));\nconst Conversion = __importStar(require(\"./conversion\"));\nconst inspect_1 = require(\"./format/utils/inspect\");\nObject.defineProperty(exports, \"ResultInspector\", { enumerable: true, get: function () { return inspect_1.ResultInspector; } });\nObject.defineProperty(exports, \"unsafeNativize\", { enumerable: true, get: function () { return inspect_1.unsafeNativize; } });\nObject.defineProperty(exports, \"unsafeNativizeVariables\", { enumerable: true, get: function () { return inspect_1.unsafeNativizeVariables; } });\nObject.defineProperty(exports, \"nativizeAccessList\", { enumerable: true, get: function () { return inspect_1.nativizeAccessList; } });\n/**\n * This function is similar to\n * [[Format.Utils.Inspect.unsafeNativize|unsafeNativize]], but is intended to\n * be safe, and also allows for different output formats.  The only currently\n * supported format is \"ethers\", which is intended to match the way that\n * Truffle Contract currently returns values (based on the Ethers decoder).  As\n * such, it only handles ABI types, and in addition does not handle the types\n * fixed, ufixed, or function.  Note that in these cases it returns `undefined`\n * rather than throwing, as we want this function to be used in contexts where\n * it had better not throw.  It also does not handle circularities, for similar\n * reasons.\n *\n * To handle numeric types, this function takes an optional numberFormatter\n * option that tells it how to handle numbers; this function should take a\n * BigInt as input.  By default, this function will be the identity, and so\n * numbers will be represented as BigInts.\n *\n * Note that this function begins by calling abify, so out-of-range enums (that\n * aren't so out-of-range as to be padding errors) will not return `undefined`.\n * Out-of-range booleans similarly will return true rather than `undefined`.\n * However, other range errors may return `undefined`; this may technically be a\n * slight incompatibility with existing behavior, but should not be relevant\n * except in quite unusual cases.\n *\n * In order to match the behavior for tuples, tuples will be transformed into\n * arrays, but named entries will additionally be keyed by name.  Moreover,\n * indexed variables of reference type will be nativized to an undecoded hex\n * string.\n */\nfunction nativize(result, options = {}) {\n    const numberFormatter = options.numberFormatter || (x => x);\n    const format = options.format || \"ethers\";\n    switch (format) {\n        case \"ethers\":\n            return ethersCompatibleNativize(result, numberFormatter);\n    }\n}\nexports.nativize = nativize;\nfunction ethersCompatibleNativize(result, numberFormatter = x => x) {\n    //note: the original version of this function began by calling abify,\n    //but we don't do that here because abify requires a userDefinedTypes\n    //parameter and we don't want that.\n    //However, it only needs that to handle getting the types right.  Since\n    //we don't care about that here, we instead do away with abify and handle\n    //such matters ourselves (which is less convenient, yeah).\n    switch (result.kind) {\n        case \"error\":\n            switch (result.error.kind) {\n                case \"IndexedReferenceTypeError\":\n                    //strictly speaking for arrays ethers will fail to decode\n                    //rather than do this, but, eh\n                    return result.error.raw;\n                case \"EnumOutOfRangeError\":\n                    return numberFormatter(Conversion.toBigInt(result.error.rawAsBN));\n                default:\n                    return undefined;\n            }\n        case \"value\":\n            switch (result.type.typeClass) {\n                case \"uint\":\n                case \"int\":\n                    const asBN = (result).value.asBN;\n                    return numberFormatter(Conversion.toBigInt(asBN));\n                case \"enum\":\n                    const numericAsBN = result.value\n                        .numericAsBN;\n                    return numberFormatter(Conversion.toBigInt(numericAsBN));\n                case \"bool\":\n                    return result.value.asBoolean;\n                case \"bytes\":\n                    const asHex = result.value.asHex;\n                    return asHex !== \"0x\" ? asHex : null;\n                case \"address\":\n                    return result.value.asAddress;\n                case \"contract\":\n                    return result.value.address;\n                case \"string\": {\n                    const coercedResult = result;\n                    switch (coercedResult.value.kind) {\n                        case \"valid\":\n                            return coercedResult.value.asString;\n                        case \"malformed\":\n                            // this will turn malformed utf-8 into replacement characters (U+FFFD) (WARNING)\n                            // note we need to cut off the 0x prefix\n                            return Buffer.from(coercedResult.value.asHex.slice(2), \"hex\").toString();\n                    }\n                }\n                case \"userDefinedValueType\":\n                    return ethersCompatibleNativize(result.value, numberFormatter);\n                case \"array\":\n                    return result.value.map(value => ethersCompatibleNativize(value, numberFormatter));\n                case \"tuple\":\n                case \"struct\":\n                    //in this case, we need the result to be an array, but also\n                    //to have the field names (where extant) as keys\n                    const nativized = [];\n                    const pairs = (result).value;\n                    for (const { name, value } of pairs) {\n                        const nativizedValue = ethersCompatibleNativize(value, numberFormatter);\n                        nativized.push(nativizedValue);\n                        if (name) {\n                            nativized[name] = nativizedValue;\n                        }\n                    }\n                    return nativized;\n                case \"function\":\n                    switch (result.type.visibility) {\n                        case \"external\":\n                            const coercedResult = result;\n                            //ethers per se doesn't handle this, but web3's hacked version will\n                            //sometimes decode these as just a bytes24, so let's do that\n                            return (coercedResult.value.contract.address.toLowerCase() +\n                                coercedResult.value.selector.slice(2));\n                        case \"internal\":\n                            return undefined;\n                    }\n                case \"fixed\":\n                case \"ufixed\":\n                default:\n                    return undefined;\n            }\n    }\n}\n/**\n * This function is similar to [[nativize]], but takes\n * a [[ReturndataDecoding]].  If there's only one returned value, it\n * will be run through compatibleNativize but otherwise unaltered;\n * otherwise the results will be put in an object.\n *\n * Note that if the ReturndataDecoding is not a [[ReturnDecoding]],\n * this will just return `undefined`.\n */\nfunction nativizeReturn(decoding, options = {}) {\n    const numberFormatter = options.numberFormatter || (x => x);\n    const format = options.format || \"ethers\";\n    switch (format) {\n        case \"ethers\":\n            return ethersCompatibleNativizeReturn(decoding, numberFormatter);\n    }\n}\nexports.nativizeReturn = nativizeReturn;\nfunction ethersCompatibleNativizeReturn(decoding, numberFormatter = x => x) {\n    if (decoding.kind !== \"return\") {\n        return undefined;\n    }\n    if (decoding.arguments.length === 1) {\n        return ethersCompatibleNativize(decoding.arguments[0].value, numberFormatter);\n    }\n    const result = {};\n    for (let i = 0; i < decoding.arguments.length; i++) {\n        const { name, value } = decoding.arguments[i];\n        const nativized = ethersCompatibleNativize(value, numberFormatter);\n        result[i] = nativized;\n        if (name) {\n            result[name] = nativized;\n        }\n    }\n    return result;\n}\n/**\n * This function is similar to [[compatibleNativize]], but takes\n * a [[LogDecoding]], and puts the results in an object.  Note\n * that this does not return the entire event info, but just the\n * `args` for the event.\n */\nfunction nativizeEventArgs(decoding, options = {}) {\n    const numberFormatter = options.numberFormatter || (x => x);\n    const format = options.format || \"ethers\";\n    switch (format) {\n        case \"ethers\":\n            return ethersCompatibleNativizeEventArgs(decoding, numberFormatter);\n    }\n}\nexports.nativizeEventArgs = nativizeEventArgs;\nfunction ethersCompatibleNativizeEventArgs(decoding, numberFormatter = x => x) {\n    const result = {};\n    for (let i = 0; i < decoding.arguments.length; i++) {\n        const { name, value } = decoding.arguments[i];\n        const nativized = ethersCompatibleNativize(value, numberFormatter);\n        result[i] = nativized;\n        if (name) {\n            result[name] = nativized;\n        }\n    }\n    //note: if you have an argument named __length__, what ethers\n    //actually does is... weird.  we're just going to do this instead,\n    //which is simpler and probably more useful, even if it's not strictly\n    //the same (I *seriously* doubt anyone was relying on the old behavior,\n    //because it's, uh, not very useful)\n    result.__length__ = decoding.arguments.length;\n    return result;\n}\n/**\n * Similar to [[ResultInspector]], but for a [[CalldataDecoding]].\n * See [[ResultInspector]] for more information.\n */\nclass CalldataDecodingInspector {\n    constructor(decoding) {\n        this.decoding = decoding;\n    }\n    /**\n     * @dev non-standard alternative interface name used by browser-util-inspect\n     *      package\n     */\n    inspect(depth, options) {\n        return this[util_1.default.inspect.custom].bind(this)(depth, options);\n    }\n    [util_1.default.inspect.custom](depth, options) {\n        switch (this.decoding.kind) {\n            case \"function\":\n                const fullName = `${this.decoding.class.typeName}.${this.decoding.abi.name}`;\n                if (this.decoding.interpretations.multicall) {\n                    return formatMulticall(fullName, this.decoding.interpretations.multicall, options);\n                }\n                else if (this.decoding.interpretations.aggregate) {\n                    return formatAggregate(fullName, this.decoding.interpretations.aggregate, options);\n                }\n                else if (this.decoding.interpretations.tryAggregate) {\n                    const { requireSuccess, calls } = this.decoding.interpretations.tryAggregate;\n                    return formatAggregate(fullName, calls, options, \"requireSuccess\", options.stylize(requireSuccess.toString(), \"number\"));\n                }\n                else if (this.decoding.interpretations.deadlinedMulticall) {\n                    const { deadline, calls: decodings } = this.decoding.interpretations.deadlinedMulticall;\n                    return formatMulticall(fullName, decodings, options, \"deadline\", options.stylize(deadline.toString(), \"number\"));\n                }\n                else if (this.decoding.interpretations.specifiedBlockhashMulticall) {\n                    const { specifiedBlockhash, calls: decodings } = this.decoding.interpretations.specifiedBlockhashMulticall;\n                    return formatMulticall(fullName, decodings, options, \"previousBlockhash\", options.stylize(specifiedBlockhash, \"number\"));\n                }\n                return formatFunctionLike(fullName, this.decoding.arguments, options);\n            case \"constructor\":\n                return formatFunctionLike(`new ${this.decoding.class.typeName}`, this.decoding.arguments, options);\n            case \"message\":\n                const { data, abi } = this.decoding;\n                //we'll set up a value and inspect that :)\n                const codecValue = {\n                    kind: \"value\",\n                    type: {\n                        typeClass: \"bytes\",\n                        kind: \"dynamic\"\n                    },\n                    value: {\n                        asHex: data\n                    }\n                };\n                if (abi) {\n                    return formatFunctionLike(`${this.decoding.class.typeName}.${abi.type}`, [{ value: codecValue }], options, true // we don't need to see the type here!\n                    );\n                }\n                else {\n                    return `Sent raw data to ${this.decoding.class.typeName}: ${util_1.default.inspect(new inspect_1.ResultInspector(codecValue), options)}`;\n                }\n            case \"unknown\":\n                return \"Receiving contract could not be identified.\";\n            case \"create\":\n                return \"Created contract could not be identified.\";\n        }\n    }\n}\nexports.CalldataDecodingInspector = CalldataDecodingInspector;\nfunction containsDeliberateReadError(result) {\n    switch (result.kind) {\n        case \"value\":\n            switch (result.type.typeClass) {\n                case \"struct\":\n                    //this is currently only intended for use with storage variables, so I\n                    //won't bother with handling tuple, magic, options\n                    return result.value.some(({ value }) => containsDeliberateReadError(value));\n                case \"array\":\n                    return result.value.some(containsDeliberateReadError);\n                case \"mapping\":\n                    return result.value.some(({ value }) => containsDeliberateReadError(value));\n                default:\n                    return false;\n            }\n        case \"error\":\n            switch (result.error.kind) {\n                case \"StorageNotSuppliedError\":\n                case \"CodeNotSuppliedError\":\n                    return true;\n                default:\n                    return false;\n            }\n    }\n}\nexports.containsDeliberateReadError = containsDeliberateReadError;\n/**\n * Similar to [[ResultInspector]], but for a [[LogDecoding]].\n * See [[ResultInspector]] for more information.\n */\nclass LogDecodingInspector {\n    constructor(decoding) {\n        this.decoding = decoding;\n    }\n    /**\n     * @dev non-standard alternative interface name used by browser-util-inspect\n     *      package\n     */\n    inspect(depth, options) {\n        return this[util_1.default.inspect.custom].bind(this)(depth, options);\n    }\n    [util_1.default.inspect.custom](depth, options) {\n        const className = this.decoding.definedIn\n            ? this.decoding.definedIn.typeName\n            : this.decoding.class.typeName;\n        const eventName = this.decoding.abi.name;\n        const fullName = `${className}.${eventName}`;\n        switch (this.decoding.kind) {\n            case \"event\":\n                return formatFunctionLike(fullName, this.decoding.arguments, options);\n            case \"anonymous\":\n                return formatFunctionLike(`<anonymous> ${fullName}`, this.decoding.arguments, options);\n        }\n    }\n}\nexports.LogDecodingInspector = LogDecodingInspector;\n/**\n * Similar to [[ResultInspector]], but for a [[ReturndataDecoding]].\n * See [[ResultInspector]] for more information.\n */\nclass ReturndataDecodingInspector {\n    constructor(decoding) {\n        this.decoding = decoding;\n    }\n    /**\n     * @dev non-standard alternative interface name used by browser-util-inspect\n     *      package\n     */\n    inspect(depth, options) {\n        return this[util_1.default.inspect.custom].bind(this)(depth, options);\n    }\n    [util_1.default.inspect.custom](depth, options) {\n        switch (this.decoding.kind) {\n            case \"return\":\n                return formatFunctionLike(\"Returned values: \", this.decoding.arguments, options);\n            case \"returnmessage\":\n                const { data } = this.decoding;\n                //we'll just set up a value and inspect that :)\n                const codecValue = {\n                    kind: \"value\",\n                    type: {\n                        typeClass: \"bytes\",\n                        kind: \"dynamic\"\n                    },\n                    value: {\n                        asHex: data\n                    }\n                };\n                const dataString = util_1.default.inspect(new inspect_1.ResultInspector(codecValue), options);\n                return `Returned raw data: ${dataString}`;\n            case \"selfdestruct\":\n                return \"The contract self-destructed.\";\n            case \"failure\":\n                return \"The transaction reverted without a message.\";\n            case \"revert\":\n                const name = this.decoding.definedIn\n                    ? `${this.decoding.definedIn.typeName}.${this.decoding.abi.name}`\n                    : this.decoding.abi.name;\n                return formatFunctionLike(`Error thrown:${os_1.default.EOL}${name}`, this.decoding.arguments, options);\n            case \"bytecode\":\n                //this one gets custom handling :P\n                const contractKind = this.decoding.class.contractKind || \"contract\";\n                const firstLine = this.decoding.address !== undefined\n                    ? `Returned bytecode for a ${contractKind} ${this.decoding.class.typeName} at ${this.decoding.address}.`\n                    : `Returned bytecode for a ${contractKind} ${this.decoding.class.typeName}.`;\n                if (this.decoding.immutables && this.decoding.immutables.length > 0) {\n                    const prefixes = this.decoding.immutables.map(({ name, class: { typeName } }) => `${typeName}.${name}: `);\n                    const maxLength = Math.max(...prefixes.map(prefix => prefix.length));\n                    const paddedPrefixes = prefixes.map(prefix => prefix.padStart(maxLength));\n                    const formattedValues = this.decoding.immutables.map((value, index) => {\n                        const prefix = paddedPrefixes[index];\n                        const formatted = indentExcludingFirstLine(util_1.default.inspect(new inspect_1.ResultInspector(value.value), options), maxLength);\n                        return prefix + formatted;\n                    });\n                    return `Immutable values:${os_1.default.EOL}${formattedValues.join(os_1.default.EOL)}`;\n                }\n                else {\n                    return firstLine;\n                }\n            case \"unknownbytecode\":\n                return \"Bytecode was returned, but it could not be identified.\";\n        }\n    }\n}\nexports.ReturndataDecodingInspector = ReturndataDecodingInspector;\n//copied from TestRunner, but simplified for our purposes :)\nfunction indentArray(input, indentation) {\n    return input.map(line => \" \".repeat(indentation) + line);\n}\nfunction indentExcludingFirstLine(input, indentation) {\n    const lines = input.split(/\\r?\\n/);\n    return [lines[0], ...indentArray(lines.slice(1), indentation)].join(os_1.default.EOL);\n}\nfunction indentMiddleLines(input, indentation) {\n    const lines = input.split(/\\r?\\n/);\n    if (lines.length < 2) {\n        return input;\n    }\n    return [\n        lines[0],\n        ...indentArray(lines.slice(1, -1), indentation),\n        lines[lines.length - 1]\n    ].join(os_1.default.EOL);\n}\n//used for formatting things that look like function calls:\n//events (including anonymous events), identifiable transactions,\n//and revert messages\n//\"header\" param should include everything before the initial parenthesis\n/**\n * @hidden\n */\nfunction formatFunctionLike(header, values, options, suppressType = false, indent = 2 //for use by debug-utils\n) {\n    if (values.length === 0) {\n        return `${header}()`;\n    }\n    let formattedValues = values.map(({ name, indexed, value }, index) => {\n        const namePrefix = name ? `${name}: ` : \"\";\n        const indexedPrefix = indexed ? \"<indexed> \" : \"\";\n        const prefix = namePrefix + indexedPrefix;\n        const displayValue = util_1.default.inspect(new inspect_1.ResultInspector(value), options);\n        const typeString = suppressType\n            ? \"\"\n            : ` (type: ${Format.Types.typeStringWithoutLocation(value.type)})`;\n        return indentMiddleLines(prefix +\n            displayValue +\n            typeString +\n            (index < values.length - 1 ? \",\" : \"\"), indent);\n    });\n    return indentMiddleLines(`${header}(${os_1.default.EOL}${formattedValues.join(os_1.default.EOL)}${os_1.default.EOL})`, indent);\n}\nexports.formatFunctionLike = formatFunctionLike;\nfunction formatMulticall(fullName, decodings, options, additionalParameterName, additionalParameterValue) {\n    if (decodings.length === 0) {\n        return `${fullName}()`;\n    }\n    const indent = 2;\n    let formattedDecodings = decodings.map((decoding, index) => {\n        const formattedDecoding = decoding === null\n            ? \"<decoding error>\"\n            : util_1.default.inspect(new CalldataDecodingInspector(decoding), options);\n        return formattedDecoding + (index < decodings.length - 1 ? \",\" : \"\");\n    });\n    if (additionalParameterName) {\n        formattedDecodings.unshift(`${additionalParameterName}: ${additionalParameterValue},`);\n    }\n    return indentMiddleLines(`${fullName}(${os_1.default.EOL}${formattedDecodings.join(os_1.default.EOL)}${os_1.default.EOL})`, indent);\n}\nfunction formatAggregate(fullName, calls, options, additionalParameterName, additionalParameterValue) {\n    if (calls.length === 0) {\n        return `${fullName}()`;\n    }\n    const indent = 2;\n    let formattedCalls = calls.map(({ address, decoding }, index) => {\n        const formattedCall = decoding === null\n            ? \"<decoding error>\"\n            : util_1.default\n                .inspect(new CalldataDecodingInspector(decoding), options)\n                .replace(\".\", `(${options.stylize(address, \"number\")}).`); //HACK: splice in the address\n        return formattedCall + (index < calls.length - 1 ? \",\" : \"\");\n    });\n    if (additionalParameterName) {\n        formattedCalls.unshift(`${additionalParameterName}: ${additionalParameterValue},`);\n    }\n    return indentMiddleLines(`${fullName}(${os_1.default.EOL}${formattedCalls.join(os_1.default.EOL)}${os_1.default.EOL})`, indent);\n}\n//# sourceMappingURL=export.js.map"]},"metadata":{},"sourceType":"script"}