{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __exportStar = this && this.__exportStar || function (m, exports) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveAndWrap = exports.wrapForMethod = exports.wrapMultiple = exports.Messages = exports.wrap = exports.BadResponseTypeError = exports.TypeMismatchError = exports.NoUniqueBestOverloadError = exports.NoOverloadsMatchedError = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"codec:wrap\");\n\nconst priority_1 = require(\"./priority\");\n\nconst errors_1 = require(\"./errors\");\n\nObject.defineProperty(exports, \"NoOverloadsMatchedError\", {\n  enumerable: true,\n  get: function () {\n    return errors_1.NoOverloadsMatchedError;\n  }\n});\nObject.defineProperty(exports, \"NoUniqueBestOverloadError\", {\n  enumerable: true,\n  get: function () {\n    return errors_1.NoUniqueBestOverloadError;\n  }\n});\nObject.defineProperty(exports, \"TypeMismatchError\", {\n  enumerable: true,\n  get: function () {\n    return errors_1.TypeMismatchError;\n  }\n});\nObject.defineProperty(exports, \"BadResponseTypeError\", {\n  enumerable: true,\n  get: function () {\n    return errors_1.BadResponseTypeError;\n  }\n});\n\n__exportStar(require(\"./errors\"), exports);\n\nconst wrap_1 = require(\"./wrap\");\n\nObject.defineProperty(exports, \"wrap\", {\n  enumerable: true,\n  get: function () {\n    return wrap_1.wrap;\n  }\n});\n\n__exportStar(require(\"./types\"), exports);\n\nexports.Messages = __importStar(require(\"./messages\"));\n\nfunction* wrapMultiple(types, inputs, wrapOptions) {\n  //just wrap the types in a tuple and defer to wrap()\n  const combinedType = {\n    typeClass: \"tuple\",\n    memberTypes: types\n  };\n  debug(\"wrapping multiple\");\n  const wrappedTogether = yield* (0, wrap_1.wrap)(combinedType, inputs, wrapOptions);\n  return wrappedTogether.value.map(_ref => {\n    let {\n      value\n    } = _ref;\n    return value;\n  });\n}\n\nexports.wrapMultiple = wrapMultiple; //note: turns on loose\n\nfunction* wrapForMethod(method, inputs, resolveOptions) {\n  const wrapped = yield* wrapForMethodRaw(method, inputs, resolveOptions, true);\n  return wrappingToResolution(method, wrapped);\n}\n\nexports.wrapForMethod = wrapForMethod;\n\nfunction wrappingToResolution(method, wrapped) {\n  if (wrapped.length > 0 && wrapped[wrapped.length - 1].type.typeClass === \"options\") {\n    //there's options\n    const wrappedArguments = wrapped.slice(0, -1); //cut off options\n\n    const options = wrapped[wrapped.length - 1].value;\n    return {\n      method,\n      arguments: wrappedArguments,\n      options\n    };\n  } else {\n    //no options\n    return {\n      method,\n      arguments: wrapped,\n      options: {}\n    };\n  }\n} //doesn't separate out options from arguments & doesn't turn on loose\n\n\nfunction* wrapForMethodRaw(method, inputs, _ref2) {\n  let {\n    userDefinedTypes,\n    allowOptions,\n    allowJson,\n    strictBooleans\n  } = _ref2;\n  let loose = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  debug(\"wrapping for method\");\n\n  if (method.inputs.length === inputs.length) {\n    //no options case\n    debug(\"no options\");\n    return yield* wrapMultiple(method.inputs, inputs, {\n      userDefinedTypes,\n      oldOptionsBehavior: true,\n      loose,\n      name: \"<arguments>\",\n      allowJson,\n      strictBooleans\n    });\n  } else if (allowOptions && method.inputs.length === inputs.length - 1) {\n    //options case\n    debug(\"options\");\n    const inputsWithOptions = [...method.inputs, {\n      name: \"<options>\",\n      type: {\n        typeClass: \"options\"\n      }\n    }];\n    return yield* wrapMultiple(inputsWithOptions, inputs, {\n      userDefinedTypes,\n      oldOptionsBehavior: true,\n      loose,\n      name: \"<arguments>\",\n      allowJson,\n      strictBooleans\n    });\n  } else {\n    //invalid length case\n    const orOneMore = allowOptions ? ` (or ${method.inputs.length + 1} counting transaction options)` : \"\";\n    throw new errors_1.TypeMismatchError({\n      typeClass: \"tuple\",\n      memberTypes: method.inputs\n    }, inputs, \"<arguments>\", 5, `Incorrect number of arguments (expected ${method.inputs.length}${orOneMore}, got ${inputs.length})`);\n  }\n}\n\nfunction* resolveAndWrap(methods, inputs, _ref3) {\n  let {\n    userDefinedTypes,\n    allowOptions,\n    allowJson,\n    strictBooleans\n  } = _ref3;\n\n  //despite us having a good system for overload resolution, we want to\n  //use it as little as possible!  That's because using it means we don't\n  //get great error messages.  As such, we're going to do a bunch to filter\n  //things beforehand, so that we get good error messages.\n  if (methods.length === 1) {\n    //if there's only one possibility, we just defer to wrapForMethod\n    //if we ignore error messages this is silly... but we're not!\n    //this is important for good error messages in this case\n    return yield* wrapForMethod(methods[0], inputs, {\n      userDefinedTypes,\n      allowOptions,\n      allowJson,\n      strictBooleans\n    });\n  } //OK, so, there are multiple possibilities then.  let's try to filter things down by length.\n\n\n  const possibleMatches = methods.filter(method => method.inputs.length === inputs.length); //but, we've also got to account for the possibility of options\n\n  let possibleMatchesWithOptions = [];\n  let possibleOptions = {};\n\n  if (allowOptions && inputs.length > 0) {\n    //if options are allowed, we'll have to account for that.\n    //*however*, in order to minimize the number of possibilities, we won't\n    //use these unless the last argument of inputs actually looks like an options!\n    const lastInput = inputs[inputs.length - 1];\n    let isOptionsPossible = true;\n\n    try {\n      const wrappedOptions = yield* (0, wrap_1.wrap)({\n        typeClass: \"options\"\n      }, lastInput, {\n        name: \"<options>\",\n        loose: true,\n        oldOptionsBehavior: true,\n        userDefinedTypes,\n        allowJson,\n        strictBooleans\n      });\n      possibleOptions = wrappedOptions.value;\n    } catch (error) {\n      if (error instanceof errors_1.TypeMismatchError) {\n        isOptionsPossible = false;\n      } else {\n        throw error; //rethrow unexpected errors\n      }\n    }\n\n    if (isOptionsPossible) {\n      possibleMatchesWithOptions = methods.filter(method => method.inputs.length === inputs.length - 1);\n    }\n  }\n\n  debug(\"possibleMatches: %o\", possibleMatches);\n  debug(\"possibleMatchesWithOptions: %o\", possibleMatchesWithOptions); //if there's now only one possibility, great!\n\n  if (possibleMatches.length === 1 && possibleMatchesWithOptions.length === 0) {\n    //only one possibility, no options. we can just defer to wrapMultiple.\n    //(again, point is to have good error messaging)\n    debug(\"only one possibility, no options\");\n    const method = possibleMatches[0];\n    return {\n      method,\n      arguments: yield* wrapMultiple(method.inputs, inputs, {\n        userDefinedTypes,\n        loose: true,\n        name: \"<arguments>\",\n        allowJson,\n        strictBooleans\n      }),\n      options: {}\n    };\n  } else if (possibleMatchesWithOptions.length === 1 && possibleMatches.length === 0) {\n    //only one possibility, with options.  moreover, we already determined the options\n    //above, so we can once again just defer to wrapMultiple\n    debug(\"only one possiblity, with options\");\n    const method = possibleMatchesWithOptions[0];\n    return {\n      method,\n      arguments: yield* wrapMultiple(method.inputs, inputs, {\n        userDefinedTypes,\n        loose: true,\n        name: \"<arguments>\",\n        allowJson,\n        strictBooleans\n      }),\n      options: possibleOptions\n    };\n  } else if (possibleMatches.length === 0 && possibleMatchesWithOptions.length === 0) {\n    debug(\"no possibilities\"); //nothing matches!\n\n    throw new errors_1.NoOverloadsMatchedError(methods, inputs, userDefinedTypes);\n  } //if all of our attempts to avoid it have failed, we'll have to actually use\n  //our overload resolution system. note how we do *not* turn on loose in this\n  //case!\n\n\n  debug(\"attempting overload resolution\");\n  let resolutions = [];\n\n  for (const method of methods) {\n    let wrapped;\n\n    try {\n      //note this part takes care of options for us...\n      //although yes this means options will be re-wrapped, oh well\n      wrapped = yield* wrapForMethodRaw(method, inputs, {\n        userDefinedTypes,\n        allowOptions,\n        allowJson,\n        strictBooleans\n      });\n    } catch (error) {\n      //if there's an error, don't add it\n      debug(\"failed: %O\", method);\n      debug(\"because: %O\", error);\n      continue;\n    } //note that options and arguments here are both not correct, but we'll\n    //fix them up later!\n\n\n    debug(\"adding: %O\", method);\n    resolutions.push({\n      method,\n      arguments: wrapped,\n      options: {}\n    });\n  } //now: narrow it down to the most specific one(s)\n\n\n  debug(\"resolutions: %O\", resolutions);\n  resolutions = resolutions.filter(resolution => resolutions.every(comparisonResolution => !(0, priority_1.isMoreSpecificMultiple)(comparisonResolution.arguments, resolution.arguments, userDefinedTypes) || //because the comparison is nonstrict, this comparison is added to\n  //effectively make it strict\n  // i.e. we have !(x<=y) but we want !(x<y), i.e.,\n  // !(x<=y) | x=y, i.e., !(x<=y) | (x<=y & y<=x),\n  // i.e., !(x<=y) | y<=x\n  (0, priority_1.isMoreSpecificMultiple)(resolution.arguments, comparisonResolution.arguments, userDefinedTypes)));\n  debug(\"resolutions remaining: %O\", resolutions);\n\n  switch (resolutions.length) {\n    case 0:\n      //no resolution worked\n      throw new errors_1.NoOverloadsMatchedError(methods, inputs, userDefinedTypes);\n\n    case 1:\n      //there was a most specific resolution; fix up options and arguments\n      //before returning\n      const {\n        method,\n        arguments: wrapped\n      } = resolutions[0];\n      return wrappingToResolution(method, wrapped);\n\n    default:\n      //no unique most-specific resolution\n      throw new errors_1.NoUniqueBestOverloadError(resolutions);\n  }\n}\n\nexports.resolveAndWrap = resolveAndWrap;","map":{"version":3,"sources":["../../../lib/wrap/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAA,OAAA,GAAA,eAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AACA,MAAM,KAAK,GAAG,CAAA,GAAA,OAAA,CAAA,OAAA,EAAY,YAAZ,CAAd;;AAMA,MAAA,UAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AACA,MAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AAWE,MAAA,CAAA,cAAA,CAAA,OAAA,EAAA,yBAAA,EAAA;AAAA,EAAA,UAAA,EAAA,IAAA;AAAA,EAAA,GAAA,EAAA,YAAA;AAAA,WAVA,QAAA,CAAA,uBAUA;AAVuB;AAUvB,CAAA;AACA,MAAA,CAAA,cAAA,CAAA,OAAA,EAAA,2BAAA,EAAA;AAAA,EAAA,UAAA,EAAA,IAAA;AAAA,EAAA,GAAA,EAAA,YAAA;AAAA,WAVA,QAAA,CAAA,yBAUA;AAVyB;AAUzB,CAAA;AACA,MAAA,CAAA,cAAA,CAAA,OAAA,EAAA,mBAAA,EAAA;AAAA,EAAA,UAAA,EAAA,IAAA;AAAA,EAAA,GAAA,EAAA,YAAA;AAAA,WAVA,QAAA,CAAA,iBAUA;AAViB;AAUjB,CAAA;AACA,MAAA,CAAA,cAAA,CAAA,OAAA,EAAA,sBAAA,EAAA;AAAA,EAAA,UAAA,EAAA,IAAA;AAAA,EAAA,GAAA,EAAA,YAAA;AAAA,WAVA,QAAA,CAAA,oBAUA;AAVoB;AAUpB,CAAA;;AARF,YAAA,CAAA,OAAA,CAAA,UAAA,CAAA,EAAA,OAAA,CAAA;;AACA,MAAA,MAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AASS,MAAA,CAAA,cAAA,CAAA,OAAA,EAAA,MAAA,EAAA;AAAA,EAAA,UAAA,EAAA,IAAA;AAAA,EAAA,GAAA,EAAA,YAAA;AAAA,WATA,MAAA,CAAA,IASA;AATI;AASJ,CAAA;;AACT,YAAA,CAAA,OAAA,CAAA,SAAA,CAAA,EAAA,OAAA,CAAA;;AACA,OAAA,CAAA,QAAA,GAAA,YAAA,CAAA,OAAA,CAAA,YAAA,CAAA,CAAA;;AAEA,UAAiB,YAAjB,CACE,KADF,EAEE,MAFF,EAGE,WAHF,EAG0B;AAExB;AACA,QAAM,YAAY,GAA2B;AAC3C,IAAA,SAAS,EAAE,OADgC;AAE3C,IAAA,WAAW,EAAE;AAF8B,GAA7C;AAIA,EAAA,KAAK,CAAC,mBAAD,CAAL;AACA,QAAM,eAAe,GACnB,OAAO,CAAA,GAAA,MAAA,CAAA,IAAA,EAAK,YAAL,EAAmB,MAAnB,EAA2B,WAA3B,CADT;AAGA,SAAO,eAAe,CAAC,KAAhB,CAAsB,GAAtB,CAA0B;AAAA,QAAC;AAAE,MAAA;AAAF,KAAD;AAAA,WAAoC,KAApC;AAAA,GAA1B,CAAP;AACD;;AAfD,OAAA,CAAA,YAAA,GAAA,YAAA,C,CAiBA;;AACA,UAAiB,aAAjB,CACE,MADF,EAEE,MAFF,EAGE,cAHF,EAGgC;AAE9B,QAAM,OAAO,GAAG,OAAO,gBAAgB,CAAC,MAAD,EAAS,MAAT,EAAiB,cAAjB,EAAiC,IAAjC,CAAvC;AACA,SAAO,oBAAoB,CAAC,MAAD,EAAS,OAAT,CAA3B;AACD;;AAPD,OAAA,CAAA,aAAA,GAAA,aAAA;;AASA,SAAS,oBAAT,CACE,MADF,EAEE,OAFF,EAEgC;AAE9B,MACE,OAAO,CAAC,MAAR,GAAiB,CAAjB,IACA,OAAO,CAAC,OAAO,CAAC,MAAR,GAAiB,CAAlB,CAAP,CAA4B,IAA5B,CAAiC,SAAjC,KAA+C,SAFjD,EAGE;AACA;AACA,UAAM,gBAAgB,GAAG,OAAO,CAAC,KAAR,CAAc,CAAd,EAAiB,CAAC,CAAlB,CAAzB,CAFA,CAE+C;;AAC/C,UAAM,OAAO,GAAgC,OAAO,CAAC,OAAO,CAAC,MAAR,GAAiB,CAAlB,CAAP,CAC1C,KADH;AAEA,WAAO;AACL,MAAA,MADK;AAEL,MAAA,SAAS,EAAE,gBAFN;AAGL,MAAA;AAHK,KAAP;AAKD,GAbD,MAaO;AACL;AACA,WAAO;AACL,MAAA,MADK;AAEL,MAAA,SAAS,EAAE,OAFN;AAGL,MAAA,OAAO,EAAE;AAHJ,KAAP;AAKD;AACF,C,CAED;;;AACA,UAAU,gBAAV,CACE,MADF,EAEE,MAFF,SAIwB;AAAA,MADtB;AAAE,IAAA,gBAAF;AAAoB,IAAA,YAApB;AAAkC,IAAA,SAAlC;AAA6C,IAAA;AAA7C,GACsB;AAAA,MAAtB,KAAsB,uEAAL,KAAK;AAEtB,EAAA,KAAK,CAAC,qBAAD,CAAL;;AACA,MAAI,MAAM,CAAC,MAAP,CAAc,MAAd,KAAyB,MAAM,CAAC,MAApC,EAA4C;AAC1C;AACA,IAAA,KAAK,CAAC,YAAD,CAAL;AACA,WAAO,OAAO,YAAY,CAAC,MAAM,CAAC,MAAR,EAAgB,MAAhB,EAAwB;AAChD,MAAA,gBADgD;AAEhD,MAAA,kBAAkB,EAAE,IAF4B;AAGhD,MAAA,KAHgD;AAIhD,MAAA,IAAI,EAAE,aAJ0C;AAKhD,MAAA,SALgD;AAMhD,MAAA;AANgD,KAAxB,CAA1B;AAQD,GAXD,MAWO,IAAI,YAAY,IAAI,MAAM,CAAC,MAAP,CAAc,MAAd,KAAyB,MAAM,CAAC,MAAP,GAAgB,CAA7D,EAAgE;AACrE;AACA,IAAA,KAAK,CAAC,SAAD,CAAL;AACA,UAAM,iBAAiB,GAAG,CACxB,GAAG,MAAM,CAAC,MADc,EAExB;AAAE,MAAA,IAAI,EAAE,WAAR;AAAqB,MAAA,IAAI,EAAE;AAAE,QAAA,SAAS,EAAE;AAAb;AAA3B,KAFwB,CAA1B;AAIA,WAAO,OAAO,YAAY,CAAC,iBAAD,EAAoB,MAApB,EAA4B;AACpD,MAAA,gBADoD;AAEpD,MAAA,kBAAkB,EAAE,IAFgC;AAGpD,MAAA,KAHoD;AAIpD,MAAA,IAAI,EAAE,aAJ8C;AAKpD,MAAA,SALoD;AAMpD,MAAA;AANoD,KAA5B,CAA1B;AAQD,GAfM,MAeA;AACL;AACA,UAAM,SAAS,GAAG,YAAY,GAC1B,QAAQ,MAAM,CAAC,MAAP,CAAc,MAAd,GAAuB,CAAC,gCADN,GAE1B,EAFJ;AAGA,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ;AAAE,MAAA,SAAS,EAAE,OAAb;AAAsB,MAAA,WAAW,EAAE,MAAM,CAAC;AAA1C,KADI,EAEJ,MAFI,EAGJ,aAHI,EAIJ,CAJI,EAKJ,2CAA2C,MAAM,CAAC,MAAP,CAAc,MAAM,GAAG,SAAS,SAAS,MAAM,CAAC,MAAM,GAL7F,CAAN;AAOD;AACF;;AAED,UAAiB,cAAjB,CACE,OADF,EAEE,MAFF,SAG+E;AAAA,MAA7E;AAAE,IAAA,gBAAF;AAAoB,IAAA,YAApB;AAAkC,IAAA,SAAlC;AAA6C,IAAA;AAA7C,GAA6E;;AAE7E;AACA;AACA;AACA;AACA,MAAI,OAAO,CAAC,MAAR,KAAmB,CAAvB,EAA0B;AACxB;AACA;AACA;AACA,WAAO,OAAO,aAAa,CAAC,OAAO,CAAC,CAAD,CAAR,EAAa,MAAb,EAAqB;AAC9C,MAAA,gBAD8C;AAE9C,MAAA,YAF8C;AAG9C,MAAA,SAH8C;AAI9C,MAAA;AAJ8C,KAArB,CAA3B;AAMD,GAhB4E,CAiB7E;;;AACA,QAAM,eAAe,GAAG,OAAO,CAAC,MAAR,CACtB,MAAM,IAAI,MAAM,CAAC,MAAP,CAAc,MAAd,KAAyB,MAAM,CAAC,MADpB,CAAxB,CAlB6E,CAqB7E;;AACA,MAAI,0BAA0B,GAAa,EAA3C;AACA,MAAI,eAAe,GAAmB,EAAtC;;AACA,MAAI,YAAY,IAAI,MAAM,CAAC,MAAP,GAAgB,CAApC,EAAuC;AACrC;AACA;AACA;AACA,UAAM,SAAS,GAAG,MAAM,CAAC,MAAM,CAAC,MAAP,GAAgB,CAAjB,CAAxB;AACA,QAAI,iBAAiB,GAAY,IAAjC;;AACA,QAAI;AACF,YAAM,cAAc,GAClB,OAAO,CAAA,GAAA,MAAA,CAAA,IAAA,EAAK;AAAE,QAAA,SAAS,EAAE;AAAb,OAAL,EAA+B,SAA/B,EAA0C;AAC/C,QAAA,IAAI,EAAE,WADyC;AAE/C,QAAA,KAAK,EAAE,IAFwC;AAG/C,QAAA,kBAAkB,EAAE,IAH2B;AAI/C,QAAA,gBAJ+C;AAK/C,QAAA,SAL+C;AAM/C,QAAA;AAN+C,OAA1C,CADT;AAUA,MAAA,eAAe,GAAG,cAAc,CAAC,KAAjC;AACD,KAZD,CAYE,OAAO,KAAP,EAAc;AACd,UAAI,KAAK,YAAY,QAAA,CAAA,iBAArB,EAAwC;AACtC,QAAA,iBAAiB,GAAG,KAApB;AACD,OAFD,MAEO;AACL,cAAM,KAAN,CADK,CACQ;AACd;AACF;;AACD,QAAI,iBAAJ,EAAuB;AACrB,MAAA,0BAA0B,GAAG,OAAO,CAAC,MAAR,CAC3B,MAAM,IAAI,MAAM,CAAC,MAAP,CAAc,MAAd,KAAyB,MAAM,CAAC,MAAP,GAAgB,CADxB,CAA7B;AAGD;AACF;;AACD,EAAA,KAAK,CAAC,qBAAD,EAAwB,eAAxB,CAAL;AACA,EAAA,KAAK,CAAC,gCAAD,EAAmC,0BAAnC,CAAL,CAxD6E,CAyD7E;;AACA,MAAI,eAAe,CAAC,MAAhB,KAA2B,CAA3B,IAAgC,0BAA0B,CAAC,MAA3B,KAAsC,CAA1E,EAA6E;AAC3E;AACA;AACA,IAAA,KAAK,CAAC,kCAAD,CAAL;AACA,UAAM,MAAM,GAAG,eAAe,CAAC,CAAD,CAA9B;AACA,WAAO;AACL,MAAA,MADK;AAEL,MAAA,SAAS,EAAE,OAAO,YAAY,CAAC,MAAM,CAAC,MAAR,EAAgB,MAAhB,EAAwB;AACpD,QAAA,gBADoD;AAEpD,QAAA,KAAK,EAAE,IAF6C;AAGpD,QAAA,IAAI,EAAE,aAH8C;AAIpD,QAAA,SAJoD;AAKpD,QAAA;AALoD,OAAxB,CAFzB;AASL,MAAA,OAAO,EAAE;AATJ,KAAP;AAWD,GAhBD,MAgBO,IACL,0BAA0B,CAAC,MAA3B,KAAsC,CAAtC,IACA,eAAe,CAAC,MAAhB,KAA2B,CAFtB,EAGL;AACA;AACA;AACA,IAAA,KAAK,CAAC,mCAAD,CAAL;AACA,UAAM,MAAM,GAAG,0BAA0B,CAAC,CAAD,CAAzC;AACA,WAAO;AACL,MAAA,MADK;AAEL,MAAA,SAAS,EAAE,OAAO,YAAY,CAAC,MAAM,CAAC,MAAR,EAAgB,MAAhB,EAAwB;AACpD,QAAA,gBADoD;AAEpD,QAAA,KAAK,EAAE,IAF6C;AAGpD,QAAA,IAAI,EAAE,aAH8C;AAIpD,QAAA,SAJoD;AAKpD,QAAA;AALoD,OAAxB,CAFzB;AASL,MAAA,OAAO,EAAE;AATJ,KAAP;AAWD,GAnBM,MAmBA,IACL,eAAe,CAAC,MAAhB,KAA2B,CAA3B,IACA,0BAA0B,CAAC,MAA3B,KAAsC,CAFjC,EAGL;AACA,IAAA,KAAK,CAAC,kBAAD,CAAL,CADA,CAEA;;AACA,UAAM,IAAI,QAAA,CAAA,uBAAJ,CAA4B,OAA5B,EAAqC,MAArC,EAA6C,gBAA7C,CAAN;AACD,GApG4E,CAqG7E;AACA;AACA;;;AACA,EAAA,KAAK,CAAC,gCAAD,CAAL;AACA,MAAI,WAAW,GAAiB,EAAhC;;AACA,OAAK,MAAM,MAAX,IAAqB,OAArB,EAA8B;AAC5B,QAAI,OAAJ;;AACA,QAAI;AACF;AACA;AACA,MAAA,OAAO,GAAG,OAAO,gBAAgB,CAAC,MAAD,EAAS,MAAT,EAAiB;AAChD,QAAA,gBADgD;AAEhD,QAAA,YAFgD;AAGhD,QAAA,SAHgD;AAIhD,QAAA;AAJgD,OAAjB,CAAjC;AAMD,KATD,CASE,OAAO,KAAP,EAAc;AACd;AACA,MAAA,KAAK,CAAC,YAAD,EAAe,MAAf,CAAL;AACA,MAAA,KAAK,CAAC,aAAD,EAAgB,KAAhB,CAAL;AACA;AACD,KAhB2B,CAiB5B;AACA;;;AACA,IAAA,KAAK,CAAC,YAAD,EAAe,MAAf,CAAL;AACA,IAAA,WAAW,CAAC,IAAZ,CAAiB;AAAE,MAAA,MAAF;AAAU,MAAA,SAAS,EAAE,OAArB;AAA8B,MAAA,OAAO,EAAE;AAAvC,KAAjB;AACD,GA/H4E,CAgI7E;;;AACA,EAAA,KAAK,CAAC,iBAAD,EAAoB,WAApB,CAAL;AACA,EAAA,WAAW,GAAG,WAAW,CAAC,MAAZ,CAAmB,UAAU,IACzC,WAAW,CAAC,KAAZ,CACE,oBAAoB,IAClB,CAAC,CAAA,GAAA,UAAA,CAAA,sBAAA,EACC,oBAAoB,CAAC,SADtB,EAEC,UAAU,CAAC,SAFZ,EAGC,gBAHD,CAAD,IAKA;AACA;AACA;AACA;AACA;AACA,GAAA,GAAA,UAAA,CAAA,sBAAA,EACE,UAAU,CAAC,SADb,EAEE,oBAAoB,CAAC,SAFvB,EAGE,gBAHF,CAZJ,CADY,CAAd;AAoBA,EAAA,KAAK,CAAC,2BAAD,EAA8B,WAA9B,CAAL;;AACA,UAAQ,WAAW,CAAC,MAApB;AACE,SAAK,CAAL;AACE;AACA,YAAM,IAAI,QAAA,CAAA,uBAAJ,CAA4B,OAA5B,EAAqC,MAArC,EAA6C,gBAA7C,CAAN;;AACF,SAAK,CAAL;AACE;AACA;AACA,YAAM;AAAE,QAAA,MAAF;AAAU,QAAA,SAAS,EAAE;AAArB,UAAiC,WAAW,CAAC,CAAD,CAAlD;AACA,aAAO,oBAAoB,CAAC,MAAD,EAAS,OAAT,CAA3B;;AACF;AACE;AACA,YAAM,IAAI,QAAA,CAAA,yBAAJ,CAA8B,WAA9B,CAAN;AAXJ;AAaD;;AAvKD,OAAA,CAAA,cAAA,GAAA,cAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.resolveAndWrap = exports.wrapForMethod = exports.wrapMultiple = exports.Messages = exports.wrap = exports.BadResponseTypeError = exports.TypeMismatchError = exports.NoUniqueBestOverloadError = exports.NoOverloadsMatchedError = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:wrap\");\nconst priority_1 = require(\"./priority\");\nconst errors_1 = require(\"./errors\");\nObject.defineProperty(exports, \"NoOverloadsMatchedError\", { enumerable: true, get: function () { return errors_1.NoOverloadsMatchedError; } });\nObject.defineProperty(exports, \"NoUniqueBestOverloadError\", { enumerable: true, get: function () { return errors_1.NoUniqueBestOverloadError; } });\nObject.defineProperty(exports, \"TypeMismatchError\", { enumerable: true, get: function () { return errors_1.TypeMismatchError; } });\nObject.defineProperty(exports, \"BadResponseTypeError\", { enumerable: true, get: function () { return errors_1.BadResponseTypeError; } });\n__exportStar(require(\"./errors\"), exports);\nconst wrap_1 = require(\"./wrap\");\nObject.defineProperty(exports, \"wrap\", { enumerable: true, get: function () { return wrap_1.wrap; } });\n__exportStar(require(\"./types\"), exports);\nexports.Messages = __importStar(require(\"./messages\"));\nfunction* wrapMultiple(types, inputs, wrapOptions) {\n    //just wrap the types in a tuple and defer to wrap()\n    const combinedType = {\n        typeClass: \"tuple\",\n        memberTypes: types\n    };\n    debug(\"wrapping multiple\");\n    const wrappedTogether = (yield* (0, wrap_1.wrap)(combinedType, inputs, wrapOptions));\n    return wrappedTogether.value.map(({ value }) => value);\n}\nexports.wrapMultiple = wrapMultiple;\n//note: turns on loose\nfunction* wrapForMethod(method, inputs, resolveOptions) {\n    const wrapped = yield* wrapForMethodRaw(method, inputs, resolveOptions, true);\n    return wrappingToResolution(method, wrapped);\n}\nexports.wrapForMethod = wrapForMethod;\nfunction wrappingToResolution(method, wrapped) {\n    if (wrapped.length > 0 &&\n        wrapped[wrapped.length - 1].type.typeClass === \"options\") {\n        //there's options\n        const wrappedArguments = wrapped.slice(0, -1); //cut off options\n        const options = wrapped[wrapped.length - 1]\n            .value;\n        return {\n            method,\n            arguments: wrappedArguments,\n            options\n        };\n    }\n    else {\n        //no options\n        return {\n            method,\n            arguments: wrapped,\n            options: {}\n        };\n    }\n}\n//doesn't separate out options from arguments & doesn't turn on loose\nfunction* wrapForMethodRaw(method, inputs, { userDefinedTypes, allowOptions, allowJson, strictBooleans }, loose = false) {\n    debug(\"wrapping for method\");\n    if (method.inputs.length === inputs.length) {\n        //no options case\n        debug(\"no options\");\n        return yield* wrapMultiple(method.inputs, inputs, {\n            userDefinedTypes,\n            oldOptionsBehavior: true,\n            loose,\n            name: \"<arguments>\",\n            allowJson,\n            strictBooleans\n        });\n    }\n    else if (allowOptions && method.inputs.length === inputs.length - 1) {\n        //options case\n        debug(\"options\");\n        const inputsWithOptions = [\n            ...method.inputs,\n            { name: \"<options>\", type: { typeClass: \"options\" } }\n        ];\n        return yield* wrapMultiple(inputsWithOptions, inputs, {\n            userDefinedTypes,\n            oldOptionsBehavior: true,\n            loose,\n            name: \"<arguments>\",\n            allowJson,\n            strictBooleans\n        });\n    }\n    else {\n        //invalid length case\n        const orOneMore = allowOptions\n            ? ` (or ${method.inputs.length + 1} counting transaction options)`\n            : \"\";\n        throw new errors_1.TypeMismatchError({ typeClass: \"tuple\", memberTypes: method.inputs }, inputs, \"<arguments>\", 5, `Incorrect number of arguments (expected ${method.inputs.length}${orOneMore}, got ${inputs.length})`);\n    }\n}\nfunction* resolveAndWrap(methods, inputs, { userDefinedTypes, allowOptions, allowJson, strictBooleans }) {\n    //despite us having a good system for overload resolution, we want to\n    //use it as little as possible!  That's because using it means we don't\n    //get great error messages.  As such, we're going to do a bunch to filter\n    //things beforehand, so that we get good error messages.\n    if (methods.length === 1) {\n        //if there's only one possibility, we just defer to wrapForMethod\n        //if we ignore error messages this is silly... but we're not!\n        //this is important for good error messages in this case\n        return yield* wrapForMethod(methods[0], inputs, {\n            userDefinedTypes,\n            allowOptions,\n            allowJson,\n            strictBooleans\n        });\n    }\n    //OK, so, there are multiple possibilities then.  let's try to filter things down by length.\n    const possibleMatches = methods.filter(method => method.inputs.length === inputs.length);\n    //but, we've also got to account for the possibility of options\n    let possibleMatchesWithOptions = [];\n    let possibleOptions = {};\n    if (allowOptions && inputs.length > 0) {\n        //if options are allowed, we'll have to account for that.\n        //*however*, in order to minimize the number of possibilities, we won't\n        //use these unless the last argument of inputs actually looks like an options!\n        const lastInput = inputs[inputs.length - 1];\n        let isOptionsPossible = true;\n        try {\n            const wrappedOptions = (yield* (0, wrap_1.wrap)({ typeClass: \"options\" }, lastInput, {\n                name: \"<options>\",\n                loose: true,\n                oldOptionsBehavior: true,\n                userDefinedTypes,\n                allowJson,\n                strictBooleans\n            }));\n            possibleOptions = wrappedOptions.value;\n        }\n        catch (error) {\n            if (error instanceof errors_1.TypeMismatchError) {\n                isOptionsPossible = false;\n            }\n            else {\n                throw error; //rethrow unexpected errors\n            }\n        }\n        if (isOptionsPossible) {\n            possibleMatchesWithOptions = methods.filter(method => method.inputs.length === inputs.length - 1);\n        }\n    }\n    debug(\"possibleMatches: %o\", possibleMatches);\n    debug(\"possibleMatchesWithOptions: %o\", possibleMatchesWithOptions);\n    //if there's now only one possibility, great!\n    if (possibleMatches.length === 1 && possibleMatchesWithOptions.length === 0) {\n        //only one possibility, no options. we can just defer to wrapMultiple.\n        //(again, point is to have good error messaging)\n        debug(\"only one possibility, no options\");\n        const method = possibleMatches[0];\n        return {\n            method,\n            arguments: yield* wrapMultiple(method.inputs, inputs, {\n                userDefinedTypes,\n                loose: true,\n                name: \"<arguments>\",\n                allowJson,\n                strictBooleans\n            }),\n            options: {}\n        };\n    }\n    else if (possibleMatchesWithOptions.length === 1 &&\n        possibleMatches.length === 0) {\n        //only one possibility, with options.  moreover, we already determined the options\n        //above, so we can once again just defer to wrapMultiple\n        debug(\"only one possiblity, with options\");\n        const method = possibleMatchesWithOptions[0];\n        return {\n            method,\n            arguments: yield* wrapMultiple(method.inputs, inputs, {\n                userDefinedTypes,\n                loose: true,\n                name: \"<arguments>\",\n                allowJson,\n                strictBooleans\n            }),\n            options: possibleOptions\n        };\n    }\n    else if (possibleMatches.length === 0 &&\n        possibleMatchesWithOptions.length === 0) {\n        debug(\"no possibilities\");\n        //nothing matches!\n        throw new errors_1.NoOverloadsMatchedError(methods, inputs, userDefinedTypes);\n    }\n    //if all of our attempts to avoid it have failed, we'll have to actually use\n    //our overload resolution system. note how we do *not* turn on loose in this\n    //case!\n    debug(\"attempting overload resolution\");\n    let resolutions = [];\n    for (const method of methods) {\n        let wrapped;\n        try {\n            //note this part takes care of options for us...\n            //although yes this means options will be re-wrapped, oh well\n            wrapped = yield* wrapForMethodRaw(method, inputs, {\n                userDefinedTypes,\n                allowOptions,\n                allowJson,\n                strictBooleans\n            });\n        }\n        catch (error) {\n            //if there's an error, don't add it\n            debug(\"failed: %O\", method);\n            debug(\"because: %O\", error);\n            continue;\n        }\n        //note that options and arguments here are both not correct, but we'll\n        //fix them up later!\n        debug(\"adding: %O\", method);\n        resolutions.push({ method, arguments: wrapped, options: {} });\n    }\n    //now: narrow it down to the most specific one(s)\n    debug(\"resolutions: %O\", resolutions);\n    resolutions = resolutions.filter(resolution => resolutions.every(comparisonResolution => !(0, priority_1.isMoreSpecificMultiple)(comparisonResolution.arguments, resolution.arguments, userDefinedTypes) ||\n        //because the comparison is nonstrict, this comparison is added to\n        //effectively make it strict\n        // i.e. we have !(x<=y) but we want !(x<y), i.e.,\n        // !(x<=y) | x=y, i.e., !(x<=y) | (x<=y & y<=x),\n        // i.e., !(x<=y) | y<=x\n        (0, priority_1.isMoreSpecificMultiple)(resolution.arguments, comparisonResolution.arguments, userDefinedTypes)));\n    debug(\"resolutions remaining: %O\", resolutions);\n    switch (resolutions.length) {\n        case 0:\n            //no resolution worked\n            throw new errors_1.NoOverloadsMatchedError(methods, inputs, userDefinedTypes);\n        case 1:\n            //there was a most specific resolution; fix up options and arguments\n            //before returning\n            const { method, arguments: wrapped } = resolutions[0];\n            return wrappingToResolution(method, wrapped);\n        default:\n            //no unique most-specific resolution\n            throw new errors_1.NoUniqueBestOverloadError(resolutions);\n    }\n}\nexports.resolveAndWrap = resolveAndWrap;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}