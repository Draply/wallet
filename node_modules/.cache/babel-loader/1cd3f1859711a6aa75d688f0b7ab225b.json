{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addressCases = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"codec:wrap:address\");\n\nconst dispatch_1 = require(\"./dispatch\");\n\nconst errors_1 = require(\"./errors\");\n\nconst Utils = __importStar(require(\"./utils\"));\n\nconst EvmUtils = __importStar(require(\"../evm/utils\"));\n\nconst Messages = __importStar(require(\"./messages\"));\n\nconst web3_utils_1 = __importDefault(require(\"web3-utils\")); //no separate cases for contracts; even with loose turned off,\n//we consider these interchangeable\n\n\nconst addressFromStringCases = [addressFromHexString, addressFromPrefixlessHexString, addressFromOtherString //Please put after other string cases! Also, can yield\n];\nconst addressCasesBasic = [...addressFromStringCases, addressFromBoxedString, addressFromContractInput, addressFromCodecAddressLikeValue, addressFromCodecUdvtValue, addressFailureCase];\nexports.addressCases = [addressFromTypeValueInput, ...addressCasesBasic];\n\nfunction* addressFromHexString(dataType, input, wrapOptions) {\n  if (typeof input !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n  }\n\n  if (!Utils.isHexString(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a 0x-prefixed hex string\");\n  }\n\n  return validateNormalizeAndWrap(dataType, input, input, wrapOptions.name);\n}\n\nfunction* addressFromPrefixlessHexString(dataType, input, wrapOptions) {\n  if (typeof input !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n  }\n\n  if (!Utils.isPrefixlessHexString(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not an unprefixed hex string\");\n  }\n\n  return validateNormalizeAndWrap(dataType, \"0x\" + input, input, wrapOptions.name);\n}\n\nfunction* addressFromOtherString(dataType, input, wrapOptions) {\n  if (typeof input !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n  }\n\n  const request = {\n    kind: \"address\",\n    name: input\n  };\n  const response = yield request;\n\n  if (response.kind !== \"address\") {\n    throw new errors_1.BadResponseTypeError(request, response);\n  }\n\n  if (response.address === null) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, response.partiallyRecognized ? 5 : 3, response.reason);\n  } //we should be able to skip validation & normalization here\n\n\n  return wrapAsAppropriateType(dataType, response.address);\n}\n\nfunction* addressFromBoxedString(dataType, input, wrapOptions) {\n  if (!Utils.isBoxedString(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a boxed string\");\n  } //unbox and try again\n\n\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, input.valueOf(), wrapOptions, addressFromStringCases);\n}\n\nfunction* addressFromContractInput(dataType, input, wrapOptions) {\n  if (!Utils.isContractInput(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a contract-like object\");\n  }\n\n  return validateNormalizeAndWrap(dataType, input.address, input, wrapOptions.name);\n}\n\nfunction* addressFromCodecAddressLikeValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n\n  if (input.type.typeClass !== \"address\" && input.type.typeClass !== \"contract\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n\n  let address;\n\n  switch (input.type.typeClass) {\n    case \"address\":\n      address = input.value.asAddress;\n      break;\n\n    case \"contract\":\n      address = input.value.address;\n      break;\n    //other cases are impossible at this point\n  } //we should be able to skip validation/normalization here\n\n\n  return wrapAsAppropriateType(dataType, address);\n}\n\nfunction* addressFromCodecUdvtValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n\n  if (input.type.typeClass !== \"userDefinedValueType\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.wrappedTypeMessage(input.type));\n  }\n\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n\n  return yield* addressFromCodecAddressLikeValue(dataType, input.value, wrapOptions);\n}\n\nfunction* addressFromTypeValueInput(dataType, input, wrapOptions) {\n  if (!Utils.isTypeValueInput(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n  }\n\n  if (input.type !== \"address\" && input.type !== \"contract\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n  } //extract value & try again, with loose option turned on\n\n\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), {\n    loose: true\n  }), addressCasesBasic);\n}\n\nfunction* addressFailureCase(dataType, input, wrapOptions) {\n  throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, \"Input was not recognizable as an address\");\n}\n\nfunction validateAndNormalize(asAddress, dataType, //for errors\ninput, //for errors\nname //for errors\n) {\n  if (!Utils.isByteString(asAddress)) {\n    throw new errors_1.TypeMismatchError(dataType, input, name, 5, Messages.notABytestringMessage(\"Address\"));\n  }\n\n  if (asAddress.length !== 2 * EvmUtils.ADDRESS_SIZE + 2) {\n    throw new errors_1.TypeMismatchError(dataType, input, name, 5, Messages.wrongLengthMessage(\"address\", EvmUtils.ADDRESS_SIZE, (asAddress.length - 2) / 2));\n  }\n\n  if (!web3_utils_1.default.isAddress(asAddress)) {\n    throw new errors_1.TypeMismatchError(dataType, input, name, 6, //to beat the one from the yield case :P\n    Messages.checksumFailedMessage);\n  } //and normalize\n\n\n  return web3_utils_1.default.toChecksumAddress(asAddress);\n}\n\nfunction wrapAsAppropriateType(dataType, asAddress) {\n  //return address or contract value as appropriate\n  switch (dataType.typeClass) {\n    case \"address\":\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: {\n          asAddress\n        }\n      };\n\n    case \"contract\":\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: {\n          kind: \"unknown\",\n          address: asAddress\n        }\n      };\n  }\n}\n\nfunction validateNormalizeAndWrap(dataType, asAddress, input, //for errors\nname //for errors\n) {\n  return wrapAsAppropriateType(dataType, validateAndNormalize(asAddress, dataType, input, name));\n}","map":{"version":3,"sources":["../../../lib/wrap/address.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.addressCases = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:wrap:address\");\nconst dispatch_1 = require(\"./dispatch\");\nconst errors_1 = require(\"./errors\");\nconst Utils = __importStar(require(\"./utils\"));\nconst EvmUtils = __importStar(require(\"../evm/utils\"));\nconst Messages = __importStar(require(\"./messages\"));\nconst web3_utils_1 = __importDefault(require(\"web3-utils\"));\n//no separate cases for contracts; even with loose turned off,\n//we consider these interchangeable\nconst addressFromStringCases = [\n    addressFromHexString,\n    addressFromPrefixlessHexString,\n    addressFromOtherString //Please put after other string cases! Also, can yield\n];\nconst addressCasesBasic = [\n    ...addressFromStringCases,\n    addressFromBoxedString,\n    addressFromContractInput,\n    addressFromCodecAddressLikeValue,\n    addressFromCodecUdvtValue,\n    addressFailureCase\n];\nexports.addressCases = [addressFromTypeValueInput, ...addressCasesBasic];\nfunction* addressFromHexString(dataType, input, wrapOptions) {\n    if (typeof input !== \"string\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n    }\n    if (!Utils.isHexString(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a 0x-prefixed hex string\");\n    }\n    return validateNormalizeAndWrap(dataType, input, input, wrapOptions.name);\n}\nfunction* addressFromPrefixlessHexString(dataType, input, wrapOptions) {\n    if (typeof input !== \"string\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n    }\n    if (!Utils.isPrefixlessHexString(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not an unprefixed hex string\");\n    }\n    return validateNormalizeAndWrap(dataType, \"0x\" + input, input, wrapOptions.name);\n}\nfunction* addressFromOtherString(dataType, input, wrapOptions) {\n    if (typeof input !== \"string\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n    }\n    const request = { kind: \"address\", name: input };\n    const response = yield request;\n    if (response.kind !== \"address\") {\n        throw new errors_1.BadResponseTypeError(request, response);\n    }\n    if (response.address === null) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, response.partiallyRecognized ? 5 : 3, response.reason);\n    }\n    //we should be able to skip validation & normalization here\n    return wrapAsAppropriateType(dataType, response.address);\n}\nfunction* addressFromBoxedString(dataType, input, wrapOptions) {\n    if (!Utils.isBoxedString(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a boxed string\");\n    }\n    //unbox and try again\n    return yield* (0, dispatch_1.wrapWithCases)(dataType, input.valueOf(), wrapOptions, addressFromStringCases);\n}\nfunction* addressFromContractInput(dataType, input, wrapOptions) {\n    if (!Utils.isContractInput(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a contract-like object\");\n    }\n    return validateNormalizeAndWrap(dataType, input.address, input, wrapOptions.name);\n}\nfunction* addressFromCodecAddressLikeValue(dataType, input, wrapOptions) {\n    if (!Utils.isWrappedResult(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n    }\n    if (input.type.typeClass !== \"address\" &&\n        input.type.typeClass !== \"contract\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n    }\n    if (input.kind !== \"value\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n    }\n    let address;\n    switch (input.type.typeClass) {\n        case \"address\":\n            address = input.value.asAddress;\n            break;\n        case \"contract\":\n            address = input.value.address;\n            break;\n        //other cases are impossible at this point\n    }\n    //we should be able to skip validation/normalization here\n    return wrapAsAppropriateType(dataType, address);\n}\nfunction* addressFromCodecUdvtValue(dataType, input, wrapOptions) {\n    if (!Utils.isWrappedResult(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n    }\n    if (input.type.typeClass !== \"userDefinedValueType\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.wrappedTypeMessage(input.type));\n    }\n    if (input.kind !== \"value\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n    }\n    return yield* addressFromCodecAddressLikeValue(dataType, input.value, wrapOptions);\n}\nfunction* addressFromTypeValueInput(dataType, input, wrapOptions) {\n    if (!Utils.isTypeValueInput(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n    }\n    if (input.type !== \"address\" && input.type !== \"contract\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n    }\n    //extract value & try again, with loose option turned on\n    return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), { loose: true }), addressCasesBasic);\n}\nfunction* addressFailureCase(dataType, input, wrapOptions) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, \"Input was not recognizable as an address\");\n}\nfunction validateAndNormalize(asAddress, dataType, //for errors\ninput, //for errors\nname //for errors\n) {\n    if (!Utils.isByteString(asAddress)) {\n        throw new errors_1.TypeMismatchError(dataType, input, name, 5, Messages.notABytestringMessage(\"Address\"));\n    }\n    if (asAddress.length !== 2 * EvmUtils.ADDRESS_SIZE + 2) {\n        throw new errors_1.TypeMismatchError(dataType, input, name, 5, Messages.wrongLengthMessage(\"address\", EvmUtils.ADDRESS_SIZE, (asAddress.length - 2) / 2));\n    }\n    if (!web3_utils_1.default.isAddress(asAddress)) {\n        throw new errors_1.TypeMismatchError(dataType, input, name, 6, //to beat the one from the yield case :P\n        Messages.checksumFailedMessage);\n    }\n    //and normalize\n    return web3_utils_1.default.toChecksumAddress(asAddress);\n}\nfunction wrapAsAppropriateType(dataType, asAddress) {\n    //return address or contract value as appropriate\n    switch (dataType.typeClass) {\n        case \"address\":\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: {\n                    asAddress\n                }\n            };\n        case \"contract\":\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: {\n                    kind: \"unknown\",\n                    address: asAddress\n                }\n            };\n    }\n}\nfunction validateNormalizeAndWrap(dataType, asAddress, input, //for errors\nname //for errors\n) {\n    return wrapAsAppropriateType(dataType, validateAndNormalize(asAddress, dataType, input, name));\n}\n//# sourceMappingURL=address.js.map"]},"metadata":{},"sourceType":"script"}