{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.wrap = exports.udvtCases = exports.txOptionsCases = exports.tupleCases = exports.arrayCases = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"codec:wrap:wrap\");\n\nconst Format = __importStar(require(\"../format\"));\n\nconst errors_1 = require(\"./errors\");\n\nconst dispatch_1 = require(\"./dispatch\");\n\nconst Messages = __importStar(require(\"./messages\"));\n\nconst Conversion = __importStar(require(\"../conversion\"));\n\nconst Utils = __importStar(require(\"./utils\"));\n\nconst integer_1 = require(\"./integer\");\n\nconst decimal_1 = require(\"./decimal\");\n\nconst bool_1 = require(\"./bool\");\n\nconst bytes_1 = require(\"./bytes\");\n\nconst address_1 = require(\"./address\");\n\nconst string_1 = require(\"./string\");\n\nconst function_1 = require(\"./function\"); //this file contains the main wrap function, as well as the cases\n//for arrays, tuples, udvts, and tx options.  all other types get their\n//own file.\n\n\nconst arrayCasesBasic = [arrayFromArray, arrayFromCodecArrayValue, arrayFromJson, arrayFailureCase];\nexports.arrayCases = [arrayFromTypeValueInput, ...arrayCasesBasic];\nconst tupleCasesBasic = [tupleFromArray, tupleFromCodecTupleLikeValue, tupleFromObject, tupleFromJson, tupleFailureCase];\nexports.tupleCases = [tupleFromTypeValueInput, ...tupleCasesBasic];\nconst txOptionsCasesBasic = [optionsFromCodecOptionsValue, optionsFromObject, optionsFailureCase];\nexports.txOptionsCases = [optionsFromTypeValueInput, ...txOptionsCasesBasic];\nexports.udvtCases = [//no separate case for udvtFromUdvtValue,\n//since underlying already handles this\nudvtFromUnderlying];\n\nfunction* wrap(dataType, input, wrapOptions) {\n  if (!wrapOptions.name) {\n    wrapOptions = Object.assign(Object.assign({}, wrapOptions), {\n      name: \"<input>\"\n    });\n  }\n\n  switch (dataType.typeClass) {\n    case \"uint\":\n    case \"int\":\n    case \"enum\":\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, integer_1.integerCases);\n\n    case \"fixed\":\n    case \"ufixed\":\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, decimal_1.decimalCases);\n\n    case \"bool\":\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, bool_1.boolCases);\n\n    case \"bytes\":\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, bytes_1.bytesCases);\n\n    case \"address\":\n    case \"contract\":\n      //these are treated the same\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, address_1.addressCases);\n\n    case \"string\":\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, string_1.stringCases);\n\n    case \"function\":\n      //special check: weed out internal functions\n      if (dataType.visibility === \"internal\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, //it doesn't matter, but we'll make this error high specificity\n        `Wrapping/encoding for internal function pointers is not supported`);\n      } //otherwise, go ahead\n\n\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, function_1.functionExternalCases);\n\n    case \"array\":\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, exports.arrayCases);\n\n    case \"struct\":\n    case \"tuple\":\n      //these are treated the same as well\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, exports.tupleCases);\n\n    case \"userDefinedValueType\":\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, exports.udvtCases);\n\n    case \"options\":\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, exports.txOptionsCases);\n\n    default:\n      throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, //it doesn't matter, but we'll make this error high specificity\n      `Wrapping/encoding for type ${Format.Types.typeStringWithoutLocation(dataType)} is not supported`);\n  }\n}\n\nexports.wrap = wrap; //array cases\n\nfunction* arrayFromArray(dataType, input, wrapOptions) {\n  if (!Array.isArray(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not an array\");\n  }\n\n  if (dataType.kind === \"static\" && !dataType.length.eqn(input.length)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrongArrayLengthMessage(dataType.length, input.length));\n  } //can't do yield in a map, so manual loop here\n\n\n  let value = [];\n\n  for (let index = 0; index < input.length; index++) {\n    value.push(yield* wrap(dataType.baseType, input[index], Object.assign(Object.assign({}, wrapOptions), {\n      name: `${wrapOptions.name}[${index}]`,\n      specificityFloor: 5 //errors in components are quite specific!\n\n    })));\n  }\n\n  return {\n    type: dataType,\n    kind: \"value\",\n    value\n  };\n}\n\nfunction* arrayFromCodecArrayValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n\n  if (input.type.typeClass !== \"array\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  } //we won't bother with detailed typechecking as much of it is handled\n  //either in the call to arrayFromArray or in the wrapping of the\n  //individual elements; we will check dynamic vs static though as that\n  //isn't handled elsewhere\n\n\n  if (!wrapOptions.loose && input.type.kind === dataType.kind) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  } //note that we do *not* just copy over input.value, but rather we\n  //defer to arrayFromArray; this is because there might be some elements\n  //where the type is not the same but is compatible\n\n\n  const value = input.value;\n  return yield* arrayFromArray(dataType, value, wrapOptions);\n}\n\nfunction* arrayFromJson(dataType, input, wrapOptions) {\n  if (!wrapOptions.allowJson) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"JSON input must be explicitly enabled\");\n  }\n\n  if (typeof input !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n  }\n\n  let parsedInput;\n\n  try {\n    parsedInput = JSON.parse(input);\n  } catch (error) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, `Input was not valid JSON: ${error.message}`);\n  }\n\n  return yield* arrayFromArray(dataType, parsedInput, wrapOptions);\n}\n\nfunction* arrayFromTypeValueInput(dataType, input, wrapOptions) {\n  if (!Utils.isTypeValueInput(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n  }\n\n  if (input.type !== \"array\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n  } //don't turn on loose here, only do that for non-container types!\n\n\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, wrapOptions, arrayCasesBasic);\n}\n\nfunction* arrayFailureCase(dataType, input, wrapOptions) {\n  throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, \"Input was not an array, type/value pair or wrapped array\");\n} //tuple/struct cases;\n//note even with loose turned off, we won't distinguish\n//between tuples and structs\n\n\nfunction* tupleFromArray(dataType, input, wrapOptions) {\n  //first: obtain the types of the members\n  if (!Array.isArray(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not an array\");\n  }\n\n  debug(\"input is array\");\n  const memberTypes = memberTypesForType(dataType, wrapOptions.userDefinedTypes);\n\n  if (memberTypes.length !== input.length) {\n    debug(\"input is wrong-length array\");\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrongArrayLengthMessage(memberTypes.length, input.length));\n  } //can't do yield in a map, so manual loop here\n\n\n  let value = [];\n\n  for (let index = 0; index < input.length; index++) {\n    const memberName = memberTypes[index].name;\n    debug(\"wrapping %s\", memberName);\n    value.push({\n      name: memberName,\n      value: yield* wrap(memberTypes[index].type, input[index], Object.assign(Object.assign({}, wrapOptions), {\n        name: memberName ? wrapOptions.name.match(/^<.*>$/) //hack?\n        ? memberName : `${wrapOptions.name}.${memberName}` : `${wrapOptions.name}[${index}]`,\n        specificityFloor: 5\n      }))\n    });\n  } //we need to coerce here because TS doesn't know that if it's a struct\n  //then everything has a name\n\n\n  return {\n    type: dataType,\n    kind: \"value\",\n    value\n  };\n}\n\nfunction* tupleFromObject(dataType, input, wrapOptions) {\n  if (!Utils.isPlainObject(input)) {\n    //just checks that it's an object & not null\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a non-null object\");\n  }\n\n  if (!wrapOptions.loose && Utils.isTypeValueInput(input)) {\n    //let's exclude these unless loose is turned on\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was a type/value pair\");\n  }\n\n  if (!wrapOptions.loose && Utils.isWrappedResult(input)) {\n    //similarly here\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was a wrapped result\");\n  }\n\n  const memberTypes = memberTypesForType(dataType, wrapOptions.userDefinedTypes);\n\n  if (memberTypes.some(_ref => {\n    let {\n      name\n    } = _ref;\n    return !name;\n  })) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, \"Plain object input is allowed only when all elements of tuple are named\");\n  }\n\n  let unusedKeys = new Set(Object.keys(input));\n  let value = [];\n\n  for (let index = 0; index < memberTypes.length; index++) {\n    //note we had better process these in order!\n    const memberName = memberTypes[index].name;\n\n    if (!(memberName in input)) {\n      throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, `Missing key from tuple or struct: ${memberName}`);\n    }\n\n    unusedKeys.delete(memberName);\n    value.push({\n      name: memberName,\n      value: yield* wrap(memberTypes[index].type, input[memberName], Object.assign(Object.assign({}, wrapOptions), {\n        name: `${wrapOptions.name}.${memberName}`,\n        specificityFloor: 4 //not sure this warrants a 5\n\n      }))\n    });\n  }\n\n  if (!wrapOptions.loose) {\n    if (unusedKeys.size > 0) {\n      //choose one arbitrarily\n      const exampleKey = unusedKeys.values().next().value;\n      throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, `Unknown key ${exampleKey} included`);\n    }\n  } //we need to coerce here because TS doesn't know that if it's a struct\n  //then everything has a name\n\n\n  return {\n    type: dataType,\n    kind: \"value\",\n    value\n  };\n}\n\nfunction* tupleFromJson(dataType, input, wrapOptions) {\n  if (!wrapOptions.allowJson) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"JSON input must be explicitly enabled\");\n  }\n\n  if (typeof input !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n  }\n\n  let parsedInput;\n\n  try {\n    parsedInput = JSON.parse(input);\n  } catch (error) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, `Input was not valid JSON: ${error.message}`);\n  }\n\n  debug(\"input is JSON\");\n  debug(\"parses to: %O\", parsedInput);\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, parsedInput, wrapOptions, [tupleFromObject, tupleFromArray]);\n}\n\nfunction* tupleFromCodecTupleLikeValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n\n  if (input.type.typeClass !== \"tuple\" && input.type.typeClass !== \"struct\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  } //not going to do much typechecking here as it'll be handled in the call\n  //to tupleFromArray\n  //Typescript complains if I try to say it can be either struct or\n  //tuple, so, uh, let's just tell it it's a tuple <shrug>\n\n\n  const coercedInput = input; //HACK!\n  //note that we do *not* just copy over input.value, but rather we\n  //defer to tupleFromArray; this is because there might be some elements\n  //where the type is not the same but is compatible\n\n  return yield* tupleFromArray(dataType, coercedInput.value.map(_ref2 => {\n    let {\n      value\n    } = _ref2;\n    return value;\n  }), wrapOptions);\n}\n\nfunction* tupleFromTypeValueInput(dataType, input, wrapOptions) {\n  if (!Utils.isTypeValueInput(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n  }\n\n  if (input.type !== \"tuple\" && input.type !== \"struct\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n  } //don't turn on loose here, only do that for non-container types!\n\n\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, wrapOptions, tupleCasesBasic);\n}\n\nfunction* tupleFailureCase(dataType, input, wrapOptions) {\n  throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, \"Input was not an array, plain object, type/value pair or wrapped tuple or struct\");\n}\n\nfunction memberTypesForType(dataType, userDefinedTypes) {\n  switch (dataType.typeClass) {\n    case \"tuple\":\n      return dataType.memberTypes;\n      break;\n\n    case \"struct\":\n      debug(\"wrapping for struct %s\", dataType.typeName);\n      return Format.Types.fullType(dataType, userDefinedTypes).memberTypes;\n  }\n} //udvt cases\n\n\nfunction* udvtFromUnderlying(dataType, input, wrapOptions) {\n  const {\n    underlyingType\n  } = Format.Types.fullType(dataType, wrapOptions.userDefinedTypes);\n  const value = yield* wrap(underlyingType, input, wrapOptions);\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: value\n  };\n} //tx options cases\n\n\nfunction* optionsFromObject(dataType, input, wrapOptions) {\n  if (!Utils.isPlainObject(input)) {\n    //just checks that it's an object & not null\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a non-null object\");\n  }\n\n  debug(\"options input is object: %O\", input);\n  debug(\"wrapOptions: %O\", wrapOptions);\n\n  if (!wrapOptions.loose && Utils.isWrappedResult(input)) {\n    //similarly here\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was a wrapped result\");\n  } //now... the main case\n\n\n  let value = {};\n  const uintKeys = [\"gas\", \"gasPrice\", \"value\", \"nonce\", \"maxFeePerGas\", \"maxPriorityFeePerGas\"];\n  const uint8Keys = [\"type\"];\n  const addressKeys = [\"from\", \"to\"];\n  const bytesKeys = [\"data\"];\n  const boolKeys = [\"overwrite\"];\n  const accessListKeys = [\"accessList\"];\n  const specialKeys = [\"privateFor\"];\n  const allKeys = [...uintKeys, ...uint8Keys, ...addressKeys, ...bytesKeys, ...boolKeys, ...accessListKeys, ...specialKeys];\n  const badKey = Object.keys(input).find(key => !allKeys.includes(key));\n  const goodKey = Object.keys(input).find(key => allKeys.includes(key));\n\n  if (badKey !== undefined && !wrapOptions.oldOptionsBehavior) {\n    //note we allow extra keys if oldOptionsBehavior is on -- this is a HACK\n    //to preserve existing behavior of Truffle Contract (perhaps we can\n    //change this in Truffle 6)\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, `Transaction options included unknown option ${badKey}`);\n  }\n\n  if (wrapOptions.oldOptionsBehavior && goodKey === undefined) {\n    //similarly, if oldOptionsBehavior is on, we require at least\n    //one *legit* key (again, HACK to preserve existing behavior,\n    //maybe remove this in Truffle 6)\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, `Transaction options included no recognized options`);\n  } //otherwise, if all keys are transaction options, let's process them...\n  //part 1: uint options\n\n\n  for (const key of uintKeys) {\n    //note we check input[key] !== undefined, rather than key in input,\n    //because if one of them is undefined we want to just allow that but ignore it\n    if (input[key] !== undefined) {\n      const wrappedOption = yield* (0, dispatch_1.wrapWithCases)({\n        typeClass: \"uint\",\n        bits: 256\n      }, input[key], Object.assign(Object.assign({}, wrapOptions), {\n        name: `${wrapOptions.name}.${key}`\n      }), integer_1.integerCases);\n      value[key] = wrappedOption.value.asBN;\n    }\n  } //part 2: uint8 options (just type for now)\n\n\n  for (const key of uint8Keys) {\n    if (input[key] !== undefined) {\n      const wrappedOption = yield* (0, dispatch_1.wrapWithCases)({\n        typeClass: \"uint\",\n        bits: 8\n      }, input[key], Object.assign(Object.assign({}, wrapOptions), {\n        name: `${wrapOptions.name}.${key}`\n      }), integer_1.integerCases);\n      const asBN = wrappedOption.value.asBN; //since this is just type right now, we're going to reject illegal types\n\n      if (asBN.gten(0xc0)) {\n        //not making a constant for this, this is its only use here\n        throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.type`, 4, \"Transaction types must be less than 0xc0\");\n      } //for compatibility, we give type as a hex string rather than\n      //leaving it as a BN.  Since it's unsigned we don't have to\n      //worry about negatives.\n\n\n      value[key] = Conversion.toHexString(asBN);\n    }\n  } //part 3: address options\n\n\n  for (const key of addressKeys) {\n    if (input[key] !== undefined) {\n      const wrappedOption = yield* (0, dispatch_1.wrapWithCases)({\n        typeClass: \"address\",\n        kind: \"general\"\n      }, input[key], Object.assign(Object.assign({}, wrapOptions), {\n        name: `${wrapOptions.name}.${key}`\n      }), address_1.addressCases);\n      value[key] = wrappedOption.value.asAddress;\n    }\n  } //part 4: bytestring options\n\n\n  for (const key of bytesKeys) {\n    if (input[key] !== undefined) {\n      const wrappedOption = yield* (0, dispatch_1.wrapWithCases)({\n        typeClass: \"bytes\",\n        kind: \"dynamic\"\n      }, input[key], Object.assign(Object.assign({}, wrapOptions), {\n        name: `${wrapOptions.name}.${key}`\n      }), bytes_1.bytesCases);\n      value[key] = wrappedOption.value.asHex;\n    }\n  } //part 5: boolean options\n\n\n  for (const key of boolKeys) {\n    if (input[key] !== undefined) {\n      const wrappedOption = yield* (0, dispatch_1.wrapWithCases)({\n        typeClass: \"bool\"\n      }, input[key], Object.assign(Object.assign({}, wrapOptions), {\n        name: `${wrapOptions.name}.${key}`\n      }), bool_1.boolCases);\n      value[key] = wrappedOption.value.asBoolean;\n    }\n  } //part 6: the access list\n\n\n  for (const key of accessListKeys) {\n    if (input[key] !== undefined) {\n      const wrappedOption = yield* (0, dispatch_1.wrapWithCases)({\n        typeClass: \"array\",\n        kind: \"dynamic\",\n        baseType: {\n          typeClass: \"tuple\",\n          memberTypes: [{\n            name: \"address\",\n            type: {\n              typeClass: \"address\",\n              kind: \"general\"\n            }\n          }, {\n            name: \"storageKeys\",\n            type: {\n              typeClass: \"array\",\n              kind: \"dynamic\",\n              baseType: {\n                //we use uint256 rather than bytes32 to allow\n                //abbreviating and left-padding\n                typeClass: \"uint\",\n                bits: 256\n              }\n            }\n          }]\n        }\n      }, input[key], Object.assign(Object.assign({}, wrapOptions), {\n        name: `${wrapOptions.name}.${key}`\n      }), exports.arrayCases);\n      value[key] = Format.Utils.Inspect.nativizeAccessList(wrappedOption);\n    }\n  } //part 7: the special case of privateFor\n\n\n  if (input.privateFor !== undefined) {\n    //this doesn't correspond to any of our usual types, so we have to handle it specially\n    if (!Array.isArray(input.privateFor)) {\n      throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.privateFor`, 4, \"Transaction option privateFor should be an array of base64-encoded bytestrings of 32 bytes\");\n    }\n\n    value.privateFor = input.privateFor.map((publicKey, index) => {\n      if (Utils.isBoxedString(publicKey)) {\n        publicKey = publicKey.valueOf();\n      }\n\n      if (typeof publicKey !== \"string\") {\n        throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.privateFor`, 4, `Public key at index ${index} is not a string`);\n      }\n\n      if (!Utils.isBase64(publicKey)) {\n        throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.privateFor`, 4, `Public key at index ${index} is not base64-encoded`);\n      }\n\n      const length = Utils.base64Length(publicKey);\n\n      if (length !== 32) {\n        throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.privateFor`, 4, `Public key at index ${index} should encode a bytestring of 32 bytes; got ${length} bytes instead`);\n      }\n\n      return publicKey;\n    });\n  }\n\n  return {\n    type: dataType,\n    kind: \"value\",\n    value\n  };\n}\n\nfunction* optionsFromCodecOptionsValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n\n  if (input.type.typeClass !== \"options\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n\n  const value = input.value; //unlike in the array or tuple cases, here should not have\n  //to worry about compatible-but-not-identical types, so it's\n  //safe to just copy value over\n\n  return {\n    type: dataType,\n    kind: \"value\",\n    value\n  };\n}\n\nfunction* optionsFromTypeValueInput(dataType, input, wrapOptions) {\n  if (!Utils.isTypeValueInput(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n  }\n\n  if (input.type !== \"options\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n  } //because options, unlike other containers, has specific types, we *will* turn on loose\n\n\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), {\n    loose: true\n  }), txOptionsCasesBasic);\n}\n\nfunction* optionsFailureCase(dataType, input, wrapOptions) {\n  throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, \"Transaction options input was not a plain object, type/value pair or wrapped options object\");\n}","map":{"version":3,"sources":["../../../lib/wrap/wrap.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.wrap = exports.udvtCases = exports.txOptionsCases = exports.tupleCases = exports.arrayCases = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:wrap:wrap\");\nconst Format = __importStar(require(\"../format\"));\nconst errors_1 = require(\"./errors\");\nconst dispatch_1 = require(\"./dispatch\");\nconst Messages = __importStar(require(\"./messages\"));\nconst Conversion = __importStar(require(\"../conversion\"));\nconst Utils = __importStar(require(\"./utils\"));\nconst integer_1 = require(\"./integer\");\nconst decimal_1 = require(\"./decimal\");\nconst bool_1 = require(\"./bool\");\nconst bytes_1 = require(\"./bytes\");\nconst address_1 = require(\"./address\");\nconst string_1 = require(\"./string\");\nconst function_1 = require(\"./function\");\n//this file contains the main wrap function, as well as the cases\n//for arrays, tuples, udvts, and tx options.  all other types get their\n//own file.\nconst arrayCasesBasic = [\n    arrayFromArray,\n    arrayFromCodecArrayValue,\n    arrayFromJson,\n    arrayFailureCase\n];\nexports.arrayCases = [arrayFromTypeValueInput, ...arrayCasesBasic];\nconst tupleCasesBasic = [\n    tupleFromArray,\n    tupleFromCodecTupleLikeValue,\n    tupleFromObject,\n    tupleFromJson,\n    tupleFailureCase\n];\nexports.tupleCases = [\n    tupleFromTypeValueInput,\n    ...tupleCasesBasic\n];\nconst txOptionsCasesBasic = [optionsFromCodecOptionsValue, optionsFromObject, optionsFailureCase];\nexports.txOptionsCases = [optionsFromTypeValueInput, ...txOptionsCasesBasic];\nexports.udvtCases = [\n    //no separate case for udvtFromUdvtValue,\n    //since underlying already handles this\n    udvtFromUnderlying\n];\nfunction* wrap(dataType, input, wrapOptions) {\n    if (!wrapOptions.name) {\n        wrapOptions = Object.assign(Object.assign({}, wrapOptions), { name: \"<input>\" });\n    }\n    switch (dataType.typeClass) {\n        case \"uint\":\n        case \"int\":\n        case \"enum\":\n            return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, integer_1.integerCases);\n        case \"fixed\":\n        case \"ufixed\":\n            return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, decimal_1.decimalCases);\n        case \"bool\":\n            return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, bool_1.boolCases);\n        case \"bytes\":\n            return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, bytes_1.bytesCases);\n        case \"address\":\n        case \"contract\":\n            //these are treated the same\n            return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, address_1.addressCases);\n        case \"string\":\n            return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, string_1.stringCases);\n        case \"function\":\n            //special check: weed out internal functions\n            if (dataType.visibility === \"internal\") {\n                throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, //it doesn't matter, but we'll make this error high specificity\n                `Wrapping/encoding for internal function pointers is not supported`);\n            }\n            //otherwise, go ahead\n            return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, function_1.functionExternalCases);\n        case \"array\":\n            return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, exports.arrayCases);\n        case \"struct\":\n        case \"tuple\":\n            //these are treated the same as well\n            return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, exports.tupleCases);\n        case \"userDefinedValueType\":\n            return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, exports.udvtCases);\n        case \"options\":\n            return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, exports.txOptionsCases);\n        default:\n            throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, //it doesn't matter, but we'll make this error high specificity\n            `Wrapping/encoding for type ${Format.Types.typeStringWithoutLocation(dataType)} is not supported`);\n    }\n}\nexports.wrap = wrap;\n//array cases\nfunction* arrayFromArray(dataType, input, wrapOptions) {\n    if (!Array.isArray(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not an array\");\n    }\n    if (dataType.kind === \"static\" && !dataType.length.eqn(input.length)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrongArrayLengthMessage(dataType.length, input.length));\n    }\n    //can't do yield in a map, so manual loop here\n    let value = [];\n    for (let index = 0; index < input.length; index++) {\n        value.push(yield* wrap(dataType.baseType, input[index], Object.assign(Object.assign({}, wrapOptions), { name: `${wrapOptions.name}[${index}]`, specificityFloor: 5 //errors in components are quite specific!\n         })));\n    }\n    return {\n        type: dataType,\n        kind: \"value\",\n        value\n    };\n}\nfunction* arrayFromCodecArrayValue(dataType, input, wrapOptions) {\n    if (!Utils.isWrappedResult(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n    }\n    if (input.type.typeClass !== \"array\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n    }\n    if (input.kind !== \"value\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n    }\n    //we won't bother with detailed typechecking as much of it is handled\n    //either in the call to arrayFromArray or in the wrapping of the\n    //individual elements; we will check dynamic vs static though as that\n    //isn't handled elsewhere\n    if (!wrapOptions.loose && input.type.kind === dataType.kind) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n    }\n    //note that we do *not* just copy over input.value, but rather we\n    //defer to arrayFromArray; this is because there might be some elements\n    //where the type is not the same but is compatible\n    const value = input.value;\n    return yield* arrayFromArray(dataType, value, wrapOptions);\n}\nfunction* arrayFromJson(dataType, input, wrapOptions) {\n    if (!wrapOptions.allowJson) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"JSON input must be explicitly enabled\");\n    }\n    if (typeof input !== \"string\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n    }\n    let parsedInput;\n    try {\n        parsedInput = JSON.parse(input);\n    }\n    catch (error) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, `Input was not valid JSON: ${error.message}`);\n    }\n    return yield* arrayFromArray(dataType, parsedInput, wrapOptions);\n}\nfunction* arrayFromTypeValueInput(dataType, input, wrapOptions) {\n    if (!Utils.isTypeValueInput(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n    }\n    if (input.type !== \"array\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n    }\n    //don't turn on loose here, only do that for non-container types!\n    return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, wrapOptions, arrayCasesBasic);\n}\nfunction* arrayFailureCase(dataType, input, wrapOptions) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, \"Input was not an array, type/value pair or wrapped array\");\n}\n//tuple/struct cases;\n//note even with loose turned off, we won't distinguish\n//between tuples and structs\nfunction* tupleFromArray(dataType, input, wrapOptions) {\n    //first: obtain the types of the members\n    if (!Array.isArray(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not an array\");\n    }\n    debug(\"input is array\");\n    const memberTypes = memberTypesForType(dataType, wrapOptions.userDefinedTypes);\n    if (memberTypes.length !== input.length) {\n        debug(\"input is wrong-length array\");\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrongArrayLengthMessage(memberTypes.length, input.length));\n    }\n    //can't do yield in a map, so manual loop here\n    let value = [];\n    for (let index = 0; index < input.length; index++) {\n        const memberName = memberTypes[index].name;\n        debug(\"wrapping %s\", memberName);\n        value.push({\n            name: memberName,\n            value: yield* wrap(memberTypes[index].type, input[index], Object.assign(Object.assign({}, wrapOptions), { name: memberName\n                    ? wrapOptions.name.match(/^<.*>$/) //hack?\n                        ? memberName\n                        : `${wrapOptions.name}.${memberName}`\n                    : `${wrapOptions.name}[${index}]`, specificityFloor: 5 }))\n        });\n    }\n    //we need to coerce here because TS doesn't know that if it's a struct\n    //then everything has a name\n    return {\n        type: dataType,\n        kind: \"value\",\n        value\n    };\n}\nfunction* tupleFromObject(dataType, input, wrapOptions) {\n    if (!Utils.isPlainObject(input)) {\n        //just checks that it's an object & not null\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a non-null object\");\n    }\n    if (!wrapOptions.loose && Utils.isTypeValueInput(input)) {\n        //let's exclude these unless loose is turned on\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was a type/value pair\");\n    }\n    if (!wrapOptions.loose && Utils.isWrappedResult(input)) {\n        //similarly here\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was a wrapped result\");\n    }\n    const memberTypes = memberTypesForType(dataType, wrapOptions.userDefinedTypes);\n    if (memberTypes.some(({ name }) => !name)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, \"Plain object input is allowed only when all elements of tuple are named\");\n    }\n    let unusedKeys = new Set(Object.keys(input));\n    let value = [];\n    for (let index = 0; index < memberTypes.length; index++) {\n        //note we had better process these in order!\n        const memberName = memberTypes[index].name;\n        if (!(memberName in input)) {\n            throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, `Missing key from tuple or struct: ${memberName}`);\n        }\n        unusedKeys.delete(memberName);\n        value.push({\n            name: memberName,\n            value: yield* wrap(memberTypes[index].type, input[memberName], Object.assign(Object.assign({}, wrapOptions), { name: `${wrapOptions.name}.${memberName}`, specificityFloor: 4 //not sure this warrants a 5\n             }))\n        });\n    }\n    if (!wrapOptions.loose) {\n        if (unusedKeys.size > 0) {\n            //choose one arbitrarily\n            const exampleKey = unusedKeys.values().next().value;\n            throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, `Unknown key ${exampleKey} included`);\n        }\n    }\n    //we need to coerce here because TS doesn't know that if it's a struct\n    //then everything has a name\n    return {\n        type: dataType,\n        kind: \"value\",\n        value\n    };\n}\nfunction* tupleFromJson(dataType, input, wrapOptions) {\n    if (!wrapOptions.allowJson) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"JSON input must be explicitly enabled\");\n    }\n    if (typeof input !== \"string\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n    }\n    let parsedInput;\n    try {\n        parsedInput = JSON.parse(input);\n    }\n    catch (error) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, `Input was not valid JSON: ${error.message}`);\n    }\n    debug(\"input is JSON\");\n    debug(\"parses to: %O\", parsedInput);\n    return yield* (0, dispatch_1.wrapWithCases)(dataType, parsedInput, wrapOptions, [\n        tupleFromObject,\n        tupleFromArray\n    ]);\n}\nfunction* tupleFromCodecTupleLikeValue(dataType, input, wrapOptions) {\n    if (!Utils.isWrappedResult(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n    }\n    if (input.type.typeClass !== \"tuple\" && input.type.typeClass !== \"struct\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n    }\n    if (input.kind !== \"value\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n    }\n    //not going to do much typechecking here as it'll be handled in the call\n    //to tupleFromArray\n    //Typescript complains if I try to say it can be either struct or\n    //tuple, so, uh, let's just tell it it's a tuple <shrug>\n    const coercedInput = input; //HACK!\n    //note that we do *not* just copy over input.value, but rather we\n    //defer to tupleFromArray; this is because there might be some elements\n    //where the type is not the same but is compatible\n    return yield* tupleFromArray(dataType, coercedInput.value.map(({ value }) => value), wrapOptions);\n}\nfunction* tupleFromTypeValueInput(dataType, input, wrapOptions) {\n    if (!Utils.isTypeValueInput(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n    }\n    if (input.type !== \"tuple\" && input.type !== \"struct\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n    }\n    //don't turn on loose here, only do that for non-container types!\n    return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, wrapOptions, tupleCasesBasic);\n}\nfunction* tupleFailureCase(dataType, input, wrapOptions) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, \"Input was not an array, plain object, type/value pair or wrapped tuple or struct\");\n}\nfunction memberTypesForType(dataType, userDefinedTypes) {\n    switch (dataType.typeClass) {\n        case \"tuple\":\n            return dataType.memberTypes;\n            break;\n        case \"struct\":\n            debug(\"wrapping for struct %s\", dataType.typeName);\n            return (Format.Types.fullType(dataType, userDefinedTypes)).memberTypes;\n    }\n}\n//udvt cases\nfunction* udvtFromUnderlying(dataType, input, wrapOptions) {\n    const { underlyingType } = (Format.Types.fullType(dataType, wrapOptions.userDefinedTypes));\n    const value = yield* wrap(underlyingType, input, wrapOptions);\n    return {\n        type: dataType,\n        kind: \"value\",\n        value: value\n    };\n}\n//tx options cases\nfunction* optionsFromObject(dataType, input, wrapOptions) {\n    if (!Utils.isPlainObject(input)) {\n        //just checks that it's an object & not null\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a non-null object\");\n    }\n    debug(\"options input is object: %O\", input);\n    debug(\"wrapOptions: %O\", wrapOptions);\n    if (!wrapOptions.loose && Utils.isWrappedResult(input)) {\n        //similarly here\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was a wrapped result\");\n    }\n    //now... the main case\n    let value = {};\n    const uintKeys = [\n        \"gas\",\n        \"gasPrice\",\n        \"value\",\n        \"nonce\",\n        \"maxFeePerGas\",\n        \"maxPriorityFeePerGas\"\n    ];\n    const uint8Keys = [\"type\"];\n    const addressKeys = [\"from\", \"to\"];\n    const bytesKeys = [\"data\"];\n    const boolKeys = [\"overwrite\"];\n    const accessListKeys = [\"accessList\"];\n    const specialKeys = [\"privateFor\"];\n    const allKeys = [\n        ...uintKeys,\n        ...uint8Keys,\n        ...addressKeys,\n        ...bytesKeys,\n        ...boolKeys,\n        ...accessListKeys,\n        ...specialKeys\n    ];\n    const badKey = Object.keys(input).find(key => !allKeys.includes(key));\n    const goodKey = Object.keys(input).find(key => allKeys.includes(key));\n    if (badKey !== undefined && !wrapOptions.oldOptionsBehavior) {\n        //note we allow extra keys if oldOptionsBehavior is on -- this is a HACK\n        //to preserve existing behavior of Truffle Contract (perhaps we can\n        //change this in Truffle 6)\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, `Transaction options included unknown option ${badKey}`);\n    }\n    if (wrapOptions.oldOptionsBehavior && goodKey === undefined) {\n        //similarly, if oldOptionsBehavior is on, we require at least\n        //one *legit* key (again, HACK to preserve existing behavior,\n        //maybe remove this in Truffle 6)\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, `Transaction options included no recognized options`);\n    }\n    //otherwise, if all keys are transaction options, let's process them...\n    //part 1: uint options\n    for (const key of uintKeys) {\n        //note we check input[key] !== undefined, rather than key in input,\n        //because if one of them is undefined we want to just allow that but ignore it\n        if (input[key] !== undefined) {\n            const wrappedOption = (yield* (0, dispatch_1.wrapWithCases)({ typeClass: \"uint\", bits: 256 }, input[key], Object.assign(Object.assign({}, wrapOptions), { name: `${wrapOptions.name}.${key}` }), integer_1.integerCases));\n            value[key] = wrappedOption.value.asBN;\n        }\n    }\n    //part 2: uint8 options (just type for now)\n    for (const key of uint8Keys) {\n        if (input[key] !== undefined) {\n            const wrappedOption = (yield* (0, dispatch_1.wrapWithCases)({ typeClass: \"uint\", bits: 8 }, input[key], Object.assign(Object.assign({}, wrapOptions), { name: `${wrapOptions.name}.${key}` }), integer_1.integerCases));\n            const asBN = wrappedOption.value.asBN;\n            //since this is just type right now, we're going to reject illegal types\n            if (asBN.gten(0xc0)) {\n                //not making a constant for this, this is its only use here\n                throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.type`, 4, \"Transaction types must be less than 0xc0\");\n            }\n            //for compatibility, we give type as a hex string rather than\n            //leaving it as a BN.  Since it's unsigned we don't have to\n            //worry about negatives.\n            value[key] = Conversion.toHexString(asBN);\n        }\n    }\n    //part 3: address options\n    for (const key of addressKeys) {\n        if (input[key] !== undefined) {\n            const wrappedOption = (yield* (0, dispatch_1.wrapWithCases)({ typeClass: \"address\", kind: \"general\" }, input[key], Object.assign(Object.assign({}, wrapOptions), { name: `${wrapOptions.name}.${key}` }), address_1.addressCases));\n            value[key] = wrappedOption.value.asAddress;\n        }\n    }\n    //part 4: bytestring options\n    for (const key of bytesKeys) {\n        if (input[key] !== undefined) {\n            const wrappedOption = yield* (0, dispatch_1.wrapWithCases)({ typeClass: \"bytes\", kind: \"dynamic\" }, input[key], Object.assign(Object.assign({}, wrapOptions), { name: `${wrapOptions.name}.${key}` }), bytes_1.bytesCases);\n            value[key] = wrappedOption.value.asHex;\n        }\n    }\n    //part 5: boolean options\n    for (const key of boolKeys) {\n        if (input[key] !== undefined) {\n            const wrappedOption = yield* (0, dispatch_1.wrapWithCases)({ typeClass: \"bool\" }, input[key], Object.assign(Object.assign({}, wrapOptions), { name: `${wrapOptions.name}.${key}` }), bool_1.boolCases);\n            value[key] = wrappedOption.value.asBoolean;\n        }\n    }\n    //part 6: the access list\n    for (const key of accessListKeys) {\n        if (input[key] !== undefined) {\n            const wrappedOption = yield* (0, dispatch_1.wrapWithCases)({\n                typeClass: \"array\",\n                kind: \"dynamic\",\n                baseType: {\n                    typeClass: \"tuple\",\n                    memberTypes: [\n                        {\n                            name: \"address\",\n                            type: {\n                                typeClass: \"address\",\n                                kind: \"general\"\n                            }\n                        },\n                        {\n                            name: \"storageKeys\",\n                            type: {\n                                typeClass: \"array\",\n                                kind: \"dynamic\",\n                                baseType: {\n                                    //we use uint256 rather than bytes32 to allow\n                                    //abbreviating and left-padding\n                                    typeClass: \"uint\",\n                                    bits: 256\n                                }\n                            }\n                        }\n                    ]\n                }\n            }, input[key], Object.assign(Object.assign({}, wrapOptions), { name: `${wrapOptions.name}.${key}` }), exports.arrayCases);\n            value[key] = Format.Utils.Inspect.nativizeAccessList(wrappedOption);\n        }\n    }\n    //part 7: the special case of privateFor\n    if (input.privateFor !== undefined) {\n        //this doesn't correspond to any of our usual types, so we have to handle it specially\n        if (!Array.isArray(input.privateFor)) {\n            throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.privateFor`, 4, \"Transaction option privateFor should be an array of base64-encoded bytestrings of 32 bytes\");\n        }\n        value.privateFor = input.privateFor.map((publicKey, index) => {\n            if (Utils.isBoxedString(publicKey)) {\n                publicKey = publicKey.valueOf();\n            }\n            if (typeof publicKey !== \"string\") {\n                throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.privateFor`, 4, `Public key at index ${index} is not a string`);\n            }\n            if (!Utils.isBase64(publicKey)) {\n                throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.privateFor`, 4, `Public key at index ${index} is not base64-encoded`);\n            }\n            const length = Utils.base64Length(publicKey);\n            if (length !== 32) {\n                throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.privateFor`, 4, `Public key at index ${index} should encode a bytestring of 32 bytes; got ${length} bytes instead`);\n            }\n            return publicKey;\n        });\n    }\n    return {\n        type: dataType,\n        kind: \"value\",\n        value\n    };\n}\nfunction* optionsFromCodecOptionsValue(dataType, input, wrapOptions) {\n    if (!Utils.isWrappedResult(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n    }\n    if (input.type.typeClass !== \"options\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n    }\n    if (input.kind !== \"value\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n    }\n    const value = input.value;\n    //unlike in the array or tuple cases, here should not have\n    //to worry about compatible-but-not-identical types, so it's\n    //safe to just copy value over\n    return {\n        type: dataType,\n        kind: \"value\",\n        value\n    };\n}\nfunction* optionsFromTypeValueInput(dataType, input, wrapOptions) {\n    if (!Utils.isTypeValueInput(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n    }\n    if (input.type !== \"options\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n    }\n    //because options, unlike other containers, has specific types, we *will* turn on loose\n    return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), { loose: true }), txOptionsCasesBasic);\n}\nfunction* optionsFailureCase(dataType, input, wrapOptions) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, \"Transaction options input was not a plain object, type/value pair or wrapped options object\");\n}\n//# sourceMappingURL=wrap.js.map"]},"metadata":{},"sourceType":"script"}