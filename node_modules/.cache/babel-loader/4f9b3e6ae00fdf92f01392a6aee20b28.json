{"ast":null,"code":"//Const\nconst NOAH_ARK_CAPACITY = 3;\nexport var EntryType;\n\n(function (EntryType) {\n  EntryType[EntryType[\"Marker\"] = 0] = \"Marker\";\n  EntryType[EntryType[\"Element\"] = 1] = \"Element\";\n})(EntryType = EntryType || (EntryType = {}));\n\nconst MARKER = {\n  type: EntryType.Marker\n}; //List of formatting elements\n\nexport class FormattingElementList {\n  constructor(treeAdapter) {\n    this.treeAdapter = treeAdapter;\n    this.entries = [];\n    this.bookmark = null;\n  } //Noah Ark's condition\n  //OPTIMIZATION: at first we try to find possible candidates for exclusion using\n  //lightweight heuristics without thorough attributes check.\n\n\n  _getNoahArkConditionCandidates(newElement, neAttrs) {\n    const candidates = [];\n    const neAttrsLength = neAttrs.length;\n    const neTagName = this.treeAdapter.getTagName(newElement);\n    const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);\n\n    for (let i = 0; i < this.entries.length; i++) {\n      const entry = this.entries[i];\n\n      if (entry.type === EntryType.Marker) {\n        break;\n      }\n\n      const {\n        element\n      } = entry;\n\n      if (this.treeAdapter.getTagName(element) === neTagName && this.treeAdapter.getNamespaceURI(element) === neNamespaceURI) {\n        const elementAttrs = this.treeAdapter.getAttrList(element);\n\n        if (elementAttrs.length === neAttrsLength) {\n          candidates.push({\n            idx: i,\n            attrs: elementAttrs\n          });\n        }\n      }\n    }\n\n    return candidates;\n  }\n\n  _ensureNoahArkCondition(newElement) {\n    if (this.entries.length < NOAH_ARK_CAPACITY) return;\n    const neAttrs = this.treeAdapter.getAttrList(newElement);\n\n    const candidates = this._getNoahArkConditionCandidates(newElement, neAttrs);\n\n    if (candidates.length < NOAH_ARK_CAPACITY) return; //NOTE: build attrs map for the new element, so we can perform fast lookups\n\n    const neAttrsMap = new Map(neAttrs.map(neAttr => [neAttr.name, neAttr.value]));\n    let validCandidates = 0; //NOTE: remove bottommost candidates, until Noah's Ark condition will not be met\n\n    for (let i = 0; i < candidates.length; i++) {\n      const candidate = candidates[i]; // We know that `candidate.attrs.length === neAttrs.length`\n\n      if (candidate.attrs.every(cAttr => neAttrsMap.get(cAttr.name) === cAttr.value)) {\n        validCandidates += 1;\n\n        if (validCandidates >= NOAH_ARK_CAPACITY) {\n          this.entries.splice(candidate.idx, 1);\n        }\n      }\n    }\n  } //Mutations\n\n\n  insertMarker() {\n    this.entries.unshift(MARKER);\n  }\n\n  pushElement(element, token) {\n    this._ensureNoahArkCondition(element);\n\n    this.entries.unshift({\n      type: EntryType.Element,\n      element,\n      token\n    });\n  }\n\n  insertElementAfterBookmark(element, token) {\n    const bookmarkIdx = this.entries.indexOf(this.bookmark);\n    this.entries.splice(bookmarkIdx, 0, {\n      type: EntryType.Element,\n      element,\n      token\n    });\n  }\n\n  removeEntry(entry) {\n    const entryIndex = this.entries.indexOf(entry);\n\n    if (entryIndex >= 0) {\n      this.entries.splice(entryIndex, 1);\n    }\n  }\n  /**\n   * Clears the list of formatting elements up to the last marker.\n   *\n   * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker\n   */\n\n\n  clearToLastMarker() {\n    const markerIdx = this.entries.indexOf(MARKER);\n\n    if (markerIdx >= 0) {\n      this.entries.splice(0, markerIdx + 1);\n    } else {\n      this.entries.length = 0;\n    }\n  } //Search\n\n\n  getElementEntryInScopeWithTagName(tagName) {\n    const entry = this.entries.find(entry => entry.type === EntryType.Marker || this.treeAdapter.getTagName(entry.element) === tagName);\n    return entry && entry.type === EntryType.Element ? entry : null;\n  }\n\n  getElementEntry(element) {\n    return this.entries.find(entry => entry.type === EntryType.Element && entry.element === element);\n  }\n\n}","map":{"version":3,"sources":["U:/NFT-Mar/faucet/node_modules/cheerio/node_modules/parse5/dist/parser/formatting-element-list.js"],"names":["NOAH_ARK_CAPACITY","EntryType","MARKER","type","Marker","FormattingElementList","constructor","treeAdapter","entries","bookmark","_getNoahArkConditionCandidates","newElement","neAttrs","candidates","neAttrsLength","length","neTagName","getTagName","neNamespaceURI","getNamespaceURI","i","entry","element","elementAttrs","getAttrList","push","idx","attrs","_ensureNoahArkCondition","neAttrsMap","Map","map","neAttr","name","value","validCandidates","candidate","every","cAttr","get","splice","insertMarker","unshift","pushElement","token","Element","insertElementAfterBookmark","bookmarkIdx","indexOf","removeEntry","entryIndex","clearToLastMarker","markerIdx","getElementEntryInScopeWithTagName","tagName","find","getElementEntry"],"mappings":"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","sourcesContent":["//Const\nconst NOAH_ARK_CAPACITY = 3;\nexport var EntryType;\n(function (EntryType) {\n    EntryType[EntryType[\"Marker\"] = 0] = \"Marker\";\n    EntryType[EntryType[\"Element\"] = 1] = \"Element\";\n})(EntryType = EntryType || (EntryType = {}));\nconst MARKER = { type: EntryType.Marker };\n//List of formatting elements\nexport class FormattingElementList {\n    constructor(treeAdapter) {\n        this.treeAdapter = treeAdapter;\n        this.entries = [];\n        this.bookmark = null;\n    }\n    //Noah Ark's condition\n    //OPTIMIZATION: at first we try to find possible candidates for exclusion using\n    //lightweight heuristics without thorough attributes check.\n    _getNoahArkConditionCandidates(newElement, neAttrs) {\n        const candidates = [];\n        const neAttrsLength = neAttrs.length;\n        const neTagName = this.treeAdapter.getTagName(newElement);\n        const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);\n        for (let i = 0; i < this.entries.length; i++) {\n            const entry = this.entries[i];\n            if (entry.type === EntryType.Marker) {\n                break;\n            }\n            const { element } = entry;\n            if (this.treeAdapter.getTagName(element) === neTagName &&\n                this.treeAdapter.getNamespaceURI(element) === neNamespaceURI) {\n                const elementAttrs = this.treeAdapter.getAttrList(element);\n                if (elementAttrs.length === neAttrsLength) {\n                    candidates.push({ idx: i, attrs: elementAttrs });\n                }\n            }\n        }\n        return candidates;\n    }\n    _ensureNoahArkCondition(newElement) {\n        if (this.entries.length < NOAH_ARK_CAPACITY)\n            return;\n        const neAttrs = this.treeAdapter.getAttrList(newElement);\n        const candidates = this._getNoahArkConditionCandidates(newElement, neAttrs);\n        if (candidates.length < NOAH_ARK_CAPACITY)\n            return;\n        //NOTE: build attrs map for the new element, so we can perform fast lookups\n        const neAttrsMap = new Map(neAttrs.map((neAttr) => [neAttr.name, neAttr.value]));\n        let validCandidates = 0;\n        //NOTE: remove bottommost candidates, until Noah's Ark condition will not be met\n        for (let i = 0; i < candidates.length; i++) {\n            const candidate = candidates[i];\n            // We know that `candidate.attrs.length === neAttrs.length`\n            if (candidate.attrs.every((cAttr) => neAttrsMap.get(cAttr.name) === cAttr.value)) {\n                validCandidates += 1;\n                if (validCandidates >= NOAH_ARK_CAPACITY) {\n                    this.entries.splice(candidate.idx, 1);\n                }\n            }\n        }\n    }\n    //Mutations\n    insertMarker() {\n        this.entries.unshift(MARKER);\n    }\n    pushElement(element, token) {\n        this._ensureNoahArkCondition(element);\n        this.entries.unshift({\n            type: EntryType.Element,\n            element,\n            token,\n        });\n    }\n    insertElementAfterBookmark(element, token) {\n        const bookmarkIdx = this.entries.indexOf(this.bookmark);\n        this.entries.splice(bookmarkIdx, 0, {\n            type: EntryType.Element,\n            element,\n            token,\n        });\n    }\n    removeEntry(entry) {\n        const entryIndex = this.entries.indexOf(entry);\n        if (entryIndex >= 0) {\n            this.entries.splice(entryIndex, 1);\n        }\n    }\n    /**\n     * Clears the list of formatting elements up to the last marker.\n     *\n     * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker\n     */\n    clearToLastMarker() {\n        const markerIdx = this.entries.indexOf(MARKER);\n        if (markerIdx >= 0) {\n            this.entries.splice(0, markerIdx + 1);\n        }\n        else {\n            this.entries.length = 0;\n        }\n    }\n    //Search\n    getElementEntryInScopeWithTagName(tagName) {\n        const entry = this.entries.find((entry) => entry.type === EntryType.Marker || this.treeAdapter.getTagName(entry.element) === tagName);\n        return entry && entry.type === EntryType.Element ? entry : null;\n    }\n    getElementEntry(element) {\n        return this.entries.find((entry) => entry.type === EntryType.Element && entry.element === element);\n    }\n}\n//# sourceMappingURL=formatting-element-list.js.map"]},"metadata":{},"sourceType":"module"}