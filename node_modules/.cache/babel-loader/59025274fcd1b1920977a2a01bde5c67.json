{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateUint8ArrayLike = exports.bytesCases = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"codec:wrap:bytes\");\n\nconst dispatch_1 = require(\"./dispatch\");\n\nconst errors_1 = require(\"./errors\");\n\nconst Conversion = __importStar(require(\"../conversion\"));\n\nconst Utils = __importStar(require(\"./utils\"));\n\nconst Messages = __importStar(require(\"./messages\"));\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nconst bytesFromStringCases = [bytesFromHexString, bytesFromIntegerString //dynamic loose mode only; make sure this goes after hex string case!\n];\nconst bytesCasesBasic = [...bytesFromStringCases, bytesFromBoxedString, bytesFromUint8ArrayLike, bytesFromCodecBytesValue, bytesFromCodecUdvtValue, bytesFromEncodingTextInput, bytesFromNumber, bytesFromBoxedNumber, bytesFromBigint, bytesFromBN, bytesFromBig, bytesFromOther //dynamic loose mode only, is failure case otherwise. Make sure this goes last!\n];\nexports.bytesCases = [bytesFromTypeValueInput, ...bytesCasesBasic];\n\nfunction* bytesFromHexString(dataType, input, wrapOptions) {\n  if (typeof input !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n  }\n\n  const trimmed = Utils.removeUnderscoresHex(input); //(but not between individual hex digits)\n\n  if (!Utils.isByteString(trimmed)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.notABytestringMessage(\"Input\"));\n  }\n\n  const asHex = validateAndPad(dataType, trimmed, input, wrapOptions.name);\n  return {\n    //TS is complaining again\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asHex\n    }\n  };\n}\n\nfunction* bytesFromIntegerString(dataType, input, wrapOptions) {\n  if (!wrapOptions.loose || dataType.kind === \"static\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.looseModeOnlyMessage);\n  }\n\n  if (typeof input !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n  }\n\n  if (input.trim() === \"\") {\n    //bigint accepts this but we shouldn't\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.notABytestringMessage(\"Input\"));\n  }\n\n  const trimmed = Utils.removeUnderscoresNumeric(input);\n  let asBigInt;\n\n  try {\n    //we'll use BigInt to parse integer strings, as it's pretty good at it.\n    //Note that it accepts hex/octal/binary with prefixes 0x, 0o, 0b.\n    asBigInt = BigInt(trimmed);\n  } catch (_a) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input string was not a byte string or integer string\");\n  }\n\n  if (asBigInt < 0) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.negativeBytesMessage);\n  }\n\n  let asHex = Conversion.toHexString(asBigInt);\n  asHex = adjustZeroNumericInput(asHex); //because we're in dynamic case, we can skip validateAndPad\n\n  return {\n    //TS is complaining again\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asHex\n    }\n  };\n}\n\nfunction* bytesFromBoxedString(dataType, input, wrapOptions) {\n  if (!Utils.isBoxedString(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a boxed string\");\n  } //defer to primitive string cases\n\n\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, input.valueOf(), wrapOptions, bytesFromStringCases);\n}\n\nfunction* bytesFromUint8ArrayLike(dataType, input, wrapOptions) {\n  if (!Utils.isUint8ArrayLike(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a Uint8Array-like\");\n  } //the next series of checks is delegated to a helper fn\n\n\n  validateUint8ArrayLike(input, dataType, wrapOptions.name); //(this fn just throws an appropriate error if something's bad)\n\n  let asHex = Conversion.toHexString(new Uint8Array(input)); //I am surprised TS accepts this!\n\n  asHex = validateAndPad(dataType, asHex, input, wrapOptions.name);\n  return {\n    //TS is complaining again\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asHex\n    }\n  };\n}\n\nfunction* bytesFromEncodingTextInput(dataType, input, wrapOptions) {\n  if (!Utils.isEncodingTextInput(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a in encoding/text form\");\n  }\n\n  if (input.encoding !== \"utf8\") {\n    //(the only allowed encoding :P )\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, `Unknown or unsupported text encoding ${input.encoding}`);\n  }\n\n  let asHex;\n\n  try {\n    asHex = Conversion.toHexString(Conversion.stringToBytes(input.text));\n  } catch (_a) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.invalidUtf16Message);\n  }\n\n  asHex = validateAndPad(dataType, asHex, input, wrapOptions.name);\n  return {\n    //TS is complaining again\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asHex\n    }\n  };\n}\n\nfunction* bytesFromCodecBytesValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n\n  if (input.type.typeClass !== \"bytes\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n\n  if (!wrapOptions.loose && !(input.type.kind === \"dynamic\" && dataType.kind === \"dynamic\") && !(input.type.kind === \"static\" && dataType.kind === \"static\" && input.type.length === dataType.length)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n\n  let asHex = input.value.asHex;\n  asHex = validateAndPad(dataType, asHex, input, wrapOptions.name);\n  return {\n    //TS is complaining again\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asHex\n    }\n  };\n}\n\nfunction* bytesFromCodecUdvtValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n\n  if (input.type.typeClass !== \"userDefinedValueType\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.wrappedTypeMessage(input.type));\n  }\n\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n\n  return yield* bytesFromCodecBytesValue(dataType, input.value, wrapOptions);\n}\n\nfunction* bytesFromTypeValueInput(dataType, input, wrapOptions) {\n  if (!Utils.isTypeValueInput(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n  }\n\n  if (!input.type.match(/^byte(s\\d*)?$/)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n  }\n\n  debug(\"input.type: %s\", input.type); //now: determine the specified length; we use \"null\" for dynamic\n  //note that \"byte\" is allowed, with a length of 1\n\n  let length = null;\n  let match = input.type.match(/^bytes(\\d+)$/);\n\n  if (match) {\n    length = Number(match[1]); //static case with specified number\n  } else if (input.type === \"byte\") {\n    //\"byte\" case; set length to 1\n    length = 1;\n  } //otherwise, it's dynamic, so leave it at the default of null\n\n\n  debug(\"length: %o\", length); //check: does the specified length match the data type length?\n\n  if (!(length === null && dataType.kind === \"dynamic\") && !(dataType.kind === \"static\" && length === dataType.length)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n  } //extract value & try again, with loose option turned on\n\n\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), {\n    loose: true\n  }), bytesCasesBasic);\n}\n\nfunction* bytesFromNumber(dataType, input, wrapOptions) {\n  if (!wrapOptions.loose || dataType.kind === \"static\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.looseModeOnlyMessage);\n  }\n\n  if (typeof input !== \"number\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a number\");\n  }\n\n  if (!Number.isInteger(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.nonIntegerMessage);\n  }\n\n  if (!Number.isSafeInteger(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.nonSafeMessage);\n  }\n\n  if (input < 0) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.negativeBytesMessage);\n  }\n\n  let asHex = Conversion.toHexString(input);\n  asHex = adjustZeroNumericInput(asHex); //because we're in dynamic case, we can skip validateAndPad\n\n  return {\n    //TS is complaining again\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asHex\n    }\n  };\n}\n\nfunction* bytesFromBoxedNumber(dataType, input, wrapOptions) {\n  //skipping the wrapOptions.loose check, as that'll get checked\n  //in bytesFromNumber\n  if (!Utils.isBoxedNumber(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a boxed number\");\n  } //unbox and try again\n\n\n  return yield* bytesFromNumber(dataType, input.valueOf(), wrapOptions);\n}\n\nfunction* bytesFromBigint(dataType, input, wrapOptions) {\n  if (!wrapOptions.loose || dataType.kind === \"static\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.looseModeOnlyMessage);\n  }\n\n  if (typeof input !== \"bigint\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a bigint\");\n  }\n\n  if (input < 0) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.negativeBytesMessage);\n  }\n\n  let asHex = Conversion.toHexString(input);\n  asHex = adjustZeroNumericInput(asHex); //because we're in dynamic case, we can skip validateAndPad\n\n  return {\n    //TS is complaining again\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asHex\n    }\n  };\n}\n\nfunction* bytesFromBN(dataType, input, wrapOptions) {\n  if (!wrapOptions.loose || dataType.kind === \"static\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.looseModeOnlyMessage);\n  }\n\n  if (!bn_js_1.default.isBN(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a BN\");\n  }\n\n  if (input.isNeg()) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.negativeBytesMessage);\n  }\n\n  let asHex = Conversion.toHexString(input);\n  asHex = adjustZeroNumericInput(asHex); //because we're in dynamic case, we can skip validateAndPad\n\n  return {\n    //TS is complaining again\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asHex\n    }\n  };\n}\n\nfunction* bytesFromBig(dataType, input, wrapOptions) {\n  if (!wrapOptions.loose || dataType.kind === \"static\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.looseModeOnlyMessage);\n  }\n\n  if (!Conversion.isBig(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a Big\");\n  }\n\n  if (Conversion.countDecimalPlaces(input) !== 0) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.nonIntegerMessage);\n  }\n\n  if (input.lt(0)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.negativeBytesMessage);\n  }\n\n  let asHex = Conversion.toHexString(input);\n  asHex = adjustZeroNumericInput(asHex); //because we're in dynamic case, we can skip validateAndPad\n\n  return {\n    //TS is complaining again\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asHex\n    }\n  };\n}\n\nfunction* bytesFromOther(dataType, input, wrapOptions) {\n  if (!wrapOptions.loose || dataType.kind === \"static\") {\n    //outside of the dynamic-loose case, this is just a failure case\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, \"Input was not a hex string, byte-array-alike, encoding/text pair, type/value pair, or wrapped bytestring\");\n  }\n\n  const request = {\n    kind: \"integer\",\n    input\n  };\n  const response = yield request;\n\n  if (response.kind !== \"integer\") {\n    throw new errors_1.BadResponseTypeError(request, response);\n  }\n\n  if (response.value === null) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, response.partiallyRecognized ? 5 : 3, response.reason || \"Input was not a hex string, byte-array-alike, encoding/text pair, type/value pair, integer input, or wrapped bytestring\");\n  }\n\n  if (response.value < 0) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.negativeBytesMessage);\n  }\n\n  let asHex = Conversion.toHexString(response.value);\n  asHex = adjustZeroNumericInput(asHex); //because we're in dynamic case, we can skip validateAndPad\n\n  return {\n    //TS is complaining again\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asHex\n    }\n  };\n}\n\nfunction validateUint8ArrayLike(input, dataType, //for error information\nname //for error information\n) {\n  //this function doesn't return anything, it just throws errors if something\n  //goes wrong\n  if (input instanceof Uint8Array) {\n    return; //honest Uint8Arrays don't need checking\n  }\n\n  if (!Number.isSafeInteger(input.length)) {\n    throw new errors_1.TypeMismatchError(dataType, input, name, 5, \"Input is byte-array-like, but its length is not a safe integer\");\n  }\n\n  if (input.length < 0) {\n    throw new errors_1.TypeMismatchError(dataType, input, name, 5, \"Input is byte-array-like, but its length is negative\");\n  } //check: is it actually like a Uint8Array?\n\n\n  for (let index = 0; index < input.length; index++) {\n    if (typeof input[index] !== \"number\" || input[index] < 0 || input[index] >= 256 || !Number.isInteger(input[index])) {\n      throw new errors_1.TypeMismatchError(dataType, input, name, 5, `Input is byte-array-like, but byte ${index} is not a 1-byte value (number from 0 to 255)`);\n    }\n  } //otherwise, we didn't throw any errors, so return\n\n}\n\nexports.validateUint8ArrayLike = validateUint8ArrayLike;\n\nfunction validateAndPad(dataType, asHex, input, //for errors\nname //for errors\n) {\n  asHex = asHex.toLowerCase(); //if static, validate and pad\n\n  if (dataType.kind === \"static\") {\n    if ((asHex.length - 2) / 2 > dataType.length) {\n      throw new errors_1.TypeMismatchError(dataType, input, name, 5, Messages.overlongMessage(dataType.length, (asHex.length - 2) / 2));\n    } else {\n      asHex = asHex.padEnd(dataType.length * 2 + 2, \"00\");\n    }\n  }\n\n  return asHex;\n} //special case for ethers compatibility; represents 0 as 0x00 rather than 0x.\n//only for numeric input in loose mode, in dynamic case, for compatibility; not\n//for ordinary hex input, where the two are distinct!\n\n\nfunction adjustZeroNumericInput(asHex) {\n  return asHex === \"0x\" ? \"0x00\" : asHex;\n}","map":{"version":3,"sources":["../../../lib/wrap/bytes.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateUint8ArrayLike = exports.bytesCases = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:wrap:bytes\");\nconst dispatch_1 = require(\"./dispatch\");\nconst errors_1 = require(\"./errors\");\nconst Conversion = __importStar(require(\"../conversion\"));\nconst Utils = __importStar(require(\"./utils\"));\nconst Messages = __importStar(require(\"./messages\"));\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst bytesFromStringCases = [\n    bytesFromHexString,\n    bytesFromIntegerString //dynamic loose mode only; make sure this goes after hex string case!\n];\nconst bytesCasesBasic = [\n    ...bytesFromStringCases,\n    bytesFromBoxedString,\n    bytesFromUint8ArrayLike,\n    bytesFromCodecBytesValue,\n    bytesFromCodecUdvtValue,\n    bytesFromEncodingTextInput,\n    bytesFromNumber,\n    bytesFromBoxedNumber,\n    bytesFromBigint,\n    bytesFromBN,\n    bytesFromBig,\n    bytesFromOther //dynamic loose mode only, is failure case otherwise. Make sure this goes last!\n];\nexports.bytesCases = [bytesFromTypeValueInput, ...bytesCasesBasic];\nfunction* bytesFromHexString(dataType, input, wrapOptions) {\n    if (typeof input !== \"string\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n    }\n    const trimmed = Utils.removeUnderscoresHex(input);\n    //(but not between individual hex digits)\n    if (!Utils.isByteString(trimmed)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.notABytestringMessage(\"Input\"));\n    }\n    const asHex = validateAndPad(dataType, trimmed, input, wrapOptions.name);\n    return {\n        //TS is complaining again\n        type: dataType,\n        kind: \"value\",\n        value: {\n            asHex\n        }\n    };\n}\nfunction* bytesFromIntegerString(dataType, input, wrapOptions) {\n    if (!wrapOptions.loose || dataType.kind === \"static\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.looseModeOnlyMessage);\n    }\n    if (typeof input !== \"string\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n    }\n    if (input.trim() === \"\") {\n        //bigint accepts this but we shouldn't\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.notABytestringMessage(\"Input\"));\n    }\n    const trimmed = Utils.removeUnderscoresNumeric(input);\n    let asBigInt;\n    try {\n        //we'll use BigInt to parse integer strings, as it's pretty good at it.\n        //Note that it accepts hex/octal/binary with prefixes 0x, 0o, 0b.\n        asBigInt = BigInt(trimmed);\n    }\n    catch (_a) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input string was not a byte string or integer string\");\n    }\n    if (asBigInt < 0) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.negativeBytesMessage);\n    }\n    let asHex = Conversion.toHexString(asBigInt);\n    asHex = adjustZeroNumericInput(asHex);\n    //because we're in dynamic case, we can skip validateAndPad\n    return {\n        //TS is complaining again\n        type: dataType,\n        kind: \"value\",\n        value: {\n            asHex\n        }\n    };\n}\nfunction* bytesFromBoxedString(dataType, input, wrapOptions) {\n    if (!Utils.isBoxedString(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a boxed string\");\n    }\n    //defer to primitive string cases\n    return yield* (0, dispatch_1.wrapWithCases)(dataType, input.valueOf(), wrapOptions, bytesFromStringCases);\n}\nfunction* bytesFromUint8ArrayLike(dataType, input, wrapOptions) {\n    if (!Utils.isUint8ArrayLike(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a Uint8Array-like\");\n    }\n    //the next series of checks is delegated to a helper fn\n    validateUint8ArrayLike(input, dataType, wrapOptions.name); //(this fn just throws an appropriate error if something's bad)\n    let asHex = Conversion.toHexString(new Uint8Array(input)); //I am surprised TS accepts this!\n    asHex = validateAndPad(dataType, asHex, input, wrapOptions.name);\n    return {\n        //TS is complaining again\n        type: dataType,\n        kind: \"value\",\n        value: {\n            asHex\n        }\n    };\n}\nfunction* bytesFromEncodingTextInput(dataType, input, wrapOptions) {\n    if (!Utils.isEncodingTextInput(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a in encoding/text form\");\n    }\n    if (input.encoding !== \"utf8\") {\n        //(the only allowed encoding :P )\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, `Unknown or unsupported text encoding ${input.encoding}`);\n    }\n    let asHex;\n    try {\n        asHex = Conversion.toHexString(Conversion.stringToBytes(input.text));\n    }\n    catch (_a) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.invalidUtf16Message);\n    }\n    asHex = validateAndPad(dataType, asHex, input, wrapOptions.name);\n    return {\n        //TS is complaining again\n        type: dataType,\n        kind: \"value\",\n        value: {\n            asHex\n        }\n    };\n}\nfunction* bytesFromCodecBytesValue(dataType, input, wrapOptions) {\n    if (!Utils.isWrappedResult(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n    }\n    if (input.type.typeClass !== \"bytes\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n    }\n    if (input.kind !== \"value\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n    }\n    if (!wrapOptions.loose &&\n        !(input.type.kind === \"dynamic\" && dataType.kind === \"dynamic\") &&\n        !(input.type.kind === \"static\" &&\n            dataType.kind === \"static\" &&\n            input.type.length === dataType.length)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n    }\n    let asHex = input.value.asHex;\n    asHex = validateAndPad(dataType, asHex, input, wrapOptions.name);\n    return {\n        //TS is complaining again\n        type: dataType,\n        kind: \"value\",\n        value: {\n            asHex\n        }\n    };\n}\nfunction* bytesFromCodecUdvtValue(dataType, input, wrapOptions) {\n    if (!Utils.isWrappedResult(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n    }\n    if (input.type.typeClass !== \"userDefinedValueType\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.wrappedTypeMessage(input.type));\n    }\n    if (input.kind !== \"value\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n    }\n    return yield* bytesFromCodecBytesValue(dataType, input.value, wrapOptions);\n}\nfunction* bytesFromTypeValueInput(dataType, input, wrapOptions) {\n    if (!Utils.isTypeValueInput(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n    }\n    if (!input.type.match(/^byte(s\\d*)?$/)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n    }\n    debug(\"input.type: %s\", input.type);\n    //now: determine the specified length; we use \"null\" for dynamic\n    //note that \"byte\" is allowed, with a length of 1\n    let length = null;\n    let match = input.type.match(/^bytes(\\d+)$/);\n    if (match) {\n        length = Number(match[1]); //static case with specified number\n    }\n    else if (input.type === \"byte\") {\n        //\"byte\" case; set length to 1\n        length = 1;\n    }\n    //otherwise, it's dynamic, so leave it at the default of null\n    debug(\"length: %o\", length);\n    //check: does the specified length match the data type length?\n    if (!(length === null && dataType.kind === \"dynamic\") &&\n        !(dataType.kind === \"static\" && length === dataType.length)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n    }\n    //extract value & try again, with loose option turned on\n    return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), { loose: true }), bytesCasesBasic);\n}\nfunction* bytesFromNumber(dataType, input, wrapOptions) {\n    if (!wrapOptions.loose || dataType.kind === \"static\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.looseModeOnlyMessage);\n    }\n    if (typeof input !== \"number\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a number\");\n    }\n    if (!Number.isInteger(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.nonIntegerMessage);\n    }\n    if (!Number.isSafeInteger(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.nonSafeMessage);\n    }\n    if (input < 0) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.negativeBytesMessage);\n    }\n    let asHex = Conversion.toHexString(input);\n    asHex = adjustZeroNumericInput(asHex);\n    //because we're in dynamic case, we can skip validateAndPad\n    return {\n        //TS is complaining again\n        type: dataType,\n        kind: \"value\",\n        value: {\n            asHex\n        }\n    };\n}\nfunction* bytesFromBoxedNumber(dataType, input, wrapOptions) {\n    //skipping the wrapOptions.loose check, as that'll get checked\n    //in bytesFromNumber\n    if (!Utils.isBoxedNumber(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a boxed number\");\n    }\n    //unbox and try again\n    return yield* bytesFromNumber(dataType, input.valueOf(), wrapOptions);\n}\nfunction* bytesFromBigint(dataType, input, wrapOptions) {\n    if (!wrapOptions.loose || dataType.kind === \"static\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.looseModeOnlyMessage);\n    }\n    if (typeof input !== \"bigint\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a bigint\");\n    }\n    if (input < 0) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.negativeBytesMessage);\n    }\n    let asHex = Conversion.toHexString(input);\n    asHex = adjustZeroNumericInput(asHex);\n    //because we're in dynamic case, we can skip validateAndPad\n    return {\n        //TS is complaining again\n        type: dataType,\n        kind: \"value\",\n        value: {\n            asHex\n        }\n    };\n}\nfunction* bytesFromBN(dataType, input, wrapOptions) {\n    if (!wrapOptions.loose || dataType.kind === \"static\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.looseModeOnlyMessage);\n    }\n    if (!bn_js_1.default.isBN(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a BN\");\n    }\n    if (input.isNeg()) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.negativeBytesMessage);\n    }\n    let asHex = Conversion.toHexString(input);\n    asHex = adjustZeroNumericInput(asHex);\n    //because we're in dynamic case, we can skip validateAndPad\n    return {\n        //TS is complaining again\n        type: dataType,\n        kind: \"value\",\n        value: {\n            asHex\n        }\n    };\n}\nfunction* bytesFromBig(dataType, input, wrapOptions) {\n    if (!wrapOptions.loose || dataType.kind === \"static\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.looseModeOnlyMessage);\n    }\n    if (!Conversion.isBig(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a Big\");\n    }\n    if (Conversion.countDecimalPlaces(input) !== 0) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.nonIntegerMessage);\n    }\n    if (input.lt(0)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.negativeBytesMessage);\n    }\n    let asHex = Conversion.toHexString(input);\n    asHex = adjustZeroNumericInput(asHex);\n    //because we're in dynamic case, we can skip validateAndPad\n    return {\n        //TS is complaining again\n        type: dataType,\n        kind: \"value\",\n        value: {\n            asHex\n        }\n    };\n}\nfunction* bytesFromOther(dataType, input, wrapOptions) {\n    if (!wrapOptions.loose || dataType.kind === \"static\") {\n        //outside of the dynamic-loose case, this is just a failure case\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, \"Input was not a hex string, byte-array-alike, encoding/text pair, type/value pair, or wrapped bytestring\");\n    }\n    const request = { kind: \"integer\", input };\n    const response = yield request;\n    if (response.kind !== \"integer\") {\n        throw new errors_1.BadResponseTypeError(request, response);\n    }\n    if (response.value === null) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, response.partiallyRecognized ? 5 : 3, response.reason ||\n            \"Input was not a hex string, byte-array-alike, encoding/text pair, type/value pair, integer input, or wrapped bytestring\");\n    }\n    if (response.value < 0) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.negativeBytesMessage);\n    }\n    let asHex = Conversion.toHexString(response.value);\n    asHex = adjustZeroNumericInput(asHex);\n    //because we're in dynamic case, we can skip validateAndPad\n    return {\n        //TS is complaining again\n        type: dataType,\n        kind: \"value\",\n        value: {\n            asHex\n        }\n    };\n}\nfunction validateUint8ArrayLike(input, dataType, //for error information\nname //for error information\n) {\n    //this function doesn't return anything, it just throws errors if something\n    //goes wrong\n    if (input instanceof Uint8Array) {\n        return; //honest Uint8Arrays don't need checking\n    }\n    if (!Number.isSafeInteger(input.length)) {\n        throw new errors_1.TypeMismatchError(dataType, input, name, 5, \"Input is byte-array-like, but its length is not a safe integer\");\n    }\n    if (input.length < 0) {\n        throw new errors_1.TypeMismatchError(dataType, input, name, 5, \"Input is byte-array-like, but its length is negative\");\n    }\n    //check: is it actually like a Uint8Array?\n    for (let index = 0; index < input.length; index++) {\n        if (typeof input[index] !== \"number\" ||\n            input[index] < 0 ||\n            input[index] >= 256 ||\n            !Number.isInteger(input[index])) {\n            throw new errors_1.TypeMismatchError(dataType, input, name, 5, `Input is byte-array-like, but byte ${index} is not a 1-byte value (number from 0 to 255)`);\n        }\n    }\n    //otherwise, we didn't throw any errors, so return\n}\nexports.validateUint8ArrayLike = validateUint8ArrayLike;\nfunction validateAndPad(dataType, asHex, input, //for errors\nname //for errors\n) {\n    asHex = asHex.toLowerCase();\n    //if static, validate and pad\n    if (dataType.kind === \"static\") {\n        if ((asHex.length - 2) / 2 > dataType.length) {\n            throw new errors_1.TypeMismatchError(dataType, input, name, 5, Messages.overlongMessage(dataType.length, (asHex.length - 2) / 2));\n        }\n        else {\n            asHex = asHex.padEnd(dataType.length * 2 + 2, \"00\");\n        }\n    }\n    return asHex;\n}\n//special case for ethers compatibility; represents 0 as 0x00 rather than 0x.\n//only for numeric input in loose mode, in dynamic case, for compatibility; not\n//for ordinary hex input, where the two are distinct!\nfunction adjustZeroNumericInput(asHex) {\n    return asHex === \"0x\" ? \"0x00\" : asHex;\n}\n//# sourceMappingURL=bytes.js.map"]},"metadata":{},"sourceType":"script"}