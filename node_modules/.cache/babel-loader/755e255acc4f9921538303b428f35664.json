{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unrecognizedNumberMessage = exports.wrongLengthMessage = exports.notABytestringMessage = exports.tooPreciseMessage = exports.overlongMessage = exports.specifiedTypeMessage = exports.wrappedTypeMessage = exports.negativeBytesMessage = exports.looseModeOnlyMessage = exports.invalidUtf16Message = exports.checksumFailedMessage = exports.outOfRangeEnumMessage = exports.outOfRangeMessage = exports.badEnumMessage = exports.nonSafeMessage = exports.nonNumericMessage = exports.nonIntegerMessage = exports.notAStringMessage = exports.errorResultMessage = exports.wrongArrayLengthMessage = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"codec:wrap:messages\");\n\nconst Format = __importStar(require(\"../format\"));\n\nfunction wrongArrayLengthMessage(expected, got) {\n  return `Incorrect array length (expected ${expected.toString()} entries, got ${got})`;\n}\n\nexports.wrongArrayLengthMessage = wrongArrayLengthMessage;\nexports.errorResultMessage = \"Input is a wrapped result representing an error rather than a value\";\nexports.notAStringMessage = \"Input was not a string, type/value pair, or wrapped or boxed string\";\nexports.nonIntegerMessage = \"Input numeric value was not an integer\";\nexports.nonNumericMessage = \"Input string was not numeric\";\nexports.nonSafeMessage = \"Input number is not a Javascript safe integer\";\nexports.badEnumMessage = \"Input string was neither numeric nor a valid enum value\";\nexports.outOfRangeMessage = \"Input is outside the range of this numeric type\";\nexports.outOfRangeEnumMessage = \"Input is outside the range of this enum type\";\nexports.checksumFailedMessage = \"Address checksum failed (use all lowercase or all uppercase to circumvent)\";\nexports.invalidUtf16Message = \"Input string was not valid UTF-16\";\nexports.looseModeOnlyMessage = \"Numeric input for bytes is only allowed in loose mode and only for dynamic-length bytestrings\";\nexports.negativeBytesMessage = \"Input for bytes cannot be negative\";\n\nfunction wrappedTypeMessage(dataType) {\n  return `Input is a wrapped value of type ${Format.Types.typeString(dataType)}`;\n}\n\nexports.wrappedTypeMessage = wrappedTypeMessage;\n\nfunction specifiedTypeMessage(dataType) {\n  return `Input had type explicitly specified as ${dataType}`;\n}\n\nexports.specifiedTypeMessage = specifiedTypeMessage;\n\nfunction overlongMessage(expected, got) {\n  return `Input is too long for type (expected ${expected} bytes, got ${got} bytes)`;\n}\n\nexports.overlongMessage = overlongMessage;\n\nfunction tooPreciseMessage(expected, got) {\n  return `Input has too many decimal places for type (expected ${expected} decimal places, got ${got} decimal places)`;\n}\n\nexports.tooPreciseMessage = tooPreciseMessage;\n\nfunction notABytestringMessage(what) {\n  return `${what} is not a valid bytestring (even-length hex string)`;\n}\n\nexports.notABytestringMessage = notABytestringMessage;\n\nfunction wrongLengthMessage(what, expected, got) {\n  return `Input ${what} was ${got} bytes instead of ${expected} bytes`;\n}\n\nexports.wrongLengthMessage = wrongLengthMessage;\n\nfunction unrecognizedNumberMessage(dataType) {\n  const enumMessage = dataType.typeClass === \"enum\" ? \"enum value name, \" : \"\";\n  const byteArrayMessage = dataType.typeClass !== \"fixed\" && dataType.typeClass !== \"ufixed\" ? \"byte-array-like, \" : \"\";\n  return `Input was not a number, big integer, numeric string, ${enumMessage}type/value pair, boxed number, ${byteArrayMessage}wrapped number or enum, or recognized big number class`;\n}\n\nexports.unrecognizedNumberMessage = unrecognizedNumberMessage;","map":{"version":3,"sources":["../../../lib/wrap/messages.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAA,OAAA,GAAA,eAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AACA,MAAM,KAAK,GAAG,CAAA,GAAA,OAAA,CAAA,OAAA,EAAY,qBAAZ,CAAd;;AAIA,MAAA,MAAA,GAAA,YAAA,CAAA,OAAA,CAAA,WAAA,CAAA,CAAA;;AAEA,SAAgB,uBAAhB,CAAwC,QAAxC,EAA+D,GAA/D,EAA0E;AACxE,SAAO,oCAAoC,QAAQ,CAAC,QAAT,EAAmB,iBAAiB,GAAG,GAAlF;AACD;;AAFD,OAAA,CAAA,uBAAA,GAAA,uBAAA;AAIa,OAAA,CAAA,kBAAA,GACX,qEADW;AAEA,OAAA,CAAA,iBAAA,GACX,qEADW;AAEA,OAAA,CAAA,iBAAA,GAA4B,wCAA5B;AACA,OAAA,CAAA,iBAAA,GAA4B,8BAA5B;AACA,OAAA,CAAA,cAAA,GAAyB,+CAAzB;AACA,OAAA,CAAA,cAAA,GACX,yDADW;AAEA,OAAA,CAAA,iBAAA,GAA4B,iDAA5B;AACA,OAAA,CAAA,qBAAA,GAAgC,8CAAhC;AACA,OAAA,CAAA,qBAAA,GACX,4EADW;AAEA,OAAA,CAAA,mBAAA,GAA+B,mCAA/B;AACA,OAAA,CAAA,oBAAA,GAA+B,+FAA/B;AACA,OAAA,CAAA,oBAAA,GAA+B,oCAA/B;;AAEb,SAAgB,kBAAhB,CAAmC,QAAnC,EAA8D;AAC5D,SAAO,oCAAoC,MAAM,CAAC,KAAP,CAAa,UAAb,CACzC,QADyC,CAE1C,EAFD;AAGD;;AAJD,OAAA,CAAA,kBAAA,GAAA,kBAAA;;AAKA,SAAgB,oBAAhB,CAAqC,QAArC,EAAqD;AACnD,SAAO,0CAA0C,QAAQ,EAAzD;AACD;;AAFD,OAAA,CAAA,oBAAA,GAAA,oBAAA;;AAGA,SAAgB,eAAhB,CAAgC,QAAhC,EAAkD,GAAlD,EAA6D;AAC3D,SAAO,wCAAwC,QAAQ,eAAe,GAAG,SAAzE;AACD;;AAFD,OAAA,CAAA,eAAA,GAAA,eAAA;;AAGA,SAAgB,iBAAhB,CAAkC,QAAlC,EAAoD,GAApD,EAA+D;AAC7D,SAAO,wDAAwD,QAAQ,wBAAwB,GAAG,kBAAlG;AACD;;AAFD,OAAA,CAAA,iBAAA,GAAA,iBAAA;;AAGA,SAAgB,qBAAhB,CAAsC,IAAtC,EAAkD;AAChD,SAAO,GAAG,IAAI,qDAAd;AACD;;AAFD,OAAA,CAAA,qBAAA,GAAA,qBAAA;;AAGA,SAAgB,kBAAhB,CACE,IADF,EAEE,QAFF,EAGE,GAHF,EAGa;AAEX,SAAO,SAAS,IAAI,QAAQ,GAAG,qBAAqB,QAAQ,QAA5D;AACD;;AAND,OAAA,CAAA,kBAAA,GAAA,kBAAA;;AAQA,SAAgB,yBAAhB,CACE,QADF,EAC2C;AAEzC,QAAM,WAAW,GAAG,QAAQ,CAAC,SAAT,KAAuB,MAAvB,GAChB,mBADgB,GAEhB,EAFJ;AAGA,QAAM,gBAAgB,GACpB,QAAQ,CAAC,SAAT,KAAuB,OAAvB,IAAkC,QAAQ,CAAC,SAAT,KAAuB,QAAzD,GACI,mBADJ,GAEI,EAHN;AAIA,SAAO,wDAAwD,WAAW,kCAAkC,gBAAgB,wDAA5H;AACD;;AAXD,OAAA,CAAA,yBAAA,GAAA,yBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.unrecognizedNumberMessage = exports.wrongLengthMessage = exports.notABytestringMessage = exports.tooPreciseMessage = exports.overlongMessage = exports.specifiedTypeMessage = exports.wrappedTypeMessage = exports.negativeBytesMessage = exports.looseModeOnlyMessage = exports.invalidUtf16Message = exports.checksumFailedMessage = exports.outOfRangeEnumMessage = exports.outOfRangeMessage = exports.badEnumMessage = exports.nonSafeMessage = exports.nonNumericMessage = exports.nonIntegerMessage = exports.notAStringMessage = exports.errorResultMessage = exports.wrongArrayLengthMessage = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:wrap:messages\");\nconst Format = __importStar(require(\"../format\"));\nfunction wrongArrayLengthMessage(expected, got) {\n    return `Incorrect array length (expected ${expected.toString()} entries, got ${got})`;\n}\nexports.wrongArrayLengthMessage = wrongArrayLengthMessage;\nexports.errorResultMessage = \"Input is a wrapped result representing an error rather than a value\";\nexports.notAStringMessage = \"Input was not a string, type/value pair, or wrapped or boxed string\";\nexports.nonIntegerMessage = \"Input numeric value was not an integer\";\nexports.nonNumericMessage = \"Input string was not numeric\";\nexports.nonSafeMessage = \"Input number is not a Javascript safe integer\";\nexports.badEnumMessage = \"Input string was neither numeric nor a valid enum value\";\nexports.outOfRangeMessage = \"Input is outside the range of this numeric type\";\nexports.outOfRangeEnumMessage = \"Input is outside the range of this enum type\";\nexports.checksumFailedMessage = \"Address checksum failed (use all lowercase or all uppercase to circumvent)\";\nexports.invalidUtf16Message = \"Input string was not valid UTF-16\";\nexports.looseModeOnlyMessage = \"Numeric input for bytes is only allowed in loose mode and only for dynamic-length bytestrings\";\nexports.negativeBytesMessage = \"Input for bytes cannot be negative\";\nfunction wrappedTypeMessage(dataType) {\n    return `Input is a wrapped value of type ${Format.Types.typeString(dataType)}`;\n}\nexports.wrappedTypeMessage = wrappedTypeMessage;\nfunction specifiedTypeMessage(dataType) {\n    return `Input had type explicitly specified as ${dataType}`;\n}\nexports.specifiedTypeMessage = specifiedTypeMessage;\nfunction overlongMessage(expected, got) {\n    return `Input is too long for type (expected ${expected} bytes, got ${got} bytes)`;\n}\nexports.overlongMessage = overlongMessage;\nfunction tooPreciseMessage(expected, got) {\n    return `Input has too many decimal places for type (expected ${expected} decimal places, got ${got} decimal places)`;\n}\nexports.tooPreciseMessage = tooPreciseMessage;\nfunction notABytestringMessage(what) {\n    return `${what} is not a valid bytestring (even-length hex string)`;\n}\nexports.notABytestringMessage = notABytestringMessage;\nfunction wrongLengthMessage(what, expected, got) {\n    return `Input ${what} was ${got} bytes instead of ${expected} bytes`;\n}\nexports.wrongLengthMessage = wrongLengthMessage;\nfunction unrecognizedNumberMessage(dataType) {\n    const enumMessage = dataType.typeClass === \"enum\"\n        ? \"enum value name, \"\n        : \"\";\n    const byteArrayMessage = dataType.typeClass !== \"fixed\" && dataType.typeClass !== \"ufixed\"\n        ? \"byte-array-like, \"\n        : \"\";\n    return `Input was not a number, big integer, numeric string, ${enumMessage}type/value pair, boxed number, ${byteArrayMessage}wrapped number or enum, or recognized big number class`;\n}\nexports.unrecognizedNumberMessage = unrecognizedNumberMessage;\n//# sourceMappingURL=messages.js.map"]},"metadata":{},"sourceType":"script"}