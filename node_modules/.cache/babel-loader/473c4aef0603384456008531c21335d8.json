{"ast":null,"code":"import { tuple } from './tuple.js';\nimport { uniqueArray } from './uniqueArray.js';\nimport { restrictedIntegerArbitraryBuilder } from './_internals/builders/RestrictedIntegerArbitraryBuilder.js';\nimport { maxGeneratedLengthFromSizeForArbitrary, MaxLengthUpperBound } from './_internals/helpers/MaxLengthFromMinLength.js';\n\nfunction extractMaxIndex(indexesAndValues) {\n  let maxIndex = -1;\n\n  for (let index = 0; index !== indexesAndValues.length; ++index) {\n    maxIndex = Math.max(maxIndex, indexesAndValues[index][0]);\n  }\n\n  return maxIndex;\n}\n\nfunction arrayFromItems(length, indexesAndValues) {\n  const array = Array(length);\n\n  for (let index = 0; index !== indexesAndValues.length; ++index) {\n    const it = indexesAndValues[index];\n    if (it[0] < length) array[it[0]] = it[1];\n  }\n\n  return array;\n}\n\nexport function sparseArray(arb) {\n  let constraints = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    size,\n    minNumElements = 0,\n    maxLength = MaxLengthUpperBound,\n    maxNumElements = maxLength,\n    noTrailingHole,\n    depthIdentifier\n  } = constraints;\n  const maxGeneratedNumElements = maxGeneratedLengthFromSizeForArbitrary(size, minNumElements, maxNumElements, constraints.maxNumElements !== undefined);\n  const maxGeneratedLength = maxGeneratedLengthFromSizeForArbitrary(size, maxGeneratedNumElements, maxLength, constraints.maxLength !== undefined);\n\n  if (minNumElements > maxLength) {\n    throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal length of the array`);\n  }\n\n  if (minNumElements > maxNumElements) {\n    throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal number of non-holes`);\n  }\n\n  const resultedMaxNumElements = Math.min(maxNumElements, maxLength);\n  const resultedSizeMaxNumElements = constraints.maxNumElements !== undefined || size !== undefined ? size : '=';\n  const maxGeneratedIndexAuthorized = Math.max(maxGeneratedLength - 1, 0);\n  const maxIndexAuthorized = Math.max(maxLength - 1, 0);\n  const sparseArrayNoTrailingHole = uniqueArray(tuple(restrictedIntegerArbitraryBuilder(0, maxGeneratedIndexAuthorized, maxIndexAuthorized), arb), {\n    size: resultedSizeMaxNumElements,\n    minLength: minNumElements,\n    maxLength: resultedMaxNumElements,\n    selector: item => item[0],\n    depthIdentifier\n  }).map(items => {\n    const lastIndex = extractMaxIndex(items);\n    return arrayFromItems(lastIndex + 1, items);\n  }, value => {\n    if (!Array.isArray(value)) {\n      throw new Error('Not supported entry type');\n    }\n\n    if (noTrailingHole && value.length !== 0 && !(value.length - 1 in value)) {\n      throw new Error('No trailing hole');\n    }\n\n    return Object.entries(value).map(entry => [Number(entry[0]), entry[1]]);\n  });\n\n  if (noTrailingHole || maxLength === minNumElements) {\n    return sparseArrayNoTrailingHole;\n  }\n\n  return tuple(sparseArrayNoTrailingHole, restrictedIntegerArbitraryBuilder(minNumElements, maxGeneratedLength, maxLength)).map(data => {\n    const sparse = data[0];\n    const targetLength = data[1];\n\n    if (sparse.length >= targetLength) {\n      return sparse;\n    }\n\n    const longerSparse = sparse.slice();\n    longerSparse.length = targetLength;\n    return longerSparse;\n  }, value => {\n    if (!Array.isArray(value)) {\n      throw new Error('Not supported entry type');\n    }\n\n    return [value, value.length];\n  });\n}","map":{"version":3,"sources":["U:/NFT-Mar/faucet/node_modules/fast-check/lib/esm/arbitrary/sparseArray.js"],"names":["tuple","uniqueArray","restrictedIntegerArbitraryBuilder","maxGeneratedLengthFromSizeForArbitrary","MaxLengthUpperBound","extractMaxIndex","indexesAndValues","maxIndex","index","length","Math","max","arrayFromItems","array","Array","it","sparseArray","arb","constraints","size","minNumElements","maxLength","maxNumElements","noTrailingHole","depthIdentifier","maxGeneratedNumElements","undefined","maxGeneratedLength","Error","resultedMaxNumElements","min","resultedSizeMaxNumElements","maxGeneratedIndexAuthorized","maxIndexAuthorized","sparseArrayNoTrailingHole","minLength","selector","item","map","items","lastIndex","value","isArray","Object","entries","entry","Number","data","sparse","targetLength","longerSparse","slice"],"mappings":"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","sourcesContent":["import { tuple } from './tuple.js';\nimport { uniqueArray } from './uniqueArray.js';\nimport { restrictedIntegerArbitraryBuilder } from './_internals/builders/RestrictedIntegerArbitraryBuilder.js';\nimport { maxGeneratedLengthFromSizeForArbitrary, MaxLengthUpperBound, } from './_internals/helpers/MaxLengthFromMinLength.js';\nfunction extractMaxIndex(indexesAndValues) {\n    let maxIndex = -1;\n    for (let index = 0; index !== indexesAndValues.length; ++index) {\n        maxIndex = Math.max(maxIndex, indexesAndValues[index][0]);\n    }\n    return maxIndex;\n}\nfunction arrayFromItems(length, indexesAndValues) {\n    const array = Array(length);\n    for (let index = 0; index !== indexesAndValues.length; ++index) {\n        const it = indexesAndValues[index];\n        if (it[0] < length)\n            array[it[0]] = it[1];\n    }\n    return array;\n}\nexport function sparseArray(arb, constraints = {}) {\n    const { size, minNumElements = 0, maxLength = MaxLengthUpperBound, maxNumElements = maxLength, noTrailingHole, depthIdentifier, } = constraints;\n    const maxGeneratedNumElements = maxGeneratedLengthFromSizeForArbitrary(size, minNumElements, maxNumElements, constraints.maxNumElements !== undefined);\n    const maxGeneratedLength = maxGeneratedLengthFromSizeForArbitrary(size, maxGeneratedNumElements, maxLength, constraints.maxLength !== undefined);\n    if (minNumElements > maxLength) {\n        throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal length of the array`);\n    }\n    if (minNumElements > maxNumElements) {\n        throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal number of non-holes`);\n    }\n    const resultedMaxNumElements = Math.min(maxNumElements, maxLength);\n    const resultedSizeMaxNumElements = constraints.maxNumElements !== undefined || size !== undefined ? size : '=';\n    const maxGeneratedIndexAuthorized = Math.max(maxGeneratedLength - 1, 0);\n    const maxIndexAuthorized = Math.max(maxLength - 1, 0);\n    const sparseArrayNoTrailingHole = uniqueArray(tuple(restrictedIntegerArbitraryBuilder(0, maxGeneratedIndexAuthorized, maxIndexAuthorized), arb), {\n        size: resultedSizeMaxNumElements,\n        minLength: minNumElements,\n        maxLength: resultedMaxNumElements,\n        selector: (item) => item[0],\n        depthIdentifier,\n    }).map((items) => {\n        const lastIndex = extractMaxIndex(items);\n        return arrayFromItems(lastIndex + 1, items);\n    }, (value) => {\n        if (!Array.isArray(value)) {\n            throw new Error('Not supported entry type');\n        }\n        if (noTrailingHole && value.length !== 0 && !(value.length - 1 in value)) {\n            throw new Error('No trailing hole');\n        }\n        return Object.entries(value).map((entry) => [Number(entry[0]), entry[1]]);\n    });\n    if (noTrailingHole || maxLength === minNumElements) {\n        return sparseArrayNoTrailingHole;\n    }\n    return tuple(sparseArrayNoTrailingHole, restrictedIntegerArbitraryBuilder(minNumElements, maxGeneratedLength, maxLength)).map((data) => {\n        const sparse = data[0];\n        const targetLength = data[1];\n        if (sparse.length >= targetLength) {\n            return sparse;\n        }\n        const longerSparse = sparse.slice();\n        longerSparse.length = targetLength;\n        return longerSparse;\n    }, (value) => {\n        if (!Array.isArray(value)) {\n            throw new Error('Not supported entry type');\n        }\n        return [value, value.length];\n    });\n}\n"]},"metadata":{},"sourceType":"module"}