{"ast":null,"code":"import { Stream } from '../../stream/Stream.js';\nimport { cloneIfNeeded, cloneMethod } from '../../check/symbols.js';\nimport { integer } from '../integer.js';\nimport { makeLazy } from '../../stream/LazyIterableIterator.js';\nimport { Arbitrary } from '../../check/arbitrary/definition/Arbitrary.js';\nimport { Value } from '../../check/arbitrary/definition/Value.js';\nimport { getDepthContextFor } from './helpers/DepthContext.js';\nimport { buildSlicedGenerator } from './helpers/BuildSlicedGenerator.js';\n\nfunction biasedMaxLength(minLength, maxLength) {\n  if (minLength === maxLength) {\n    return minLength;\n  }\n\n  return minLength + Math.floor(Math.log(maxLength - minLength) / Math.log(2));\n}\n\nexport class ArrayArbitrary extends Arbitrary {\n  constructor(arb, minLength, maxGeneratedLength, maxLength, depthIdentifier, setBuilder, customSlices) {\n    super();\n    this.arb = arb;\n    this.minLength = minLength;\n    this.maxGeneratedLength = maxGeneratedLength;\n    this.maxLength = maxLength;\n    this.setBuilder = setBuilder;\n    this.customSlices = customSlices;\n    this.lengthArb = integer({\n      min: minLength,\n      max: maxGeneratedLength\n    });\n    this.depthContext = getDepthContextFor(depthIdentifier);\n  }\n\n  preFilter(tab) {\n    if (this.setBuilder === undefined) {\n      return tab;\n    }\n\n    const s = this.setBuilder();\n\n    for (let index = 0; index !== tab.length; ++index) {\n      s.tryAdd(tab[index]);\n    }\n\n    return s.getData();\n  }\n\n  static makeItCloneable(vs, shrinkables) {\n    vs[cloneMethod] = () => {\n      const cloned = [];\n\n      for (let idx = 0; idx !== shrinkables.length; ++idx) {\n        cloned.push(shrinkables[idx].value);\n      }\n\n      this.makeItCloneable(cloned, shrinkables);\n      return cloned;\n    };\n\n    return vs;\n  }\n\n  generateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems) {\n    let numSkippedInRow = 0;\n    const s = setBuilder();\n    const slicedGenerator = buildSlicedGenerator(this.arb, mrng, this.customSlices, biasFactorItems);\n\n    while (s.size() < N && numSkippedInRow < this.maxGeneratedLength) {\n      const current = slicedGenerator.next();\n\n      if (s.tryAdd(current)) {\n        numSkippedInRow = 0;\n      } else {\n        numSkippedInRow += 1;\n      }\n    }\n\n    return s.getData();\n  }\n\n  safeGenerateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems) {\n    const depthImpact = Math.max(0, N - biasedMaxLength(this.minLength, this.maxGeneratedLength));\n    this.depthContext.depth += depthImpact;\n\n    try {\n      return this.generateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems);\n    } finally {\n      this.depthContext.depth -= depthImpact;\n    }\n  }\n\n  generateNItems(N, mrng, biasFactorItems) {\n    const items = [];\n    const slicedGenerator = buildSlicedGenerator(this.arb, mrng, this.customSlices, biasFactorItems);\n    slicedGenerator.attemptExact(N);\n\n    for (let index = 0; index !== N; ++index) {\n      const current = slicedGenerator.next();\n      items.push(current);\n    }\n\n    return items;\n  }\n\n  safeGenerateNItems(N, mrng, biasFactorItems) {\n    const depthImpact = Math.max(0, N - biasedMaxLength(this.minLength, this.maxGeneratedLength));\n    this.depthContext.depth += depthImpact;\n\n    try {\n      return this.generateNItems(N, mrng, biasFactorItems);\n    } finally {\n      this.depthContext.depth -= depthImpact;\n    }\n  }\n\n  wrapper(itemsRaw, shrunkOnce, itemsRawLengthContext, startIndex) {\n    const items = shrunkOnce ? this.preFilter(itemsRaw) : itemsRaw;\n    let cloneable = false;\n    const vs = [];\n    const itemsContexts = [];\n\n    for (let idx = 0; idx !== items.length; ++idx) {\n      const s = items[idx];\n      cloneable = cloneable || s.hasToBeCloned;\n      vs.push(s.value);\n      itemsContexts.push(s.context);\n    }\n\n    if (cloneable) {\n      ArrayArbitrary.makeItCloneable(vs, items);\n    }\n\n    const context = {\n      shrunkOnce,\n      lengthContext: itemsRaw.length === items.length && itemsRawLengthContext !== undefined ? itemsRawLengthContext : undefined,\n      itemsContexts,\n      startIndex\n    };\n    return new Value(vs, context);\n  }\n\n  generate(mrng, biasFactor) {\n    const biasMeta = this.applyBias(mrng, biasFactor);\n    const targetSize = biasMeta.size;\n    const items = this.setBuilder !== undefined ? this.safeGenerateNItemsNoDuplicates(this.setBuilder, targetSize, mrng, biasMeta.biasFactorItems) : this.safeGenerateNItems(targetSize, mrng, biasMeta.biasFactorItems);\n    return this.wrapper(items, false, undefined, 0);\n  }\n\n  applyBias(mrng, biasFactor) {\n    if (biasFactor === undefined) {\n      return {\n        size: this.lengthArb.generate(mrng, undefined).value\n      };\n    }\n\n    if (this.minLength === this.maxGeneratedLength) {\n      return {\n        size: this.lengthArb.generate(mrng, undefined).value,\n        biasFactorItems: biasFactor\n      };\n    }\n\n    if (mrng.nextInt(1, biasFactor) !== 1) {\n      return {\n        size: this.lengthArb.generate(mrng, undefined).value\n      };\n    }\n\n    if (mrng.nextInt(1, biasFactor) !== 1 || this.minLength === this.maxGeneratedLength) {\n      return {\n        size: this.lengthArb.generate(mrng, undefined).value,\n        biasFactorItems: biasFactor\n      };\n    }\n\n    const maxBiasedLength = biasedMaxLength(this.minLength, this.maxGeneratedLength);\n    const targetSizeValue = integer({\n      min: this.minLength,\n      max: maxBiasedLength\n    }).generate(mrng, undefined);\n    return {\n      size: targetSizeValue.value,\n      biasFactorItems: biasFactor\n    };\n  }\n\n  canShrinkWithoutContext(value) {\n    if (!Array.isArray(value) || this.minLength > value.length || value.length > this.maxLength) {\n      return false;\n    }\n\n    for (let index = 0; index !== value.length; ++index) {\n      if (!(index in value)) {\n        return false;\n      }\n\n      if (!this.arb.canShrinkWithoutContext(value[index])) {\n        return false;\n      }\n    }\n\n    const filtered = this.preFilter(value.map(item => new Value(item, undefined)));\n    return filtered.length === value.length;\n  }\n\n  shrinkItemByItem(value, safeContext, endIndex) {\n    let shrinks = Stream.nil();\n\n    for (let index = safeContext.startIndex; index < endIndex; ++index) {\n      shrinks = shrinks.join(makeLazy(() => this.arb.shrink(value[index], safeContext.itemsContexts[index]).map(v => {\n        const beforeCurrent = value.slice(0, index).map((v, i) => new Value(cloneIfNeeded(v), safeContext.itemsContexts[i]));\n        const afterCurrent = value.slice(index + 1).map((v, i) => new Value(cloneIfNeeded(v), safeContext.itemsContexts[i + index + 1]));\n        return [beforeCurrent.concat(v).concat(afterCurrent), undefined, index];\n      })));\n    }\n\n    return shrinks;\n  }\n\n  shrinkImpl(value, context) {\n    if (value.length === 0) {\n      return Stream.nil();\n    }\n\n    const safeContext = context !== undefined ? context : {\n      shrunkOnce: false,\n      lengthContext: undefined,\n      itemsContexts: [],\n      startIndex: 0\n    };\n    return this.lengthArb.shrink(value.length, safeContext.lengthContext).drop(safeContext.shrunkOnce && safeContext.lengthContext === undefined && value.length > this.minLength + 1 ? 1 : 0).map(lengthValue => {\n      const sliceStart = value.length - lengthValue.value;\n      return [value.slice(sliceStart).map((v, index) => new Value(cloneIfNeeded(v), safeContext.itemsContexts[index + sliceStart])), lengthValue.context, 0];\n    }).join(makeLazy(() => value.length > this.minLength ? this.shrinkItemByItem(value, safeContext, 1) : this.shrinkItemByItem(value, safeContext, value.length))).join(value.length > this.minLength ? makeLazy(() => {\n      const subContext = {\n        shrunkOnce: false,\n        lengthContext: undefined,\n        itemsContexts: safeContext.itemsContexts.slice(1),\n        startIndex: 0\n      };\n      return this.shrinkImpl(value.slice(1), subContext).filter(v => this.minLength <= v[0].length + 1).map(v => {\n        return [[new Value(cloneIfNeeded(value[0]), safeContext.itemsContexts[0])].concat(v[0]), undefined, 0];\n      });\n    }) : Stream.nil());\n  }\n\n  shrink(value, context) {\n    return this.shrinkImpl(value, context).map(contextualValue => this.wrapper(contextualValue[0], true, contextualValue[1], contextualValue[2]));\n  }\n\n}","map":{"version":3,"sources":["U:/NFT-Mar/faucet/node_modules/fast-check/lib/esm/arbitrary/_internals/ArrayArbitrary.js"],"names":["Stream","cloneIfNeeded","cloneMethod","integer","makeLazy","Arbitrary","Value","getDepthContextFor","buildSlicedGenerator","biasedMaxLength","minLength","maxLength","Math","floor","log","ArrayArbitrary","constructor","arb","maxGeneratedLength","depthIdentifier","setBuilder","customSlices","lengthArb","min","max","depthContext","preFilter","tab","undefined","s","index","length","tryAdd","getData","makeItCloneable","vs","shrinkables","cloned","idx","push","value","generateNItemsNoDuplicates","N","mrng","biasFactorItems","numSkippedInRow","slicedGenerator","size","current","next","safeGenerateNItemsNoDuplicates","depthImpact","depth","generateNItems","items","attemptExact","safeGenerateNItems","wrapper","itemsRaw","shrunkOnce","itemsRawLengthContext","startIndex","cloneable","itemsContexts","hasToBeCloned","context","lengthContext","generate","biasFactor","biasMeta","applyBias","targetSize","nextInt","maxBiasedLength","targetSizeValue","canShrinkWithoutContext","Array","isArray","filtered","map","item","shrinkItemByItem","safeContext","endIndex","shrinks","nil","join","shrink","v","beforeCurrent","slice","i","afterCurrent","concat","shrinkImpl","drop","lengthValue","sliceStart","subContext","filter","contextualValue"],"mappings":"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","sourcesContent":["import { Stream } from '../../stream/Stream.js';\nimport { cloneIfNeeded, cloneMethod } from '../../check/symbols.js';\nimport { integer } from '../integer.js';\nimport { makeLazy } from '../../stream/LazyIterableIterator.js';\nimport { Arbitrary } from '../../check/arbitrary/definition/Arbitrary.js';\nimport { Value } from '../../check/arbitrary/definition/Value.js';\nimport { getDepthContextFor } from './helpers/DepthContext.js';\nimport { buildSlicedGenerator } from './helpers/BuildSlicedGenerator.js';\nfunction biasedMaxLength(minLength, maxLength) {\n    if (minLength === maxLength) {\n        return minLength;\n    }\n    return minLength + Math.floor(Math.log(maxLength - minLength) / Math.log(2));\n}\nexport class ArrayArbitrary extends Arbitrary {\n    constructor(arb, minLength, maxGeneratedLength, maxLength, depthIdentifier, setBuilder, customSlices) {\n        super();\n        this.arb = arb;\n        this.minLength = minLength;\n        this.maxGeneratedLength = maxGeneratedLength;\n        this.maxLength = maxLength;\n        this.setBuilder = setBuilder;\n        this.customSlices = customSlices;\n        this.lengthArb = integer({ min: minLength, max: maxGeneratedLength });\n        this.depthContext = getDepthContextFor(depthIdentifier);\n    }\n    preFilter(tab) {\n        if (this.setBuilder === undefined) {\n            return tab;\n        }\n        const s = this.setBuilder();\n        for (let index = 0; index !== tab.length; ++index) {\n            s.tryAdd(tab[index]);\n        }\n        return s.getData();\n    }\n    static makeItCloneable(vs, shrinkables) {\n        vs[cloneMethod] = () => {\n            const cloned = [];\n            for (let idx = 0; idx !== shrinkables.length; ++idx) {\n                cloned.push(shrinkables[idx].value);\n            }\n            this.makeItCloneable(cloned, shrinkables);\n            return cloned;\n        };\n        return vs;\n    }\n    generateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems) {\n        let numSkippedInRow = 0;\n        const s = setBuilder();\n        const slicedGenerator = buildSlicedGenerator(this.arb, mrng, this.customSlices, biasFactorItems);\n        while (s.size() < N && numSkippedInRow < this.maxGeneratedLength) {\n            const current = slicedGenerator.next();\n            if (s.tryAdd(current)) {\n                numSkippedInRow = 0;\n            }\n            else {\n                numSkippedInRow += 1;\n            }\n        }\n        return s.getData();\n    }\n    safeGenerateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems) {\n        const depthImpact = Math.max(0, N - biasedMaxLength(this.minLength, this.maxGeneratedLength));\n        this.depthContext.depth += depthImpact;\n        try {\n            return this.generateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems);\n        }\n        finally {\n            this.depthContext.depth -= depthImpact;\n        }\n    }\n    generateNItems(N, mrng, biasFactorItems) {\n        const items = [];\n        const slicedGenerator = buildSlicedGenerator(this.arb, mrng, this.customSlices, biasFactorItems);\n        slicedGenerator.attemptExact(N);\n        for (let index = 0; index !== N; ++index) {\n            const current = slicedGenerator.next();\n            items.push(current);\n        }\n        return items;\n    }\n    safeGenerateNItems(N, mrng, biasFactorItems) {\n        const depthImpact = Math.max(0, N - biasedMaxLength(this.minLength, this.maxGeneratedLength));\n        this.depthContext.depth += depthImpact;\n        try {\n            return this.generateNItems(N, mrng, biasFactorItems);\n        }\n        finally {\n            this.depthContext.depth -= depthImpact;\n        }\n    }\n    wrapper(itemsRaw, shrunkOnce, itemsRawLengthContext, startIndex) {\n        const items = shrunkOnce ? this.preFilter(itemsRaw) : itemsRaw;\n        let cloneable = false;\n        const vs = [];\n        const itemsContexts = [];\n        for (let idx = 0; idx !== items.length; ++idx) {\n            const s = items[idx];\n            cloneable = cloneable || s.hasToBeCloned;\n            vs.push(s.value);\n            itemsContexts.push(s.context);\n        }\n        if (cloneable) {\n            ArrayArbitrary.makeItCloneable(vs, items);\n        }\n        const context = {\n            shrunkOnce,\n            lengthContext: itemsRaw.length === items.length && itemsRawLengthContext !== undefined\n                ? itemsRawLengthContext\n                : undefined,\n            itemsContexts,\n            startIndex,\n        };\n        return new Value(vs, context);\n    }\n    generate(mrng, biasFactor) {\n        const biasMeta = this.applyBias(mrng, biasFactor);\n        const targetSize = biasMeta.size;\n        const items = this.setBuilder !== undefined\n            ? this.safeGenerateNItemsNoDuplicates(this.setBuilder, targetSize, mrng, biasMeta.biasFactorItems)\n            : this.safeGenerateNItems(targetSize, mrng, biasMeta.biasFactorItems);\n        return this.wrapper(items, false, undefined, 0);\n    }\n    applyBias(mrng, biasFactor) {\n        if (biasFactor === undefined) {\n            return { size: this.lengthArb.generate(mrng, undefined).value };\n        }\n        if (this.minLength === this.maxGeneratedLength) {\n            return { size: this.lengthArb.generate(mrng, undefined).value, biasFactorItems: biasFactor };\n        }\n        if (mrng.nextInt(1, biasFactor) !== 1) {\n            return { size: this.lengthArb.generate(mrng, undefined).value };\n        }\n        if (mrng.nextInt(1, biasFactor) !== 1 || this.minLength === this.maxGeneratedLength) {\n            return { size: this.lengthArb.generate(mrng, undefined).value, biasFactorItems: biasFactor };\n        }\n        const maxBiasedLength = biasedMaxLength(this.minLength, this.maxGeneratedLength);\n        const targetSizeValue = integer({ min: this.minLength, max: maxBiasedLength }).generate(mrng, undefined);\n        return { size: targetSizeValue.value, biasFactorItems: biasFactor };\n    }\n    canShrinkWithoutContext(value) {\n        if (!Array.isArray(value) || this.minLength > value.length || value.length > this.maxLength) {\n            return false;\n        }\n        for (let index = 0; index !== value.length; ++index) {\n            if (!(index in value)) {\n                return false;\n            }\n            if (!this.arb.canShrinkWithoutContext(value[index])) {\n                return false;\n            }\n        }\n        const filtered = this.preFilter(value.map((item) => new Value(item, undefined)));\n        return filtered.length === value.length;\n    }\n    shrinkItemByItem(value, safeContext, endIndex) {\n        let shrinks = Stream.nil();\n        for (let index = safeContext.startIndex; index < endIndex; ++index) {\n            shrinks = shrinks.join(makeLazy(() => this.arb.shrink(value[index], safeContext.itemsContexts[index]).map((v) => {\n                const beforeCurrent = value\n                    .slice(0, index)\n                    .map((v, i) => new Value(cloneIfNeeded(v), safeContext.itemsContexts[i]));\n                const afterCurrent = value\n                    .slice(index + 1)\n                    .map((v, i) => new Value(cloneIfNeeded(v), safeContext.itemsContexts[i + index + 1]));\n                return [\n                    beforeCurrent.concat(v).concat(afterCurrent),\n                    undefined,\n                    index,\n                ];\n            })));\n        }\n        return shrinks;\n    }\n    shrinkImpl(value, context) {\n        if (value.length === 0) {\n            return Stream.nil();\n        }\n        const safeContext = context !== undefined\n            ? context\n            : { shrunkOnce: false, lengthContext: undefined, itemsContexts: [], startIndex: 0 };\n        return (this.lengthArb\n            .shrink(value.length, safeContext.lengthContext)\n            .drop(safeContext.shrunkOnce && safeContext.lengthContext === undefined && value.length > this.minLength + 1 ? 1 : 0)\n            .map((lengthValue) => {\n            const sliceStart = value.length - lengthValue.value;\n            return [\n                value\n                    .slice(sliceStart)\n                    .map((v, index) => new Value(cloneIfNeeded(v), safeContext.itemsContexts[index + sliceStart])),\n                lengthValue.context,\n                0,\n            ];\n        })\n            .join(makeLazy(() => value.length > this.minLength\n            ? this.shrinkItemByItem(value, safeContext, 1)\n            : this.shrinkItemByItem(value, safeContext, value.length)))\n            .join(value.length > this.minLength\n            ? makeLazy(() => {\n                const subContext = {\n                    shrunkOnce: false,\n                    lengthContext: undefined,\n                    itemsContexts: safeContext.itemsContexts.slice(1),\n                    startIndex: 0,\n                };\n                return this.shrinkImpl(value.slice(1), subContext)\n                    .filter((v) => this.minLength <= v[0].length + 1)\n                    .map((v) => {\n                    return [\n                        [new Value(cloneIfNeeded(value[0]), safeContext.itemsContexts[0])].concat(v[0]),\n                        undefined,\n                        0,\n                    ];\n                });\n            })\n            : Stream.nil()));\n    }\n    shrink(value, context) {\n        return this.shrinkImpl(value, context).map((contextualValue) => this.wrapper(contextualValue[0], true, contextualValue[1], contextualValue[2]));\n    }\n}\n"]},"metadata":{},"sourceType":"module"}