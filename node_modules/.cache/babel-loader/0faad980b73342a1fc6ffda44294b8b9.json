{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.stringCases = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"codec:wrap:string\");\n\nconst dispatch_1 = require(\"./dispatch\");\n\nconst errors_1 = require(\"./errors\");\n\nconst decode_1 = require(\"../bytes/decode\");\n\nconst bytes_1 = require(\"./bytes\");\n\nconst Utils = __importStar(require(\"./utils\"));\n\nconst Messages = __importStar(require(\"./messages\"));\n\nconst stringCasesBasic = [stringFromString, stringFromBoxedString, stringFromCodecStringValue, stringFromUint8ArrayLike, stringFailureCase];\nexports.stringCases = [stringFromTypeValueInput, ...stringCasesBasic];\n\nfunction* stringFromString(dataType, input, wrapOptions) {\n  if (typeof input !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n  }\n\n  if (!Utils.isValidUtf16(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.invalidUtf16Message);\n  }\n\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: {\n      kind: \"valid\",\n      asString: input\n    }\n  };\n}\n\nfunction* stringFromBoxedString(dataType, input, wrapOptions) {\n  if (!Utils.isBoxedString(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a boxed string\");\n  } //defer to primitive string case\n\n\n  return yield* stringFromString(dataType, input.valueOf(), wrapOptions);\n}\n\nfunction* stringFromCodecStringValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n\n  if (input.type.typeClass !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  } //rather than dealing with the different kinds in this case\n  //for rewrapping, we'll just rewrap directly;\n  //yes, this is a bit inconsistent with how we handle this case for other types\n\n\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: input.value\n  };\n}\n\nfunction* stringFromUint8ArrayLike(dataType, input, wrapOptions) {\n  if (!Utils.isUint8ArrayLike(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a Uint8Array-like\");\n  } //the next series of checks is delegated to a helper fn\n\n\n  (0, bytes_1.validateUint8ArrayLike)(input, dataType, wrapOptions.name); //(this fn just throws an appropriate error if something's bad)\n\n  const info = (0, decode_1.decodeString)(new Uint8Array(input));\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: info\n  };\n}\n\nfunction* stringFromTypeValueInput(dataType, input, wrapOptions) {\n  if (!Utils.isTypeValueInput(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n  }\n\n  if (input.type !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n  } //extract value & try again, with loose option turned on\n\n\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), {\n    loose: true\n  }), stringCasesBasic);\n}\n\nfunction* stringFailureCase(dataType, input, wrapOptions) {\n  throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, Messages.notAStringMessage);\n}","map":{"version":3,"sources":["../../../lib/wrap/string.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.stringCases = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:wrap:string\");\nconst dispatch_1 = require(\"./dispatch\");\nconst errors_1 = require(\"./errors\");\nconst decode_1 = require(\"../bytes/decode\");\nconst bytes_1 = require(\"./bytes\");\nconst Utils = __importStar(require(\"./utils\"));\nconst Messages = __importStar(require(\"./messages\"));\nconst stringCasesBasic = [\n    stringFromString,\n    stringFromBoxedString,\n    stringFromCodecStringValue,\n    stringFromUint8ArrayLike,\n    stringFailureCase\n];\nexports.stringCases = [stringFromTypeValueInput, ...stringCasesBasic];\nfunction* stringFromString(dataType, input, wrapOptions) {\n    if (typeof input !== \"string\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n    }\n    if (!Utils.isValidUtf16(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.invalidUtf16Message);\n    }\n    return {\n        type: dataType,\n        kind: \"value\",\n        value: {\n            kind: \"valid\",\n            asString: input\n        }\n    };\n}\nfunction* stringFromBoxedString(dataType, input, wrapOptions) {\n    if (!Utils.isBoxedString(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a boxed string\");\n    }\n    //defer to primitive string case\n    return yield* stringFromString(dataType, input.valueOf(), wrapOptions);\n}\nfunction* stringFromCodecStringValue(dataType, input, wrapOptions) {\n    if (!Utils.isWrappedResult(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n    }\n    if (input.type.typeClass !== \"string\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n    }\n    if (input.kind !== \"value\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n    }\n    //rather than dealing with the different kinds in this case\n    //for rewrapping, we'll just rewrap directly;\n    //yes, this is a bit inconsistent with how we handle this case for other types\n    return {\n        type: dataType,\n        kind: \"value\",\n        value: input.value\n    };\n}\nfunction* stringFromUint8ArrayLike(dataType, input, wrapOptions) {\n    if (!Utils.isUint8ArrayLike(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a Uint8Array-like\");\n    }\n    //the next series of checks is delegated to a helper fn\n    (0, bytes_1.validateUint8ArrayLike)(input, dataType, wrapOptions.name); //(this fn just throws an appropriate error if something's bad)\n    const info = (0, decode_1.decodeString)(new Uint8Array(input));\n    return {\n        type: dataType,\n        kind: \"value\",\n        value: info\n    };\n}\nfunction* stringFromTypeValueInput(dataType, input, wrapOptions) {\n    if (!Utils.isTypeValueInput(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n    }\n    if (input.type !== \"string\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n    }\n    //extract value & try again, with loose option turned on\n    return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), { loose: true }), stringCasesBasic);\n}\nfunction* stringFailureCase(dataType, input, wrapOptions) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, Messages.notAStringMessage);\n}\n//# sourceMappingURL=string.js.map"]},"metadata":{},"sourceType":"script"}