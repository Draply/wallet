{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeXML = exports.decodeHTMLStrict = exports.decodeHTML = exports.determineBranch = exports.BinTrieFlags = exports.fromCodePoint = exports.replaceCodePoint = exports.decodeCodePoint = exports.xmlDecodeTree = exports.htmlDecodeTree = void 0;\n\nvar decode_data_html_js_1 = __importDefault(require(\"./generated/decode-data-html.js\"));\n\nexports.htmlDecodeTree = decode_data_html_js_1.default;\n\nvar decode_data_xml_js_1 = __importDefault(require(\"./generated/decode-data-xml.js\"));\n\nexports.xmlDecodeTree = decode_data_xml_js_1.default;\n\nvar decode_codepoint_js_1 = __importDefault(require(\"./decode_codepoint.js\"));\n\nexports.decodeCodePoint = decode_codepoint_js_1.default;\n\nvar decode_codepoint_js_2 = require(\"./decode_codepoint.js\");\n\nObject.defineProperty(exports, \"replaceCodePoint\", {\n  enumerable: true,\n  get: function () {\n    return decode_codepoint_js_2.replaceCodePoint;\n  }\n});\nObject.defineProperty(exports, \"fromCodePoint\", {\n  enumerable: true,\n  get: function () {\n    return decode_codepoint_js_2.fromCodePoint;\n  }\n});\nvar CharCodes;\n\n(function (CharCodes) {\n  CharCodes[CharCodes[\"NUM\"] = 35] = \"NUM\";\n  CharCodes[CharCodes[\"SEMI\"] = 59] = \"SEMI\";\n  CharCodes[CharCodes[\"ZERO\"] = 48] = \"ZERO\";\n  CharCodes[CharCodes[\"NINE\"] = 57] = \"NINE\";\n  CharCodes[CharCodes[\"LOWER_A\"] = 97] = \"LOWER_A\";\n  CharCodes[CharCodes[\"LOWER_F\"] = 102] = \"LOWER_F\";\n  CharCodes[CharCodes[\"LOWER_X\"] = 120] = \"LOWER_X\";\n  /** Bit that needs to be set to convert an upper case ASCII character to lower case */\n\n  CharCodes[CharCodes[\"To_LOWER_BIT\"] = 32] = \"To_LOWER_BIT\";\n})(CharCodes || (CharCodes = {}));\n\nvar BinTrieFlags;\n\n(function (BinTrieFlags) {\n  BinTrieFlags[BinTrieFlags[\"VALUE_LENGTH\"] = 49152] = \"VALUE_LENGTH\";\n  BinTrieFlags[BinTrieFlags[\"BRANCH_LENGTH\"] = 16256] = \"BRANCH_LENGTH\";\n  BinTrieFlags[BinTrieFlags[\"JUMP_TABLE\"] = 127] = \"JUMP_TABLE\";\n})(BinTrieFlags = exports.BinTrieFlags || (exports.BinTrieFlags = {}));\n\nfunction getDecoder(decodeTree) {\n  return function decodeHTMLBinary(str, strict) {\n    var ret = \"\";\n    var lastIdx = 0;\n    var strIdx = 0;\n\n    while ((strIdx = str.indexOf(\"&\", strIdx)) >= 0) {\n      ret += str.slice(lastIdx, strIdx);\n      lastIdx = strIdx; // Skip the \"&\"\n\n      strIdx += 1; // If we have a numeric entity, handle this separately.\n\n      if (str.charCodeAt(strIdx) === CharCodes.NUM) {\n        // Skip the leading \"&#\". For hex entities, also skip the leading \"x\".\n        var start = strIdx + 1;\n        var base = 10;\n        var cp = str.charCodeAt(start);\n\n        if ((cp | CharCodes.To_LOWER_BIT) === CharCodes.LOWER_X) {\n          base = 16;\n          strIdx += 1;\n          start += 1;\n        }\n\n        do cp = str.charCodeAt(++strIdx); while (cp >= CharCodes.ZERO && cp <= CharCodes.NINE || base === 16 && (cp | CharCodes.To_LOWER_BIT) >= CharCodes.LOWER_A && (cp | CharCodes.To_LOWER_BIT) <= CharCodes.LOWER_F);\n\n        if (start !== strIdx) {\n          var entity = str.substring(start, strIdx);\n          var parsed = parseInt(entity, base);\n\n          if (str.charCodeAt(strIdx) === CharCodes.SEMI) {\n            strIdx += 1;\n          } else if (strict) {\n            continue;\n          }\n\n          ret += (0, decode_codepoint_js_1.default)(parsed);\n          lastIdx = strIdx;\n        }\n\n        continue;\n      }\n\n      var resultIdx = 0;\n      var excess = 1;\n      var treeIdx = 0;\n      var current = decodeTree[treeIdx];\n\n      for (; strIdx < str.length; strIdx++, excess++) {\n        treeIdx = determineBranch(decodeTree, current, treeIdx + 1, str.charCodeAt(strIdx));\n        if (treeIdx < 0) break;\n        current = decodeTree[treeIdx];\n        var masked = current & BinTrieFlags.VALUE_LENGTH; // If the branch is a value, store it and continue\n\n        if (masked) {\n          // If we have a legacy entity while parsing strictly, just skip the number of bytes\n          if (!strict || str.charCodeAt(strIdx) === CharCodes.SEMI) {\n            resultIdx = treeIdx;\n            excess = 0;\n          } // The mask is the number of bytes of the value, including the current byte.\n\n\n          var valueLength = (masked >> 14) - 1;\n          if (valueLength === 0) break;\n          treeIdx += valueLength;\n        }\n      }\n\n      if (resultIdx !== 0) {\n        var valueLength = (decodeTree[resultIdx] & BinTrieFlags.VALUE_LENGTH) >> 14;\n        ret += valueLength === 1 ? String.fromCharCode(decodeTree[resultIdx] & ~BinTrieFlags.VALUE_LENGTH) : valueLength === 2 ? String.fromCharCode(decodeTree[resultIdx + 1]) : String.fromCharCode(decodeTree[resultIdx + 1], decodeTree[resultIdx + 2]);\n        lastIdx = strIdx - excess + 1;\n      }\n    }\n\n    return ret + str.slice(lastIdx);\n  };\n}\n\nfunction determineBranch(decodeTree, current, nodeIdx, char) {\n  var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;\n  var jumpOffset = current & BinTrieFlags.JUMP_TABLE; // Case 1: Single branch encoded in jump offset\n\n  if (branchCount === 0) {\n    return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;\n  } // Case 2: Multiple branches encoded in jump table\n\n\n  if (jumpOffset) {\n    var value = char - jumpOffset;\n    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;\n  } // Case 3: Multiple branches encoded in dictionary\n  // Binary search for the character.\n\n\n  var lo = nodeIdx;\n  var hi = lo + branchCount - 1;\n\n  while (lo <= hi) {\n    var mid = lo + hi >>> 1;\n    var midVal = decodeTree[mid];\n\n    if (midVal < char) {\n      lo = mid + 1;\n    } else if (midVal > char) {\n      hi = mid - 1;\n    } else {\n      return decodeTree[mid + branchCount];\n    }\n  }\n\n  return -1;\n}\n\nexports.determineBranch = determineBranch;\nvar htmlDecoder = getDecoder(decode_data_html_js_1.default);\nvar xmlDecoder = getDecoder(decode_data_xml_js_1.default);\n/**\n * Decodes an HTML string, allowing for entities not terminated by a semi-colon.\n *\n * @param str The string to decode.\n * @returns The decoded string.\n */\n\nfunction decodeHTML(str) {\n  return htmlDecoder(str, false);\n}\n\nexports.decodeHTML = decodeHTML;\n/**\n * Decodes an HTML string, requiring all entities to be terminated by a semi-colon.\n *\n * @param str The string to decode.\n * @returns The decoded string.\n */\n\nfunction decodeHTMLStrict(str) {\n  return htmlDecoder(str, true);\n}\n\nexports.decodeHTMLStrict = decodeHTMLStrict;\n/**\n * Decodes an XML string, requiring all entities to be terminated by a semi-colon.\n *\n * @param str The string to decode.\n * @returns The decoded string.\n */\n\nfunction decodeXML(str) {\n  return xmlDecoder(str, true);\n}\n\nexports.decodeXML = decodeXML;","map":{"version":3,"sources":["decode.ts"],"names":[],"mappings":"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","sourceRoot":"https://raw.githubusercontent.com/fb55/entities/867ac709ba482a56a98b7c35f49ca833c74dc193/src/","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decodeXML = exports.decodeHTMLStrict = exports.decodeHTML = exports.determineBranch = exports.BinTrieFlags = exports.fromCodePoint = exports.replaceCodePoint = exports.decodeCodePoint = exports.xmlDecodeTree = exports.htmlDecodeTree = void 0;\nvar decode_data_html_js_1 = __importDefault(require(\"./generated/decode-data-html.js\"));\nexports.htmlDecodeTree = decode_data_html_js_1.default;\nvar decode_data_xml_js_1 = __importDefault(require(\"./generated/decode-data-xml.js\"));\nexports.xmlDecodeTree = decode_data_xml_js_1.default;\nvar decode_codepoint_js_1 = __importDefault(require(\"./decode_codepoint.js\"));\nexports.decodeCodePoint = decode_codepoint_js_1.default;\nvar decode_codepoint_js_2 = require(\"./decode_codepoint.js\");\nObject.defineProperty(exports, \"replaceCodePoint\", { enumerable: true, get: function () { return decode_codepoint_js_2.replaceCodePoint; } });\nObject.defineProperty(exports, \"fromCodePoint\", { enumerable: true, get: function () { return decode_codepoint_js_2.fromCodePoint; } });\nvar CharCodes;\n(function (CharCodes) {\n    CharCodes[CharCodes[\"NUM\"] = 35] = \"NUM\";\n    CharCodes[CharCodes[\"SEMI\"] = 59] = \"SEMI\";\n    CharCodes[CharCodes[\"ZERO\"] = 48] = \"ZERO\";\n    CharCodes[CharCodes[\"NINE\"] = 57] = \"NINE\";\n    CharCodes[CharCodes[\"LOWER_A\"] = 97] = \"LOWER_A\";\n    CharCodes[CharCodes[\"LOWER_F\"] = 102] = \"LOWER_F\";\n    CharCodes[CharCodes[\"LOWER_X\"] = 120] = \"LOWER_X\";\n    /** Bit that needs to be set to convert an upper case ASCII character to lower case */\n    CharCodes[CharCodes[\"To_LOWER_BIT\"] = 32] = \"To_LOWER_BIT\";\n})(CharCodes || (CharCodes = {}));\nvar BinTrieFlags;\n(function (BinTrieFlags) {\n    BinTrieFlags[BinTrieFlags[\"VALUE_LENGTH\"] = 49152] = \"VALUE_LENGTH\";\n    BinTrieFlags[BinTrieFlags[\"BRANCH_LENGTH\"] = 16256] = \"BRANCH_LENGTH\";\n    BinTrieFlags[BinTrieFlags[\"JUMP_TABLE\"] = 127] = \"JUMP_TABLE\";\n})(BinTrieFlags = exports.BinTrieFlags || (exports.BinTrieFlags = {}));\nfunction getDecoder(decodeTree) {\n    return function decodeHTMLBinary(str, strict) {\n        var ret = \"\";\n        var lastIdx = 0;\n        var strIdx = 0;\n        while ((strIdx = str.indexOf(\"&\", strIdx)) >= 0) {\n            ret += str.slice(lastIdx, strIdx);\n            lastIdx = strIdx;\n            // Skip the \"&\"\n            strIdx += 1;\n            // If we have a numeric entity, handle this separately.\n            if (str.charCodeAt(strIdx) === CharCodes.NUM) {\n                // Skip the leading \"&#\". For hex entities, also skip the leading \"x\".\n                var start = strIdx + 1;\n                var base = 10;\n                var cp = str.charCodeAt(start);\n                if ((cp | CharCodes.To_LOWER_BIT) === CharCodes.LOWER_X) {\n                    base = 16;\n                    strIdx += 1;\n                    start += 1;\n                }\n                do\n                    cp = str.charCodeAt(++strIdx);\n                while ((cp >= CharCodes.ZERO && cp <= CharCodes.NINE) ||\n                    (base === 16 &&\n                        (cp | CharCodes.To_LOWER_BIT) >= CharCodes.LOWER_A &&\n                        (cp | CharCodes.To_LOWER_BIT) <= CharCodes.LOWER_F));\n                if (start !== strIdx) {\n                    var entity = str.substring(start, strIdx);\n                    var parsed = parseInt(entity, base);\n                    if (str.charCodeAt(strIdx) === CharCodes.SEMI) {\n                        strIdx += 1;\n                    }\n                    else if (strict) {\n                        continue;\n                    }\n                    ret += (0, decode_codepoint_js_1.default)(parsed);\n                    lastIdx = strIdx;\n                }\n                continue;\n            }\n            var resultIdx = 0;\n            var excess = 1;\n            var treeIdx = 0;\n            var current = decodeTree[treeIdx];\n            for (; strIdx < str.length; strIdx++, excess++) {\n                treeIdx = determineBranch(decodeTree, current, treeIdx + 1, str.charCodeAt(strIdx));\n                if (treeIdx < 0)\n                    break;\n                current = decodeTree[treeIdx];\n                var masked = current & BinTrieFlags.VALUE_LENGTH;\n                // If the branch is a value, store it and continue\n                if (masked) {\n                    // If we have a legacy entity while parsing strictly, just skip the number of bytes\n                    if (!strict || str.charCodeAt(strIdx) === CharCodes.SEMI) {\n                        resultIdx = treeIdx;\n                        excess = 0;\n                    }\n                    // The mask is the number of bytes of the value, including the current byte.\n                    var valueLength = (masked >> 14) - 1;\n                    if (valueLength === 0)\n                        break;\n                    treeIdx += valueLength;\n                }\n            }\n            if (resultIdx !== 0) {\n                var valueLength = (decodeTree[resultIdx] & BinTrieFlags.VALUE_LENGTH) >> 14;\n                ret +=\n                    valueLength === 1\n                        ? String.fromCharCode(decodeTree[resultIdx] & ~BinTrieFlags.VALUE_LENGTH)\n                        : valueLength === 2\n                            ? String.fromCharCode(decodeTree[resultIdx + 1])\n                            : String.fromCharCode(decodeTree[resultIdx + 1], decodeTree[resultIdx + 2]);\n                lastIdx = strIdx - excess + 1;\n            }\n        }\n        return ret + str.slice(lastIdx);\n    };\n}\nfunction determineBranch(decodeTree, current, nodeIdx, char) {\n    var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;\n    var jumpOffset = current & BinTrieFlags.JUMP_TABLE;\n    // Case 1: Single branch encoded in jump offset\n    if (branchCount === 0) {\n        return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;\n    }\n    // Case 2: Multiple branches encoded in jump table\n    if (jumpOffset) {\n        var value = char - jumpOffset;\n        return value < 0 || value >= branchCount\n            ? -1\n            : decodeTree[nodeIdx + value] - 1;\n    }\n    // Case 3: Multiple branches encoded in dictionary\n    // Binary search for the character.\n    var lo = nodeIdx;\n    var hi = lo + branchCount - 1;\n    while (lo <= hi) {\n        var mid = (lo + hi) >>> 1;\n        var midVal = decodeTree[mid];\n        if (midVal < char) {\n            lo = mid + 1;\n        }\n        else if (midVal > char) {\n            hi = mid - 1;\n        }\n        else {\n            return decodeTree[mid + branchCount];\n        }\n    }\n    return -1;\n}\nexports.determineBranch = determineBranch;\nvar htmlDecoder = getDecoder(decode_data_html_js_1.default);\nvar xmlDecoder = getDecoder(decode_data_xml_js_1.default);\n/**\n * Decodes an HTML string, allowing for entities not terminated by a semi-colon.\n *\n * @param str The string to decode.\n * @returns The decoded string.\n */\nfunction decodeHTML(str) {\n    return htmlDecoder(str, false);\n}\nexports.decodeHTML = decodeHTML;\n/**\n * Decodes an HTML string, requiring all entities to be terminated by a semi-colon.\n *\n * @param str The string to decode.\n * @returns The decoded string.\n */\nfunction decodeHTMLStrict(str) {\n    return htmlDecoder(str, true);\n}\nexports.decodeHTMLStrict = decodeHTMLStrict;\n/**\n * Decodes an XML string, requiring all entities to be terminated by a semi-colon.\n *\n * @param str The string to decode.\n * @returns The decoded string.\n */\nfunction decodeXML(str) {\n    return xmlDecoder(str, true);\n}\nexports.decodeXML = decodeXML;\n//# sourceMappingURL=decode.js.map"]},"metadata":{},"sourceType":"script"}