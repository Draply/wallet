{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.boolCases = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"codec:wrap:bool\");\n\nconst dispatch_1 = require(\"./dispatch\");\n\nconst errors_1 = require(\"./errors\");\n\nconst Utils = __importStar(require(\"./utils\"));\n\nconst Messages = __importStar(require(\"./messages\"));\n\nconst boolCasesBasic = [boolFromBoolean, boolFromString, boolFromBoxedPrimitive, boolFromCodecBoolValue, boolFromCodecBoolError, boolFromCodecUdvtValue, boolFromCodecUdvtError, boolFromOther //must go last!\n];\nexports.boolCases = [boolFromTypeValueInput, ...boolCasesBasic];\n\nfunction* boolFromBoolean(dataType, input, wrapOptions) {\n  if (typeof input !== \"boolean\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a boolean\");\n  }\n\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asBoolean: input\n    }\n  };\n}\n\nfunction* boolFromString(dataType, input, wrapOptions) {\n  if (typeof input !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n  }\n\n  const lowerCasedInput = input.toLowerCase();\n\n  if (wrapOptions.strictBooleans && ![\"true\", \"false\", \"1\", \"0\"].includes(lowerCasedInput)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, \"Input was not 'true', 'false', '1', or '0'\");\n  } //strings are true unless they're falsy or the case-insensitive strings \"false\" or \"0\"\n\n\n  const asBoolean = Boolean(input) && ![\"false\", \"0\"].includes(lowerCasedInput);\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asBoolean\n    }\n  };\n}\n\nfunction* boolFromBoxedPrimitive(dataType, input, wrapOptions) {\n  if (!Utils.isBoxedPrimitive(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a boxed primitive\");\n  } //unbox and try again\n\n\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, input.valueOf(), wrapOptions, exports.boolCases);\n}\n\nfunction* boolFromCodecBoolValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n\n  if (input.type.typeClass !== \"bool\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, //only specificity 1 due to BoolError case\n    Messages.errorResultMessage);\n  }\n\n  const asBoolean = input.value.asBoolean;\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asBoolean\n    }\n  };\n}\n\nfunction* boolFromCodecBoolError(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n\n  if (input.type.typeClass !== \"bool\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n\n  if (input.kind !== \"error\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was a value rather than an error\");\n  } //these two error types will be regarded as true\n\n\n  const allowedErrors = [\"BoolOutOfRangeError\", \"BoolPaddingError\"];\n\n  if (!allowedErrors.includes(input.error.kind)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asBoolean: true\n    }\n  };\n}\n\nfunction* boolFromTypeValueInput(dataType, input, wrapOptions) {\n  if (!Utils.isTypeValueInput(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n  }\n\n  if (input.type !== \"bool\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n  } //extract value & try again, disallowing type/value input\n\n\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), {\n    loose: true\n  }), boolCasesBasic);\n}\n\nfunction* boolFromCodecUdvtValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n\n  if (input.type.typeClass !== \"userDefinedValueType\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.wrappedTypeMessage(input.type));\n  }\n\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n\n  return yield* boolFromCodecBoolValue(dataType, input.value, wrapOptions);\n}\n\nfunction* boolFromCodecUdvtError(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n\n  if (input.type.typeClass !== \"userDefinedValueType\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.wrappedTypeMessage(input.type));\n  }\n\n  if (input.kind !== \"error\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was a value rather than an error\");\n  } //wrapped errors will have to be unwrapped, others can be rejected\n\n\n  if (input.error.kind !== \"WrappedError\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n\n  return yield* boolFromCodecBoolError(dataType, input.error.error, wrapOptions);\n}\n\nfunction* boolFromOther(dataType, input, wrapOptions) {\n  //fallback case: just go by truthiness/falsiness\n  //(this case has to be last because there are various other\n  //cases we do not want to go by truthiness/falsiness!)\n  if (Utils.isWrappedResult(input)) {\n    //...except for these, which may error\n    //(note that we do this even when loose is on!)\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was a wrapped result\");\n  }\n\n  if (Utils.isTypeValueInput(input)) {\n    //...and these, which also may error\n    //(note that we do this even when loose is on!)\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was a type/value pair\");\n  } //...and also we don't do this case if strictBooleans is turned on\n\n\n  if (wrapOptions.strictBooleans) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, \"Input was neither a boolean nor a boolean string\");\n  }\n\n  const asBoolean = Boolean(input);\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asBoolean\n    }\n  };\n}","map":{"version":3,"sources":["../../../lib/wrap/bool.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.boolCases = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:wrap:bool\");\nconst dispatch_1 = require(\"./dispatch\");\nconst errors_1 = require(\"./errors\");\nconst Utils = __importStar(require(\"./utils\"));\nconst Messages = __importStar(require(\"./messages\"));\nconst boolCasesBasic = [\n    boolFromBoolean,\n    boolFromString,\n    boolFromBoxedPrimitive,\n    boolFromCodecBoolValue,\n    boolFromCodecBoolError,\n    boolFromCodecUdvtValue,\n    boolFromCodecUdvtError,\n    boolFromOther //must go last!\n];\nexports.boolCases = [boolFromTypeValueInput, ...boolCasesBasic];\nfunction* boolFromBoolean(dataType, input, wrapOptions) {\n    if (typeof input !== \"boolean\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a boolean\");\n    }\n    return {\n        type: dataType,\n        kind: \"value\",\n        value: {\n            asBoolean: input\n        }\n    };\n}\nfunction* boolFromString(dataType, input, wrapOptions) {\n    if (typeof input !== \"string\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n    }\n    const lowerCasedInput = input.toLowerCase();\n    if (wrapOptions.strictBooleans &&\n        ![\"true\", \"false\", \"1\", \"0\"].includes(lowerCasedInput)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, \"Input was not 'true', 'false', '1', or '0'\");\n    }\n    //strings are true unless they're falsy or the case-insensitive strings \"false\" or \"0\"\n    const asBoolean = Boolean(input) && ![\"false\", \"0\"].includes(lowerCasedInput);\n    return {\n        type: dataType,\n        kind: \"value\",\n        value: {\n            asBoolean\n        }\n    };\n}\nfunction* boolFromBoxedPrimitive(dataType, input, wrapOptions) {\n    if (!Utils.isBoxedPrimitive(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a boxed primitive\");\n    }\n    //unbox and try again\n    return yield* (0, dispatch_1.wrapWithCases)(dataType, input.valueOf(), wrapOptions, exports.boolCases);\n}\nfunction* boolFromCodecBoolValue(dataType, input, wrapOptions) {\n    if (!Utils.isWrappedResult(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n    }\n    if (input.type.typeClass !== \"bool\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n    }\n    if (input.kind !== \"value\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, //only specificity 1 due to BoolError case\n        Messages.errorResultMessage);\n    }\n    const asBoolean = input.value.asBoolean;\n    return {\n        type: dataType,\n        kind: \"value\",\n        value: {\n            asBoolean\n        }\n    };\n}\nfunction* boolFromCodecBoolError(dataType, input, wrapOptions) {\n    if (!Utils.isWrappedResult(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n    }\n    if (input.type.typeClass !== \"bool\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n    }\n    if (input.kind !== \"error\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was a value rather than an error\");\n    }\n    //these two error types will be regarded as true\n    const allowedErrors = [\"BoolOutOfRangeError\", \"BoolPaddingError\"];\n    if (!allowedErrors.includes(input.error.kind)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n    }\n    return {\n        type: dataType,\n        kind: \"value\",\n        value: {\n            asBoolean: true\n        }\n    };\n}\nfunction* boolFromTypeValueInput(dataType, input, wrapOptions) {\n    if (!Utils.isTypeValueInput(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n    }\n    if (input.type !== \"bool\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n    }\n    //extract value & try again, disallowing type/value input\n    return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), { loose: true }), boolCasesBasic);\n}\nfunction* boolFromCodecUdvtValue(dataType, input, wrapOptions) {\n    if (!Utils.isWrappedResult(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n    }\n    if (input.type.typeClass !== \"userDefinedValueType\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.wrappedTypeMessage(input.type));\n    }\n    if (input.kind !== \"value\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n    }\n    return yield* boolFromCodecBoolValue(dataType, input.value, wrapOptions);\n}\nfunction* boolFromCodecUdvtError(dataType, input, wrapOptions) {\n    if (!Utils.isWrappedResult(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n    }\n    if (input.type.typeClass !== \"userDefinedValueType\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.wrappedTypeMessage(input.type));\n    }\n    if (input.kind !== \"error\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was a value rather than an error\");\n    }\n    //wrapped errors will have to be unwrapped, others can be rejected\n    if (input.error.kind !== \"WrappedError\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n    }\n    return yield* boolFromCodecBoolError(dataType, input.error.error, wrapOptions);\n}\nfunction* boolFromOther(dataType, input, wrapOptions) {\n    //fallback case: just go by truthiness/falsiness\n    //(this case has to be last because there are various other\n    //cases we do not want to go by truthiness/falsiness!)\n    if (Utils.isWrappedResult(input)) {\n        //...except for these, which may error\n        //(note that we do this even when loose is on!)\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was a wrapped result\");\n    }\n    if (Utils.isTypeValueInput(input)) {\n        //...and these, which also may error\n        //(note that we do this even when loose is on!)\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was a type/value pair\");\n    }\n    //...and also we don't do this case if strictBooleans is turned on\n    if (wrapOptions.strictBooleans) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, \"Input was neither a boolean nor a boolean string\");\n    }\n    const asBoolean = Boolean(input);\n    return {\n        type: dataType,\n        kind: \"value\",\n        value: {\n            asBoolean\n        }\n    };\n}\n//# sourceMappingURL=bool.js.map"]},"metadata":{},"sourceType":"script"}