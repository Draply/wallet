{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.integerCases = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"codec:wrap:integer\");\n\nconst Format = __importStar(require(\"../format\"));\n\nconst dispatch_1 = require(\"./dispatch\");\n\nconst errors_1 = require(\"./errors\");\n\nconst Conversion = __importStar(require(\"../conversion\"));\n\nconst Utils = __importStar(require(\"./utils\"));\n\nconst Messages = __importStar(require(\"./messages\"));\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nconst big_js_1 = __importDefault(require(\"big.js\"));\n\nconst bytes_1 = require(\"./bytes\"); //NOTE: all cases called \"integerFrom...\" also work for enums.\n//The cases labeled \"enumFrom...\" work only for enums.\n//there are no cases that work only for integers and not enums,\n//because we always want input for integers to also be valid for enums.\n\n\nconst integerFromStringCases = [integerFromIntegerString, enumFromNameString, integerFromScientificOrUnits, integerFromNegatedBaseString, integerFromStringFailureCase]; //note: doesn't include UDVT case,\n//or error case\n\nconst integerFromWrappedValueCases = [integerFromCodecIntegerValue, integerFromCodecEnumValue, integerFromCodecDecimalValue];\nconst integerCasesBasic = [...integerFromStringCases, integerFromNumber, integerFromBoxedNumber, integerFromBoxedString, integerFromBigint, integerFromBN, integerFromBig, integerFromUint8ArrayLike, ...integerFromWrappedValueCases, integerFromCodecEnumError, integerFromCodecUdvtValue, integerFromOther //must go last!\n];\nexports.integerCases = [integerFromIntegerTypeValueInput, enumFromEnumTypeValueInput, ...integerCasesBasic];\n\nfunction* integerFromIntegerString(dataType, input, wrapOptions) {\n  if (typeof input !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n  }\n\n  if (input.trim() === \"\") {\n    //bigint accepts this but we shouldn't\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, dataType.typeClass === \"enum\" ? Messages.badEnumMessage : Messages.nonNumericMessage);\n  }\n\n  const stripped = Utils.removeUnderscoresNumeric(input);\n  let asBN;\n\n  try {\n    //we'll use BigInt to parse integer strings, as it's pretty good at it.\n    //Note that it accepts hex/octal/binary with prefixes 0x, 0o, 0b.\n    const asBigInt = BigInt(stripped);\n    asBN = Conversion.toBN(asBigInt);\n  } catch (_a) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input string was not an integer string\");\n  }\n\n  return validateAndWrap(dataType, asBN, wrapOptions, input);\n} //this case handles both scientific notation, and numbers with units\n\n\nfunction* integerFromScientificOrUnits(dataType, input, wrapOptions) {\n  if (typeof input !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n  }\n\n  if (input.trim() === \"\") {\n    //the code below accepts this but we shouldn't\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, //only specificity 1 since it's already specificity 5 above\n    dataType.typeClass === \"enum\" ? Messages.badEnumMessage : Messages.nonNumericMessage);\n  }\n\n  const stripped = Utils.removeUnderscoresNoHex(input);\n  let [_, quantityString, unit] = stripped.match(/^(.*?)(|wei|gwei|shannon|finney|szabo|ether)\\s*$/i); //units will be case insensitive; note this always matches\n\n  quantityString = quantityString.trim(); //Big rejects whitespace, let's allow it\n\n  const unitPlacesTable = {\n    //we could accept all of web3's units here, but, that's a little much;\n    //we'll just accept the most common ones\n    \"\": 0,\n    wei: 0,\n    gwei: 9,\n    shannon: 9,\n    szabo: 12,\n    finney: 15,\n    ether: 18\n  };\n  let quantity;\n\n  try {\n    quantity = quantityString.match(/^\\s*$/) ? new big_js_1.default(1) //allow just \"ether\" e.g.\n    : new big_js_1.default(quantityString);\n  } catch (_a) {\n    quantity = null;\n  }\n\n  if (quantity === null) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string using scientific notation or units\");\n  }\n\n  const places = unitPlacesTable[unit.toLowerCase()];\n  const asBig = Conversion.shiftBigUp(quantity, places);\n\n  if (Conversion.countDecimalPlaces(asBig) !== 0) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, unit !== \"\" ? \"Input numeric value was not an integral number of wei\" : Messages.nonIntegerMessage);\n  }\n\n  const asBN = Conversion.toBN(asBig);\n  return validateAndWrap(dataType, asBN, wrapOptions, input);\n}\n\nfunction* integerFromNegatedBaseString(dataType, input, wrapOptions) {\n  if (typeof input !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n  }\n\n  if (!input.match(/^\\s*-/)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a negated numeric string\");\n  }\n\n  const stripped = Utils.removeUnderscoresNumeric(input);\n  let positiveAsBN;\n  const [_, positiveString] = stripped.match(/^\\s*-(.*)$/);\n\n  try {\n    const positive = BigInt(positiveString);\n    positiveAsBN = Conversion.toBN(positive);\n  } catch (_a) {\n    positiveAsBN = null;\n  }\n\n  if (positiveAsBN === null || positiveString === \"\" || positiveString.match(/^(-|\\s)/)) {\n    //no double negation, no bare \"-\", and no space after the minus!\n    //(we do this as a string check, rather than checking if\n    //positiveAsBN is >=0, in order to prevent entering e.g. \"--\" or \"- 2\")\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.nonNumericMessage);\n  }\n\n  const asBN = positiveAsBN.neg();\n  return validateAndWrap(dataType, asBN, wrapOptions, input);\n}\n\nfunction* enumFromNameString(dataType, input, wrapOptions) {\n  if (typeof input !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n  }\n\n  if (dataType.typeClass !== \"enum\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.nonNumericMessage);\n  }\n\n  const fullType = Format.Types.fullType(dataType, wrapOptions.userDefinedTypes);\n  const options = fullType.options;\n  const components = input.split(\".\");\n  const finalComponent = components[components.length - 1];\n  debug(\"components: %O\", components);\n  debug(\"dataType: %O\", dataType);\n  debug(\"options: %O\", options); //the enum can be qualified.  if it's qualified, does the type match?\n\n  let matchingType;\n\n  switch (components.length) {\n    case 1:\n      //not qualified, automatically matches\n      matchingType = true;\n      break;\n\n    case 2:\n      //qualified by type name, does it match?\n      matchingType = components[0] === dataType.typeName;\n      break;\n\n    case 3:\n      //qualified by type name and contract name, does it match?\n      matchingType = dataType.kind === \"local\" && components[0] === dataType.definingContractName && components[1] === dataType.typeName;\n      break;\n\n    default:\n      //no valid reason to have 3 or more periods\n      //(and split cannot return an empty array)\n      matchingType = false;\n  }\n\n  debug(\"matchingType: %O\", matchingType);\n  const numeric = matchingType ? options.indexOf(finalComponent) : -1; //if type doesn't match, just indicate error\n\n  debug(\"numeric: %d\", numeric);\n\n  if (numeric === -1) {\n    //-1 comes from either our setting it manually above to indicate error,\n    //or from a failed indexOf call\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.badEnumMessage);\n  }\n\n  const asBN = new bn_js_1.default(numeric); //whew!\n  //now: unlike in every other case, we can skip validation!\n  //so let's just wrap and return!\n\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: {\n      numericAsBN: asBN,\n      name: finalComponent //we know it matches!\n\n    }\n  };\n}\n\nfunction* integerFromStringFailureCase(dataType, input, wrapOptions) {\n  if (typeof input !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n  }\n\n  throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, dataType.typeClass === \"enum\" ? Messages.badEnumMessage : Messages.nonNumericMessage);\n}\n\nfunction* integerFromBN(dataType, input, wrapOptions) {\n  if (!bn_js_1.default.isBN(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a BN\");\n  }\n\n  const asBN = input.clone();\n  return validateAndWrap(dataType, asBN, wrapOptions, input);\n}\n\nfunction* integerFromBigint(dataType, input, wrapOptions) {\n  if (typeof input !== \"bigint\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a bigint\");\n  }\n\n  const asBN = Conversion.toBN(input);\n  return validateAndWrap(dataType, asBN, wrapOptions, input);\n}\n\nfunction* integerFromNumber(dataType, input, wrapOptions) {\n  if (typeof input !== \"number\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a number\");\n  }\n\n  if (!Number.isInteger(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.nonIntegerMessage);\n  }\n\n  if (!Number.isSafeInteger(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.nonSafeMessage);\n  }\n\n  const asBN = new bn_js_1.default(input);\n  return validateAndWrap(dataType, asBN, wrapOptions, input);\n}\n\nfunction* integerFromBig(dataType, input, wrapOptions) {\n  if (!Conversion.isBig(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a Big\");\n  }\n\n  if (Conversion.countDecimalPlaces(input) !== 0) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.nonIntegerMessage);\n  }\n\n  const asBN = Conversion.toBN(input);\n  return validateAndWrap(dataType, asBN, wrapOptions, input);\n}\n\nfunction* integerFromUint8ArrayLike(dataType, input, wrapOptions) {\n  if (!Utils.isUint8ArrayLike(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a Uint8Array-like\");\n  } //the next series of checks is delegated to a helper fn\n\n\n  (0, bytes_1.validateUint8ArrayLike)(input, dataType, wrapOptions.name); //(this fn just throws an appropriate error if something's bad)\n\n  const asBN = Conversion.toBN(new Uint8Array(input)); //I am surprised TS accepts this!\n\n  return validateAndWrap(dataType, asBN, wrapOptions, input);\n}\n\nfunction* integerFromBoxedNumber(dataType, input, wrapOptions) {\n  if (!Utils.isBoxedNumber(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a boxed number\");\n  } //unbox and try again\n\n\n  return yield* integerFromNumber(dataType, input.valueOf(), wrapOptions);\n}\n\nfunction* integerFromBoxedString(dataType, input, wrapOptions) {\n  if (!Utils.isBoxedString(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a boxed string\");\n  } //unbox and try again\n\n\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, input.valueOf(), wrapOptions, integerFromStringCases);\n}\n\nfunction* integerFromCodecIntegerValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n\n  if (input.type.typeClass !== \"int\" && input.type.typeClass !== \"uint\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n\n  if (!wrapOptions.loose && (input.type.typeClass !== dataType.typeClass || input.type.bits !== dataType.bits)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n\n  const asBN = input.value.asBN.clone();\n  return validateAndWrap(dataType, asBN, wrapOptions, input);\n}\n\nfunction* integerFromCodecDecimalValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n\n  if (input.type.typeClass !== \"fixed\" && input.type.typeClass !== \"ufixed\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n\n  if (!wrapOptions.loose) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n\n  const asBN = Conversion.toBN(input.value.asBig);\n  return validateAndWrap(dataType, asBN, wrapOptions, input);\n}\n\nfunction* integerFromCodecEnumValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n\n  if (input.type.typeClass !== \"enum\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, //only specificity 1 due to EnumError case\n    Messages.errorResultMessage);\n  }\n\n  if (!wrapOptions.loose && (dataType.typeClass !== \"enum\" || input.type.id !== dataType.id)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n\n  const asBN = input.value.numericAsBN.clone();\n  return validateAndWrap(dataType, asBN, wrapOptions, input);\n}\n\nfunction* integerFromCodecEnumError(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n\n  if (input.type.typeClass !== \"enum\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n\n  if (input.kind !== \"error\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Wrapped result was a value rather than an error\");\n  }\n\n  if (!wrapOptions.loose && (dataType.typeClass !== \"enum\" || input.type.id !== dataType.id)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n\n  const coercedInput = input; //only one specific kind of error will be allowed\n\n  if (coercedInput.error.kind !== \"EnumOutOfRangeError\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n\n  const asBN = coercedInput.error.rawAsBN.clone();\n  return validateAndWrap(dataType, asBN, wrapOptions, input);\n}\n\nfunction* integerFromCodecUdvtValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n\n  if (input.type.typeClass !== \"userDefinedValueType\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.wrappedTypeMessage(input.type));\n  }\n\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, wrapOptions, integerFromWrappedValueCases);\n}\n\nfunction* integerFromIntegerTypeValueInput(dataType, input, wrapOptions) {\n  if (!Utils.isTypeValueInput(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n  }\n\n  if (!input.type.match(/^u?int\\d*$/)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, dataType.typeClass === \"enum\" ? 1 : 5, //use specificity 5 when getting an integer (which have no alternative),\n    //but specificity 1 when getting an enum (which have enum type/value input also)\n    Messages.specifiedTypeMessage(input.type));\n  }\n\n  const [_, typeClass, bitsAsString] = input.type.match(/^(u?int)(\\d*)$/);\n  const bits = bitsAsString ? Number(bitsAsString) : 256; //defaults to 256\n  //(not using the WORD_SIZE constant due to fixed types bringing its applicability\n  //here into question)\n\n  const requiredTypeClass = dataType.typeClass !== \"enum\" ? dataType.typeClass : \"uint\"; //allow underlying uint type to work for enums\n  //(we handle \"enum\" given as type in a separate case below)\n\n  const requiredBits = dataType.typeClass !== \"enum\" ? dataType.bits : 8 * Math.ceil(Math.log2(Format.Types.fullType(dataType, wrapOptions.userDefinedTypes).options.length) / 8); //compute required bits for enum type (sorry)\n\n  if (requiredTypeClass !== typeClass || requiredBits !== bits) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n  } //extract value & try again, with loose option turned on\n\n\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), {\n    loose: true\n  }), integerCasesBasic);\n}\n\nfunction* enumFromEnumTypeValueInput(dataType, input, wrapOptions) {\n  if (!Utils.isTypeValueInput(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n  }\n\n  if (input.type !== \"enum\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, dataType.typeClass === \"enum\" ? 5 : 1, //use specificity 5 when getting an enum (which will have also failed integer type/value input),\n    //but specificity 1 when getting an integer (to which this doesn't really apply)\n    Messages.specifiedTypeMessage(input.type));\n  }\n\n  if (dataType.typeClass !== \"enum\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n  } //extract value & try again, with loose option turned on\n  //(we'll also coerce the type on this one since we know it's\n  //going to be an enum value :P )\n\n\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), {\n    loose: true\n  }), integerCasesBasic);\n}\n\nfunction* integerFromOther(dataType, input, wrapOptions) {\n  const request = {\n    kind: \"integer\",\n    input\n  };\n  const response = yield request;\n\n  if (response.kind !== \"integer\") {\n    throw new errors_1.BadResponseTypeError(request, response);\n  }\n\n  if (response.value === null) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, response.partiallyRecognized ? 5 : 3, response.reason || Messages.unrecognizedNumberMessage(dataType));\n  }\n\n  const asBN = Conversion.toBN(response.value);\n  return validateAndWrap(dataType, asBN, wrapOptions, input);\n}\n\nfunction validateAndWrap(dataType, asBN, wrapOptions, input //just for erroring\n) {\n  switch (dataType.typeClass) {\n    case \"uint\":\n      if (asBN.isNeg() || asBN.bitLength() > dataType.bits) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.outOfRangeMessage);\n      }\n\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: {\n          asBN\n        }\n      };\n\n    case \"int\":\n      if (!asBN.isNeg() && asBN.bitLength() >= dataType.bits || //>= since signed\n      asBN.isNeg() && asBN.neg().subn(1).bitLength() >= dataType.bits //bitLength doesn't work great for negatives so we do this instead\n      ) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.outOfRangeMessage);\n      }\n\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: {\n          asBN\n        }\n      };\n\n    case \"enum\":\n      const fullType = Format.Types.fullType(dataType, wrapOptions.userDefinedTypes);\n\n      if (asBN.isNeg() || asBN.gten(fullType.options.length)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.outOfRangeEnumMessage);\n      }\n\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: {\n          numericAsBN: asBN,\n          name: fullType.options[asBN.toNumber()]\n        }\n      };\n  }\n}","map":{"version":3,"sources":["../../../lib/wrap/integer.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAA,OAAA,GAAA,eAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AACA,MAAM,KAAK,GAAG,CAAA,GAAA,OAAA,CAAA,OAAA,EAAY,oBAAZ,CAAd;;AAEA,MAAA,MAAA,GAAA,YAAA,CAAA,OAAA,CAAA,WAAA,CAAA,CAAA;;AACA,MAAA,UAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AACA,MAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AAUA,MAAA,UAAA,GAAA,YAAA,CAAA,OAAA,CAAA,eAAA,CAAA,CAAA;;AACA,MAAA,KAAA,GAAA,YAAA,CAAA,OAAA,CAAA,SAAA,CAAA,CAAA;;AACA,MAAA,QAAA,GAAA,YAAA,CAAA,OAAA,CAAA,YAAA,CAAA,CAAA;;AACA,MAAA,OAAA,GAAA,eAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AACA,MAAA,QAAA,GAAA,eAAA,CAAA,OAAA,CAAA,QAAA,CAAA,CAAA;;AAEA,MAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA,C,CAEA;AACA;AACA;AACA;;;AAEA,MAAM,sBAAsB,GAItB,CACJ,wBADI,EAEJ,kBAFI,EAGJ,4BAHI,EAIJ,4BAJI,EAKJ,4BALI,CAJN,C,CAYA;AACA;;AACA,MAAM,4BAA4B,GAI5B,CACJ,4BADI,EAEJ,yBAFI,EAGJ,4BAHI,CAJN;AAUA,MAAM,iBAAiB,GAIjB,CACJ,GAAG,sBADC,EAEJ,iBAFI,EAGJ,sBAHI,EAIJ,sBAJI,EAKJ,iBALI,EAMJ,aANI,EAOJ,cAPI,EAQJ,yBARI,EASJ,GAAG,4BATC,EAUJ,yBAVI,EAWJ,yBAXI,EAYJ,gBAZI,CAYa;AAZb,CAJN;AAmBa,OAAA,CAAA,YAAA,GAIP,CACJ,gCADI,EAEJ,0BAFI,EAGJ,GAAG,iBAHC,CAJO;;AAUb,UAAU,wBAAV,CACE,QADF,EAEE,KAFF,EAGE,WAHF,EAG0B;AAExB,MAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAC7B,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,wBALI,CAAN;AAOD;;AACD,MAAI,KAAK,CAAC,IAAN,OAAiB,EAArB,EAAyB;AACvB;AACA,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,QAAQ,CAAC,SAAT,KAAuB,MAAvB,GACI,QAAQ,CAAC,cADb,GAEI,QAAQ,CAAC,iBAPT,CAAN;AASD;;AACD,QAAM,QAAQ,GAAG,KAAK,CAAC,wBAAN,CAA+B,KAA/B,CAAjB;AACA,MAAI,IAAJ;;AACA,MAAI;AACF;AACA;AACA,UAAM,QAAQ,GAAG,MAAM,CAAC,QAAD,CAAvB;AACA,IAAA,IAAI,GAAG,UAAU,CAAC,IAAX,CAAgB,QAAhB,CAAP;AACD,GALD,CAKE,OAAA,EAAA,EAAM;AACN,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,wCALI,CAAN;AAOD;;AACD,SAAO,eAAe,CAAC,QAAD,EAAW,IAAX,EAAiB,WAAjB,EAA8B,KAA9B,CAAtB;AACD,C,CAED;;;AACA,UAAU,4BAAV,CACE,QADF,EAEE,KAFF,EAGE,WAHF,EAG0B;AAExB,MAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAC7B,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,wBALI,CAAN;AAOD;;AACD,MAAI,KAAK,CAAC,IAAN,OAAiB,EAArB,EAAyB;AACvB;AACA,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAID;AACH,IAAA,QAAQ,CAAC,SAAT,KAAuB,MAAvB,GACI,QAAQ,CAAC,cADb,GAEI,QAAQ,CAAC,iBAPT,CAAN;AASD;;AACD,QAAM,QAAQ,GAAG,KAAK,CAAC,sBAAN,CAA6B,KAA7B,CAAjB;AACA,MAAI,CAAC,CAAD,EAAI,cAAJ,EAAoB,IAApB,IAA4B,QAAQ,CAAC,KAAT,CAC9B,mDAD8B,CAAhC,CAxBwB,CA0BrB;;AACH,EAAA,cAAc,GAAG,cAAc,CAAC,IAAf,EAAjB,CA3BwB,CA2BgB;;AACxC,QAAM,eAAe,GAA+B;AAClD;AACA;AACA,QAAI,CAH8C;AAIlD,IAAA,GAAG,EAAE,CAJ6C;AAKlD,IAAA,IAAI,EAAE,CAL4C;AAMlD,IAAA,OAAO,EAAE,CANyC;AAOlD,IAAA,KAAK,EAAE,EAP2C;AAQlD,IAAA,MAAM,EAAE,EAR0C;AASlD,IAAA,KAAK,EAAE;AAT2C,GAApD;AAWA,MAAI,QAAJ;;AACA,MAAI;AACF,IAAA,QAAQ,GAAG,cAAc,CAAC,KAAf,CAAqB,OAArB,IACP,IAAI,QAAA,CAAA,OAAJ,CAAQ,CAAR,CADO,CACI;AADJ,MAEP,IAAI,QAAA,CAAA,OAAJ,CAAQ,cAAR,CAFJ;AAGD,GAJD,CAIE,OAAA,EAAA,EAAM;AACN,IAAA,QAAQ,GAAG,IAAX;AACD;;AACD,MAAI,QAAQ,KAAK,IAAjB,EAAuB;AACrB,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,2DALI,CAAN;AAOD;;AACD,QAAM,MAAM,GAAW,eAAe,CAAC,IAAI,CAAC,WAAL,EAAD,CAAtC;AACA,QAAM,KAAK,GAAG,UAAU,CAAC,UAAX,CAAsB,QAAtB,EAAgC,MAAhC,CAAd;;AACA,MAAI,UAAU,CAAC,kBAAX,CAA8B,KAA9B,MAAyC,CAA7C,EAAgD;AAC9C,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,IAAI,KAAK,EAAT,GACI,uDADJ,GAEI,QAAQ,CAAC,iBAPT,CAAN;AASD;;AACD,QAAM,IAAI,GAAG,UAAU,CAAC,IAAX,CAAgB,KAAhB,CAAb;AACA,SAAO,eAAe,CAAC,QAAD,EAAW,IAAX,EAAiB,WAAjB,EAA8B,KAA9B,CAAtB;AACD;;AAED,UAAU,4BAAV,CACE,QADF,EAEE,KAFF,EAGE,WAHF,EAG0B;AAExB,MAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAC7B,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,wBALI,CAAN;AAOD;;AACD,MAAI,CAAC,KAAK,CAAC,KAAN,CAAY,OAAZ,CAAL,EAA2B;AACzB,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,wCALI,CAAN;AAOD;;AACD,QAAM,QAAQ,GAAG,KAAK,CAAC,wBAAN,CAA+B,KAA/B,CAAjB;AACA,MAAI,YAAJ;AACA,QAAM,CAAC,CAAD,EAAI,cAAJ,IAAsB,QAAQ,CAAC,KAAT,CAAe,YAAf,CAA5B;;AACA,MAAI;AACF,UAAM,QAAQ,GAAG,MAAM,CAAC,cAAD,CAAvB;AACA,IAAA,YAAY,GAAG,UAAU,CAAC,IAAX,CAAgB,QAAhB,CAAf;AACD,GAHD,CAGE,OAAA,EAAA,EAAM;AACN,IAAA,YAAY,GAAG,IAAf;AACD;;AACD,MACE,YAAY,KAAK,IAAjB,IACA,cAAc,KAAK,EADnB,IAEA,cAAc,CAAC,KAAf,CAAqB,SAArB,CAHF,EAIE;AACA;AACA;AACA;AACA,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,QAAQ,CAAC,iBALL,CAAN;AAOD;;AACD,QAAM,IAAI,GAAG,YAAY,CAAC,GAAb,EAAb;AACA,SAAO,eAAe,CAAC,QAAD,EAAW,IAAX,EAAiB,WAAjB,EAA8B,KAA9B,CAAtB;AACD;;AAED,UAAU,kBAAV,CACE,QADF,EAEE,KAFF,EAGE,WAHF,EAG0B;AAExB,MAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAC7B,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,wBALI,CAAN;AAOD;;AACD,MAAI,QAAQ,CAAC,SAAT,KAAuB,MAA3B,EAAmC;AACjC,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,QAAQ,CAAC,iBALL,CAAN;AAOD;;AACD,QAAM,QAAQ,GACZ,MAAM,CAAC,KAAP,CAAa,QAAb,CAAsB,QAAtB,EAAgC,WAAW,CAAC,gBAA5C,CADF;AAGA,QAAM,OAAO,GAAG,QAAQ,CAAC,OAAzB;AACA,QAAM,UAAU,GAAG,KAAK,CAAC,KAAN,CAAY,GAAZ,CAAnB;AACA,QAAM,cAAc,GAAG,UAAU,CAAC,UAAU,CAAC,MAAX,GAAoB,CAArB,CAAjC;AACA,EAAA,KAAK,CAAC,gBAAD,EAAmB,UAAnB,CAAL;AACA,EAAA,KAAK,CAAC,cAAD,EAAiB,QAAjB,CAAL;AACA,EAAA,KAAK,CAAC,aAAD,EAAgB,OAAhB,CAAL,CA5BwB,CA6BxB;;AACA,MAAI,YAAJ;;AACA,UAAQ,UAAU,CAAC,MAAnB;AACE,SAAK,CAAL;AACE;AACA,MAAA,YAAY,GAAG,IAAf;AACA;;AACF,SAAK,CAAL;AACE;AACA,MAAA,YAAY,GAAG,UAAU,CAAC,CAAD,CAAV,KAAkB,QAAQ,CAAC,QAA1C;AACA;;AACF,SAAK,CAAL;AACE;AACA,MAAA,YAAY,GACV,QAAQ,CAAC,IAAT,KAAkB,OAAlB,IACA,UAAU,CAAC,CAAD,CAAV,KAAkB,QAAQ,CAAC,oBAD3B,IAEA,UAAU,CAAC,CAAD,CAAV,KAAkB,QAAQ,CAAC,QAH7B;AAIA;;AACF;AACE;AACA;AACA,MAAA,YAAY,GAAG,KAAf;AAnBJ;;AAqBA,EAAA,KAAK,CAAC,kBAAD,EAAqB,YAArB,CAAL;AACA,QAAM,OAAO,GAAG,YAAY,GAAG,OAAO,CAAC,OAAR,CAAgB,cAAhB,CAAH,GAAqC,CAAC,CAAlE,CArDwB,CAqD6C;;AACrE,EAAA,KAAK,CAAC,aAAD,EAAgB,OAAhB,CAAL;;AACA,MAAI,OAAO,KAAK,CAAC,CAAjB,EAAoB;AAClB;AACA;AACA,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,QAAQ,CAAC,cALL,CAAN;AAOD;;AACD,QAAM,IAAI,GAAG,IAAI,OAAA,CAAA,OAAJ,CAAO,OAAP,CAAb,CAlEwB,CAkEM;AAC9B;AACA;;AACA,SAAO;AACL,IAAA,IAAI,EAAE,QADD;AAEL,IAAA,IAAI,EAAE,OAFD;AAGL,IAAA,KAAK,EAAE;AACL,MAAA,WAAW,EAAE,IADR;AAEL,MAAA,IAAI,EAAE,cAFD,CAEgB;;AAFhB;AAHF,GAAP;AAQD;;AAED,UAAU,4BAAV,CACE,QADF,EAEE,KAFF,EAGE,WAHF,EAG0B;AAExB,MAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAC7B,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,wBALI,CAAN;AAOD;;AACD,QAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,QAAQ,CAAC,SAAT,KAAuB,MAAvB,GACI,QAAQ,CAAC,cADb,GAEI,QAAQ,CAAC,iBAPT,CAAN;AASD;;AAED,UAAU,aAAV,CACE,QADF,EAEE,KAFF,EAGE,WAHF,EAG0B;AAExB,MAAI,CAAC,OAAA,CAAA,OAAA,CAAG,IAAH,CAAQ,KAAR,CAAL,EAAqB;AACnB,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,oBALI,CAAN;AAOD;;AACD,QAAM,IAAI,GAAG,KAAK,CAAC,KAAN,EAAb;AACA,SAAO,eAAe,CAAC,QAAD,EAAW,IAAX,EAAiB,WAAjB,EAA8B,KAA9B,CAAtB;AACD;;AAED,UAAU,iBAAV,CACE,QADF,EAEE,KAFF,EAGE,WAHF,EAG0B;AAExB,MAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAC7B,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,wBALI,CAAN;AAOD;;AACD,QAAM,IAAI,GAAG,UAAU,CAAC,IAAX,CAAgB,KAAhB,CAAb;AACA,SAAO,eAAe,CAAC,QAAD,EAAW,IAAX,EAAiB,WAAjB,EAA8B,KAA9B,CAAtB;AACD;;AAED,UAAU,iBAAV,CACE,QADF,EAEE,KAFF,EAGE,WAHF,EAG0B;AAExB,MAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAC7B,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,wBALI,CAAN;AAOD;;AACD,MAAI,CAAC,MAAM,CAAC,SAAP,CAAiB,KAAjB,CAAL,EAA8B;AAC5B,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,QAAQ,CAAC,iBALL,CAAN;AAOD;;AACD,MAAI,CAAC,MAAM,CAAC,aAAP,CAAqB,KAArB,CAAL,EAAkC;AAChC,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,QAAQ,CAAC,cALL,CAAN;AAOD;;AACD,QAAM,IAAI,GAAG,IAAI,OAAA,CAAA,OAAJ,CAAO,KAAP,CAAb;AACA,SAAO,eAAe,CAAC,QAAD,EAAW,IAAX,EAAiB,WAAjB,EAA8B,KAA9B,CAAtB;AACD;;AAED,UAAU,cAAV,CACE,QADF,EAEE,KAFF,EAGE,WAHF,EAG0B;AAExB,MAAI,CAAC,UAAU,CAAC,KAAX,CAAiB,KAAjB,CAAL,EAA8B;AAC5B,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,qBALI,CAAN;AAOD;;AACD,MAAI,UAAU,CAAC,kBAAX,CAA8B,KAA9B,MAAyC,CAA7C,EAAgD;AAC9C,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,QAAQ,CAAC,iBALL,CAAN;AAOD;;AACD,QAAM,IAAI,GAAG,UAAU,CAAC,IAAX,CAAgB,KAAhB,CAAb;AACA,SAAO,eAAe,CAAC,QAAD,EAAW,IAAX,EAAiB,WAAjB,EAA8B,KAA9B,CAAtB;AACD;;AAED,UAAU,yBAAV,CACE,QADF,EAEE,KAFF,EAGE,WAHF,EAG0B;AAExB,MAAI,CAAC,KAAK,CAAC,gBAAN,CAAuB,KAAvB,CAAL,EAAoC;AAClC,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,iCALI,CAAN;AAOD,GAVuB,CAWxB;;;AACA,GAAA,GAAA,OAAA,CAAA,sBAAA,EAAuB,KAAvB,EAA8B,QAA9B,EAAwC,WAAW,CAAC,IAApD,EAZwB,CAYmC;;AAC3D,QAAM,IAAI,GAAG,UAAU,CAAC,IAAX,CAAgB,IAAI,UAAJ,CAAe,KAAf,CAAhB,CAAb,CAbwB,CAa6B;;AACrD,SAAO,eAAe,CAAC,QAAD,EAAW,IAAX,EAAiB,WAAjB,EAA8B,KAA9B,CAAtB;AACD;;AAED,UAAU,sBAAV,CACE,QADF,EAEE,KAFF,EAGE,WAHF,EAG0B;AAExB,MAAI,CAAC,KAAK,CAAC,aAAN,CAAoB,KAApB,CAAL,EAAiC;AAC/B,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,8BALI,CAAN;AAOD,GAVuB,CAWxB;;;AACA,SAAO,OAAO,iBAAiB,CAAC,QAAD,EAAW,KAAK,CAAC,OAAN,EAAX,EAA4B,WAA5B,CAA/B;AACD;;AAED,UAAU,sBAAV,CACE,QADF,EAEE,KAFF,EAGE,WAHF,EAG0B;AAExB,MAAI,CAAC,KAAK,CAAC,aAAN,CAAoB,KAApB,CAAL,EAAiC;AAC/B,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,8BALI,CAAN;AAOD,GAVuB,CAWxB;;;AACA,SAAO,OAAO,CAAA,GAAA,UAAA,CAAA,aAAA,EACZ,QADY,EAEZ,KAAK,CAAC,OAAN,EAFY,EAGZ,WAHY,EAIZ,sBAJY,CAAd;AAMD;;AAED,UAAU,4BAAV,CACE,QADF,EAEE,KAFF,EAGE,WAHF,EAG0B;AAExB,MAAI,CAAC,KAAK,CAAC,eAAN,CAAsB,KAAtB,CAAL,EAAmC;AACjC,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,gCALI,CAAN;AAOD;;AACD,MAAI,KAAK,CAAC,IAAN,CAAW,SAAX,KAAyB,KAAzB,IAAkC,KAAK,CAAC,IAAN,CAAW,SAAX,KAAyB,MAA/D,EAAuE;AACrE,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,QAAQ,CAAC,kBAAT,CAA4B,KAAK,CAAC,IAAlC,CALI,CAAN;AAOD;;AACD,MAAI,KAAK,CAAC,IAAN,KAAe,OAAnB,EAA4B;AAC1B,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,QAAQ,CAAC,kBALL,CAAN;AAOD;;AACD,MACE,CAAC,WAAW,CAAC,KAAb,KACC,KAAK,CAAC,IAAN,CAAW,SAAX,KAAyB,QAAQ,CAAC,SAAlC,IACC,KAAK,CAAC,IAAN,CAAW,IAAX,KAAoB,QAAQ,CAAC,IAF/B,CADF,EAIE;AACA,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,QAAQ,CAAC,kBAAT,CAA4B,KAAK,CAAC,IAAlC,CALI,CAAN;AAOD;;AACD,QAAM,IAAI,GAAkB,KAAM,CAAC,KAAP,CAAa,IAAb,CAAkB,KAAlB,EAA5B;AACA,SAAO,eAAe,CAAC,QAAD,EAAW,IAAX,EAAiB,WAAjB,EAA8B,KAA9B,CAAtB;AACD;;AAED,UAAU,4BAAV,CACE,QADF,EAEE,KAFF,EAGE,WAHF,EAG0B;AAExB,MAAI,CAAC,KAAK,CAAC,eAAN,CAAsB,KAAtB,CAAL,EAAmC;AACjC,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,gCALI,CAAN;AAOD;;AACD,MAAI,KAAK,CAAC,IAAN,CAAW,SAAX,KAAyB,OAAzB,IAAoC,KAAK,CAAC,IAAN,CAAW,SAAX,KAAyB,QAAjE,EAA2E;AACzE,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,QAAQ,CAAC,kBAAT,CAA4B,KAAK,CAAC,IAAlC,CALI,CAAN;AAOD;;AACD,MAAI,KAAK,CAAC,IAAN,KAAe,OAAnB,EAA4B;AAC1B,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,QAAQ,CAAC,kBALL,CAAN;AAOD;;AACD,MAAI,CAAC,WAAW,CAAC,KAAjB,EAAwB;AACtB,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,QAAQ,CAAC,kBAAT,CAA4B,KAAK,CAAC,IAAlC,CALI,CAAN;AAOD;;AACD,QAAM,IAAI,GAAG,UAAU,CAAC,IAAX,CAA+B,KAAM,CAAC,KAAP,CAAa,KAA5C,CAAb;AACA,SAAO,eAAe,CAAC,QAAD,EAAW,IAAX,EAAiB,WAAjB,EAA8B,KAA9B,CAAtB;AACD;;AAED,UAAU,yBAAV,CACE,QADF,EAEE,KAFF,EAGE,WAHF,EAG0B;AAExB,MAAI,CAAC,KAAK,CAAC,eAAN,CAAsB,KAAtB,CAAL,EAAmC;AACjC,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,gCALI,CAAN;AAOD;;AACD,MAAI,KAAK,CAAC,IAAN,CAAW,SAAX,KAAyB,MAA7B,EAAqC;AACnC,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,QAAQ,CAAC,kBAAT,CAA4B,KAAK,CAAC,IAAlC,CALI,CAAN;AAOD;;AACD,MAAI,KAAK,CAAC,IAAN,KAAe,OAAnB,EAA4B;AAC1B,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAID;AACH,IAAA,QAAQ,CAAC,kBALL,CAAN;AAOD;;AACD,MACE,CAAC,WAAW,CAAC,KAAb,KACC,QAAQ,CAAC,SAAT,KAAuB,MAAvB,IAAiC,KAAK,CAAC,IAAN,CAAW,EAAX,KAAkB,QAAQ,CAAC,EAD7D,CADF,EAGE;AACA,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,QAAQ,CAAC,kBAAT,CAA4B,KAAK,CAAC,IAAlC,CALI,CAAN;AAOD;;AACD,QAAM,IAAI,GAA6B,KAAM,CAAC,KAAP,CAAa,WAAb,CAAyB,KAAzB,EAAvC;AACA,SAAO,eAAe,CAAC,QAAD,EAAW,IAAX,EAAiB,WAAjB,EAA8B,KAA9B,CAAtB;AACD;;AAED,UAAU,yBAAV,CACE,QADF,EAEE,KAFF,EAGE,WAHF,EAG0B;AAExB,MAAI,CAAC,KAAK,CAAC,eAAN,CAAsB,KAAtB,CAAL,EAAmC;AACjC,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,gCALI,CAAN;AAOD;;AACD,MAAI,KAAK,CAAC,IAAN,CAAW,SAAX,KAAyB,MAA7B,EAAqC;AACnC,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,QAAQ,CAAC,kBAAT,CAA4B,KAAK,CAAC,IAAlC,CALI,CAAN;AAOD;;AACD,MAAI,KAAK,CAAC,IAAN,KAAe,OAAnB,EAA4B;AAC1B,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,iDALI,CAAN;AAOD;;AACD,MACE,CAAC,WAAW,CAAC,KAAb,KACC,QAAQ,CAAC,SAAT,KAAuB,MAAvB,IAAiC,KAAK,CAAC,IAAN,CAAW,EAAX,KAAkB,QAAQ,CAAC,EAD7D,CADF,EAGE;AACA,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,QAAQ,CAAC,kBAAT,CAA4B,KAAK,CAAC,IAAlC,CALI,CAAN;AAOD;;AACD,QAAM,YAAY,GAAkC,KAApD,CAzCwB,CA0CxB;;AACA,MAAI,YAAY,CAAC,KAAb,CAAmB,IAAnB,KAA4B,qBAAhC,EAAuD;AACrD,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,QAAQ,CAAC,kBALL,CAAN;AAOD;;AACD,QAAM,IAAI,GAAG,YAAY,CAAC,KAAb,CAAmB,OAAnB,CAA2B,KAA3B,EAAb;AACA,SAAO,eAAe,CAAC,QAAD,EAAW,IAAX,EAAiB,WAAjB,EAA8B,KAA9B,CAAtB;AACD;;AAED,UAAU,yBAAV,CACE,QADF,EAEE,KAFF,EAGE,WAHF,EAG0B;AAExB,MAAI,CAAC,KAAK,CAAC,eAAN,CAAsB,KAAtB,CAAL,EAAmC;AACjC,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,gCALI,CAAN;AAOD;;AACD,MAAI,KAAK,CAAC,IAAN,CAAW,SAAX,KAAyB,sBAA7B,EAAqD;AACnD,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,QAAQ,CAAC,kBAAT,CAA4B,KAAK,CAAC,IAAlC,CALI,CAAN;AAOD;;AACD,MAAI,KAAK,CAAC,IAAN,KAAe,OAAnB,EAA4B;AAC1B,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,QAAQ,CAAC,kBALL,CAAN;AAOD;;AACD,SAAO,OAAO,CAAA,GAAA,UAAA,CAAA,aAAA,EACZ,QADY,EAEZ,KAAK,CAAC,KAFM,EAGZ,WAHY,EAIZ,4BAJY,CAAd;AAMD;;AAED,UAAU,gCAAV,CACE,QADF,EAEE,KAFF,EAGE,WAHF,EAG0B;AAExB,MAAI,CAAC,KAAK,CAAC,gBAAN,CAAuB,KAAvB,CAAL,EAAoC;AAClC,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,iCALI,CAAN;AAOD;;AACD,MAAI,CAAC,KAAK,CAAC,IAAN,CAAW,KAAX,CAAiB,YAAjB,CAAL,EAAqC;AACnC,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,QAAQ,CAAC,SAAT,KAAuB,MAAvB,GAAgC,CAAhC,GAAoC,CAJhC,EAKJ;AACA;AACA,IAAA,QAAQ,CAAC,oBAAT,CAA8B,KAAK,CAAC,IAApC,CAPI,CAAN;AASD;;AACD,QAAM,CAAC,CAAD,EAAI,SAAJ,EAAe,YAAf,IAA+B,KAAK,CAAC,IAAN,CAAW,KAAX,CAAiB,gBAAjB,CAArC;AACA,QAAM,IAAI,GAAG,YAAY,GAAG,MAAM,CAAC,YAAD,CAAT,GAA0B,GAAnD,CAvBwB,CAuBgC;AACxD;AACA;;AACA,QAAM,iBAAiB,GACrB,QAAQ,CAAC,SAAT,KAAuB,MAAvB,GAAgC,QAAQ,CAAC,SAAzC,GAAqD,MADvD,CA1BwB,CA2BuC;AAC/D;;AACA,QAAM,YAAY,GAChB,QAAQ,CAAC,SAAT,KAAuB,MAAvB,GACI,QAAQ,CAAC,IADb,GAEI,IACA,IAAI,CAAC,IAAL,CACE,IAAI,CAAC,IAAL,CAEI,MAAM,CAAC,KAAP,CAAa,QAAb,CAAsB,QAAtB,EAAgC,WAAW,CAAC,gBAA5C,CADsB,CAErB,OAFqB,CAEb,MAHb,IAII,CALN,CAJN,CA7BwB,CAuCf;;AACT,MAAI,iBAAiB,KAAK,SAAtB,IAAmC,YAAY,KAAK,IAAxD,EAA8D;AAC5D,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,QAAQ,CAAC,oBAAT,CAA8B,KAAK,CAAC,IAApC,CALI,CAAN;AAOD,GAhDuB,CAiDxB;;;AACA,SAAO,OAAO,CAAA,GAAA,UAAA,CAAA,aAAA,EACZ,QADY,EAEZ,KAAK,CAAC,KAFM,EAED,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACN,WADM,CAAA,EACK;AAAE,IAAA,KAAK,EAAE;AAAT,GADL,CAFC,EAIZ,iBAJY,CAAd;AAMD;;AAED,UAAU,0BAAV,CACE,QADF,EAEE,KAFF,EAGE,WAHF,EAG0B;AAExB,MAAI,CAAC,KAAK,CAAC,gBAAN,CAAuB,KAAvB,CAAL,EAAoC;AAClC,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,iCALI,CAAN;AAOD;;AACD,MAAI,KAAK,CAAC,IAAN,KAAe,MAAnB,EAA2B;AACzB,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,QAAQ,CAAC,SAAT,KAAuB,MAAvB,GAAgC,CAAhC,GAAoC,CAJhC,EAKJ;AACA;AACA,IAAA,QAAQ,CAAC,oBAAT,CAA8B,KAAK,CAAC,IAApC,CAPI,CAAN;AASD;;AACD,MAAI,QAAQ,CAAC,SAAT,KAAuB,MAA3B,EAAmC;AACjC,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,QAAQ,CAAC,oBAAT,CAA8B,KAAK,CAAC,IAApC,CALI,CAAN;AAOD,GA9BuB,CA+BxB;AACA;AACA;;;AACA,SACE,OAAO,CAAA,GAAA,UAAA,CAAA,aAAA,EACL,QADK,EAEL,KAAK,CAAC,KAFD,EAEM,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACN,WADM,CAAA,EACK;AAAE,IAAA,KAAK,EAAE;AAAT,GADL,CAFN,EAIL,iBAJK,CADT;AAQD;;AAED,UAAU,gBAAV,CACE,QADF,EAEE,KAFF,EAGE,WAHF,EAG0B;AAExB,QAAM,OAAO,GAAG;AAAE,IAAA,IAAI,EAAE,SAAR;AAA4B,IAAA;AAA5B,GAAhB;AACA,QAAM,QAAQ,GAAG,MAAM,OAAvB;;AACA,MAAI,QAAQ,CAAC,IAAT,KAAkB,SAAtB,EAAiC;AAC/B,UAAM,IAAI,QAAA,CAAA,oBAAJ,CAAyB,OAAzB,EAAkC,QAAlC,CAAN;AACD;;AACD,MAAI,QAAQ,CAAC,KAAT,KAAmB,IAAvB,EAA6B;AAC3B,UAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,QAAQ,CAAC,mBAAT,GAA+B,CAA/B,GAAmC,CAJ/B,EAKJ,QAAQ,CAAC,MAAT,IAAmB,QAAQ,CAAC,yBAAT,CAAmC,QAAnC,CALf,CAAN;AAOD;;AACD,QAAM,IAAI,GAAG,UAAU,CAAC,IAAX,CAAgB,QAAQ,CAAC,KAAzB,CAAb;AACA,SAAO,eAAe,CAAC,QAAD,EAAW,IAAX,EAAiB,WAAjB,EAA8B,KAA9B,CAAtB;AACD;;AAED,SAAS,eAAT,CACE,QADF,EAEE,IAFF,EAGE,WAHF,EAIE,KAJF,CAIiB;AAJjB,E;AAME,UAAQ,QAAQ,CAAC,SAAjB;AACE,SAAK,MAAL;AACE,UAAI,IAAI,CAAC,KAAL,MAAgB,IAAI,CAAC,SAAL,KAAmB,QAAQ,CAAC,IAAhD,EAAsD;AACpD,cAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,QAAQ,CAAC,iBALL,CAAN;AAOD;;AACD,aAAO;AACL,QAAA,IAAI,EAAE,QADD;AAEL,QAAA,IAAI,EAAE,OAFD;AAGL,QAAA,KAAK,EAAE;AACL,UAAA;AADK;AAHF,OAAP;;AAOF,SAAK,KAAL;AACE,UACG,CAAC,IAAI,CAAC,KAAL,EAAD,IAAiB,IAAI,CAAC,SAAL,MAAoB,QAAQ,CAAC,IAA/C,IAAwD;AACvD,MAAA,IAAI,CAAC,KAAL,MAAgB,IAAI,CAAC,GAAL,GAAW,IAAX,CAAgB,CAAhB,EAAmB,SAAnB,MAAkC,QAAQ,CAAC,IAF9D,CAGE;AAHF,QAIE;AACA,cAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,QAAQ,CAAC,iBALL,CAAN;AAOD;;AACD,aAAO;AACL,QAAA,IAAI,EAAE,QADD;AAEL,QAAA,IAAI,EAAE,OAFD;AAGL,QAAA,KAAK,EAAE;AACL,UAAA;AADK;AAHF,OAAP;;AAOF,SAAK,MAAL;AACE,YAAM,QAAQ,GACZ,MAAM,CAAC,KAAP,CAAa,QAAb,CAAsB,QAAtB,EAAgC,WAAW,CAAC,gBAA5C,CADF;;AAGA,UAAI,IAAI,CAAC,KAAL,MAAgB,IAAI,CAAC,IAAL,CAAU,QAAQ,CAAC,OAAT,CAAiB,MAA3B,CAApB,EAAwD;AACtD,cAAM,IAAI,QAAA,CAAA,iBAAJ,CACJ,QADI,EAEJ,KAFI,EAGJ,WAAW,CAAC,IAHR,EAIJ,CAJI,EAKJ,QAAQ,CAAC,qBALL,CAAN;AAOD;;AACD,aAAO;AACL,QAAA,IAAI,EAAE,QADD;AAEL,QAAA,IAAI,EAAE,OAFD;AAGL,QAAA,KAAK,EAAE;AACL,UAAA,WAAW,EAAE,IADR;AAEL,UAAA,IAAI,EAAE,QAAQ,CAAC,OAAT,CAAiB,IAAI,CAAC,QAAL,EAAjB;AAFD;AAHF,OAAP;AApDJ;AA6DD","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.integerCases = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"codec:wrap:integer\");\nconst Format = __importStar(require(\"../format\"));\nconst dispatch_1 = require(\"./dispatch\");\nconst errors_1 = require(\"./errors\");\nconst Conversion = __importStar(require(\"../conversion\"));\nconst Utils = __importStar(require(\"./utils\"));\nconst Messages = __importStar(require(\"./messages\"));\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst big_js_1 = __importDefault(require(\"big.js\"));\nconst bytes_1 = require(\"./bytes\");\n//NOTE: all cases called \"integerFrom...\" also work for enums.\n//The cases labeled \"enumFrom...\" work only for enums.\n//there are no cases that work only for integers and not enums,\n//because we always want input for integers to also be valid for enums.\nconst integerFromStringCases = [\n    integerFromIntegerString,\n    enumFromNameString,\n    integerFromScientificOrUnits,\n    integerFromNegatedBaseString,\n    integerFromStringFailureCase\n];\n//note: doesn't include UDVT case,\n//or error case\nconst integerFromWrappedValueCases = [\n    integerFromCodecIntegerValue,\n    integerFromCodecEnumValue,\n    integerFromCodecDecimalValue\n];\nconst integerCasesBasic = [\n    ...integerFromStringCases,\n    integerFromNumber,\n    integerFromBoxedNumber,\n    integerFromBoxedString,\n    integerFromBigint,\n    integerFromBN,\n    integerFromBig,\n    integerFromUint8ArrayLike,\n    ...integerFromWrappedValueCases,\n    integerFromCodecEnumError,\n    integerFromCodecUdvtValue,\n    integerFromOther //must go last!\n];\nexports.integerCases = [\n    integerFromIntegerTypeValueInput,\n    enumFromEnumTypeValueInput,\n    ...integerCasesBasic\n];\nfunction* integerFromIntegerString(dataType, input, wrapOptions) {\n    if (typeof input !== \"string\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n    }\n    if (input.trim() === \"\") {\n        //bigint accepts this but we shouldn't\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, dataType.typeClass === \"enum\"\n            ? Messages.badEnumMessage\n            : Messages.nonNumericMessage);\n    }\n    const stripped = Utils.removeUnderscoresNumeric(input);\n    let asBN;\n    try {\n        //we'll use BigInt to parse integer strings, as it's pretty good at it.\n        //Note that it accepts hex/octal/binary with prefixes 0x, 0o, 0b.\n        const asBigInt = BigInt(stripped);\n        asBN = Conversion.toBN(asBigInt);\n    }\n    catch (_a) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input string was not an integer string\");\n    }\n    return validateAndWrap(dataType, asBN, wrapOptions, input);\n}\n//this case handles both scientific notation, and numbers with units\nfunction* integerFromScientificOrUnits(dataType, input, wrapOptions) {\n    if (typeof input !== \"string\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n    }\n    if (input.trim() === \"\") {\n        //the code below accepts this but we shouldn't\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, //only specificity 1 since it's already specificity 5 above\n        dataType.typeClass === \"enum\"\n            ? Messages.badEnumMessage\n            : Messages.nonNumericMessage);\n    }\n    const stripped = Utils.removeUnderscoresNoHex(input);\n    let [_, quantityString, unit] = stripped.match(/^(.*?)(|wei|gwei|shannon|finney|szabo|ether)\\s*$/i); //units will be case insensitive; note this always matches\n    quantityString = quantityString.trim(); //Big rejects whitespace, let's allow it\n    const unitPlacesTable = {\n        //we could accept all of web3's units here, but, that's a little much;\n        //we'll just accept the most common ones\n        \"\": 0,\n        wei: 0,\n        gwei: 9,\n        shannon: 9,\n        szabo: 12,\n        finney: 15,\n        ether: 18\n    };\n    let quantity;\n    try {\n        quantity = quantityString.match(/^\\s*$/)\n            ? new big_js_1.default(1) //allow just \"ether\" e.g.\n            : new big_js_1.default(quantityString);\n    }\n    catch (_a) {\n        quantity = null;\n    }\n    if (quantity === null) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string using scientific notation or units\");\n    }\n    const places = unitPlacesTable[unit.toLowerCase()];\n    const asBig = Conversion.shiftBigUp(quantity, places);\n    if (Conversion.countDecimalPlaces(asBig) !== 0) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, unit !== \"\"\n            ? \"Input numeric value was not an integral number of wei\"\n            : Messages.nonIntegerMessage);\n    }\n    const asBN = Conversion.toBN(asBig);\n    return validateAndWrap(dataType, asBN, wrapOptions, input);\n}\nfunction* integerFromNegatedBaseString(dataType, input, wrapOptions) {\n    if (typeof input !== \"string\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n    }\n    if (!input.match(/^\\s*-/)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a negated numeric string\");\n    }\n    const stripped = Utils.removeUnderscoresNumeric(input);\n    let positiveAsBN;\n    const [_, positiveString] = stripped.match(/^\\s*-(.*)$/);\n    try {\n        const positive = BigInt(positiveString);\n        positiveAsBN = Conversion.toBN(positive);\n    }\n    catch (_a) {\n        positiveAsBN = null;\n    }\n    if (positiveAsBN === null ||\n        positiveString === \"\" ||\n        positiveString.match(/^(-|\\s)/)) {\n        //no double negation, no bare \"-\", and no space after the minus!\n        //(we do this as a string check, rather than checking if\n        //positiveAsBN is >=0, in order to prevent entering e.g. \"--\" or \"- 2\")\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.nonNumericMessage);\n    }\n    const asBN = positiveAsBN.neg();\n    return validateAndWrap(dataType, asBN, wrapOptions, input);\n}\nfunction* enumFromNameString(dataType, input, wrapOptions) {\n    if (typeof input !== \"string\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n    }\n    if (dataType.typeClass !== \"enum\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.nonNumericMessage);\n    }\n    const fullType = (Format.Types.fullType(dataType, wrapOptions.userDefinedTypes));\n    const options = fullType.options;\n    const components = input.split(\".\");\n    const finalComponent = components[components.length - 1];\n    debug(\"components: %O\", components);\n    debug(\"dataType: %O\", dataType);\n    debug(\"options: %O\", options);\n    //the enum can be qualified.  if it's qualified, does the type match?\n    let matchingType;\n    switch (components.length) {\n        case 1:\n            //not qualified, automatically matches\n            matchingType = true;\n            break;\n        case 2:\n            //qualified by type name, does it match?\n            matchingType = components[0] === dataType.typeName;\n            break;\n        case 3:\n            //qualified by type name and contract name, does it match?\n            matchingType =\n                dataType.kind === \"local\" &&\n                    components[0] === dataType.definingContractName &&\n                    components[1] === dataType.typeName;\n            break;\n        default:\n            //no valid reason to have 3 or more periods\n            //(and split cannot return an empty array)\n            matchingType = false;\n    }\n    debug(\"matchingType: %O\", matchingType);\n    const numeric = matchingType ? options.indexOf(finalComponent) : -1; //if type doesn't match, just indicate error\n    debug(\"numeric: %d\", numeric);\n    if (numeric === -1) {\n        //-1 comes from either our setting it manually above to indicate error,\n        //or from a failed indexOf call\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.badEnumMessage);\n    }\n    const asBN = new bn_js_1.default(numeric); //whew!\n    //now: unlike in every other case, we can skip validation!\n    //so let's just wrap and return!\n    return {\n        type: dataType,\n        kind: \"value\",\n        value: {\n            numericAsBN: asBN,\n            name: finalComponent //we know it matches!\n        }\n    };\n}\nfunction* integerFromStringFailureCase(dataType, input, wrapOptions) {\n    if (typeof input !== \"string\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n    }\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, dataType.typeClass === \"enum\"\n        ? Messages.badEnumMessage\n        : Messages.nonNumericMessage);\n}\nfunction* integerFromBN(dataType, input, wrapOptions) {\n    if (!bn_js_1.default.isBN(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a BN\");\n    }\n    const asBN = input.clone();\n    return validateAndWrap(dataType, asBN, wrapOptions, input);\n}\nfunction* integerFromBigint(dataType, input, wrapOptions) {\n    if (typeof input !== \"bigint\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a bigint\");\n    }\n    const asBN = Conversion.toBN(input);\n    return validateAndWrap(dataType, asBN, wrapOptions, input);\n}\nfunction* integerFromNumber(dataType, input, wrapOptions) {\n    if (typeof input !== \"number\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a number\");\n    }\n    if (!Number.isInteger(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.nonIntegerMessage);\n    }\n    if (!Number.isSafeInteger(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.nonSafeMessage);\n    }\n    const asBN = new bn_js_1.default(input);\n    return validateAndWrap(dataType, asBN, wrapOptions, input);\n}\nfunction* integerFromBig(dataType, input, wrapOptions) {\n    if (!Conversion.isBig(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a Big\");\n    }\n    if (Conversion.countDecimalPlaces(input) !== 0) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.nonIntegerMessage);\n    }\n    const asBN = Conversion.toBN(input);\n    return validateAndWrap(dataType, asBN, wrapOptions, input);\n}\nfunction* integerFromUint8ArrayLike(dataType, input, wrapOptions) {\n    if (!Utils.isUint8ArrayLike(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a Uint8Array-like\");\n    }\n    //the next series of checks is delegated to a helper fn\n    (0, bytes_1.validateUint8ArrayLike)(input, dataType, wrapOptions.name); //(this fn just throws an appropriate error if something's bad)\n    const asBN = Conversion.toBN(new Uint8Array(input)); //I am surprised TS accepts this!\n    return validateAndWrap(dataType, asBN, wrapOptions, input);\n}\nfunction* integerFromBoxedNumber(dataType, input, wrapOptions) {\n    if (!Utils.isBoxedNumber(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a boxed number\");\n    }\n    //unbox and try again\n    return yield* integerFromNumber(dataType, input.valueOf(), wrapOptions);\n}\nfunction* integerFromBoxedString(dataType, input, wrapOptions) {\n    if (!Utils.isBoxedString(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a boxed string\");\n    }\n    //unbox and try again\n    return yield* (0, dispatch_1.wrapWithCases)(dataType, input.valueOf(), wrapOptions, integerFromStringCases);\n}\nfunction* integerFromCodecIntegerValue(dataType, input, wrapOptions) {\n    if (!Utils.isWrappedResult(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n    }\n    if (input.type.typeClass !== \"int\" && input.type.typeClass !== \"uint\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n    }\n    if (input.kind !== \"value\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n    }\n    if (!wrapOptions.loose &&\n        (input.type.typeClass !== dataType.typeClass ||\n            input.type.bits !== dataType.bits)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n    }\n    const asBN = input.value.asBN.clone();\n    return validateAndWrap(dataType, asBN, wrapOptions, input);\n}\nfunction* integerFromCodecDecimalValue(dataType, input, wrapOptions) {\n    if (!Utils.isWrappedResult(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n    }\n    if (input.type.typeClass !== \"fixed\" && input.type.typeClass !== \"ufixed\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n    }\n    if (input.kind !== \"value\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n    }\n    if (!wrapOptions.loose) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n    }\n    const asBN = Conversion.toBN(input.value.asBig);\n    return validateAndWrap(dataType, asBN, wrapOptions, input);\n}\nfunction* integerFromCodecEnumValue(dataType, input, wrapOptions) {\n    if (!Utils.isWrappedResult(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n    }\n    if (input.type.typeClass !== \"enum\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n    }\n    if (input.kind !== \"value\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, //only specificity 1 due to EnumError case\n        Messages.errorResultMessage);\n    }\n    if (!wrapOptions.loose &&\n        (dataType.typeClass !== \"enum\" || input.type.id !== dataType.id)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n    }\n    const asBN = input.value.numericAsBN.clone();\n    return validateAndWrap(dataType, asBN, wrapOptions, input);\n}\nfunction* integerFromCodecEnumError(dataType, input, wrapOptions) {\n    if (!Utils.isWrappedResult(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n    }\n    if (input.type.typeClass !== \"enum\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n    }\n    if (input.kind !== \"error\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Wrapped result was a value rather than an error\");\n    }\n    if (!wrapOptions.loose &&\n        (dataType.typeClass !== \"enum\" || input.type.id !== dataType.id)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n    }\n    const coercedInput = input;\n    //only one specific kind of error will be allowed\n    if (coercedInput.error.kind !== \"EnumOutOfRangeError\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n    }\n    const asBN = coercedInput.error.rawAsBN.clone();\n    return validateAndWrap(dataType, asBN, wrapOptions, input);\n}\nfunction* integerFromCodecUdvtValue(dataType, input, wrapOptions) {\n    if (!Utils.isWrappedResult(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n    }\n    if (input.type.typeClass !== \"userDefinedValueType\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.wrappedTypeMessage(input.type));\n    }\n    if (input.kind !== \"value\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n    }\n    return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, wrapOptions, integerFromWrappedValueCases);\n}\nfunction* integerFromIntegerTypeValueInput(dataType, input, wrapOptions) {\n    if (!Utils.isTypeValueInput(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n    }\n    if (!input.type.match(/^u?int\\d*$/)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, dataType.typeClass === \"enum\" ? 1 : 5, \n        //use specificity 5 when getting an integer (which have no alternative),\n        //but specificity 1 when getting an enum (which have enum type/value input also)\n        Messages.specifiedTypeMessage(input.type));\n    }\n    const [_, typeClass, bitsAsString] = input.type.match(/^(u?int)(\\d*)$/);\n    const bits = bitsAsString ? Number(bitsAsString) : 256; //defaults to 256\n    //(not using the WORD_SIZE constant due to fixed types bringing its applicability\n    //here into question)\n    const requiredTypeClass = dataType.typeClass !== \"enum\" ? dataType.typeClass : \"uint\"; //allow underlying uint type to work for enums\n    //(we handle \"enum\" given as type in a separate case below)\n    const requiredBits = dataType.typeClass !== \"enum\"\n        ? dataType.bits\n        : 8 *\n            Math.ceil(Math.log2((Format.Types.fullType(dataType, wrapOptions.userDefinedTypes)).options.length) / 8); //compute required bits for enum type (sorry)\n    if (requiredTypeClass !== typeClass || requiredBits !== bits) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n    }\n    //extract value & try again, with loose option turned on\n    return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), { loose: true }), integerCasesBasic);\n}\nfunction* enumFromEnumTypeValueInput(dataType, input, wrapOptions) {\n    if (!Utils.isTypeValueInput(input)) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n    }\n    if (input.type !== \"enum\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, dataType.typeClass === \"enum\" ? 5 : 1, \n        //use specificity 5 when getting an enum (which will have also failed integer type/value input),\n        //but specificity 1 when getting an integer (to which this doesn't really apply)\n        Messages.specifiedTypeMessage(input.type));\n    }\n    if (dataType.typeClass !== \"enum\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n    }\n    //extract value & try again, with loose option turned on\n    //(we'll also coerce the type on this one since we know it's\n    //going to be an enum value :P )\n    return (yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), { loose: true }), integerCasesBasic));\n}\nfunction* integerFromOther(dataType, input, wrapOptions) {\n    const request = { kind: \"integer\", input };\n    const response = yield request;\n    if (response.kind !== \"integer\") {\n        throw new errors_1.BadResponseTypeError(request, response);\n    }\n    if (response.value === null) {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, response.partiallyRecognized ? 5 : 3, response.reason || Messages.unrecognizedNumberMessage(dataType));\n    }\n    const asBN = Conversion.toBN(response.value);\n    return validateAndWrap(dataType, asBN, wrapOptions, input);\n}\nfunction validateAndWrap(dataType, asBN, wrapOptions, input //just for erroring\n) {\n    switch (dataType.typeClass) {\n        case \"uint\":\n            if (asBN.isNeg() || asBN.bitLength() > dataType.bits) {\n                throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.outOfRangeMessage);\n            }\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: {\n                    asBN\n                }\n            };\n        case \"int\":\n            if ((!asBN.isNeg() && asBN.bitLength() >= dataType.bits) || //>= since signed\n                (asBN.isNeg() && asBN.neg().subn(1).bitLength() >= dataType.bits)\n            //bitLength doesn't work great for negatives so we do this instead\n            ) {\n                throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.outOfRangeMessage);\n            }\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: {\n                    asBN\n                }\n            };\n        case \"enum\":\n            const fullType = (Format.Types.fullType(dataType, wrapOptions.userDefinedTypes));\n            if (asBN.isNeg() || asBN.gten(fullType.options.length)) {\n                throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.outOfRangeEnumMessage);\n            }\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: {\n                    numericAsBN: asBN,\n                    name: fullType.options[asBN.toNumber()]\n                }\n            };\n    }\n}\n//# sourceMappingURL=integer.js.map"]},"metadata":{},"sourceType":"script"}