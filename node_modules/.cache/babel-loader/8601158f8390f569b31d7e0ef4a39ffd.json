{"ast":null,"code":"import { htmlDecodeTree, xmlDecodeTree, BinTrieFlags, determineBranch, replaceCodePoint } from \"entities/lib/decode.js\";\nvar CharCodes;\n\n(function (CharCodes) {\n  CharCodes[CharCodes[\"Tab\"] = 9] = \"Tab\";\n  CharCodes[CharCodes[\"NewLine\"] = 10] = \"NewLine\";\n  CharCodes[CharCodes[\"FormFeed\"] = 12] = \"FormFeed\";\n  CharCodes[CharCodes[\"CarriageReturn\"] = 13] = \"CarriageReturn\";\n  CharCodes[CharCodes[\"Space\"] = 32] = \"Space\";\n  CharCodes[CharCodes[\"ExclamationMark\"] = 33] = \"ExclamationMark\";\n  CharCodes[CharCodes[\"Num\"] = 35] = \"Num\";\n  CharCodes[CharCodes[\"Amp\"] = 38] = \"Amp\";\n  CharCodes[CharCodes[\"SingleQuote\"] = 39] = \"SingleQuote\";\n  CharCodes[CharCodes[\"DoubleQuote\"] = 34] = \"DoubleQuote\";\n  CharCodes[CharCodes[\"Dash\"] = 45] = \"Dash\";\n  CharCodes[CharCodes[\"Slash\"] = 47] = \"Slash\";\n  CharCodes[CharCodes[\"Zero\"] = 48] = \"Zero\";\n  CharCodes[CharCodes[\"Nine\"] = 57] = \"Nine\";\n  CharCodes[CharCodes[\"Semi\"] = 59] = \"Semi\";\n  CharCodes[CharCodes[\"Lt\"] = 60] = \"Lt\";\n  CharCodes[CharCodes[\"Eq\"] = 61] = \"Eq\";\n  CharCodes[CharCodes[\"Gt\"] = 62] = \"Gt\";\n  CharCodes[CharCodes[\"Questionmark\"] = 63] = \"Questionmark\";\n  CharCodes[CharCodes[\"UpperA\"] = 65] = \"UpperA\";\n  CharCodes[CharCodes[\"LowerA\"] = 97] = \"LowerA\";\n  CharCodes[CharCodes[\"UpperF\"] = 70] = \"UpperF\";\n  CharCodes[CharCodes[\"LowerF\"] = 102] = \"LowerF\";\n  CharCodes[CharCodes[\"UpperZ\"] = 90] = \"UpperZ\";\n  CharCodes[CharCodes[\"LowerZ\"] = 122] = \"LowerZ\";\n  CharCodes[CharCodes[\"LowerX\"] = 120] = \"LowerX\";\n  CharCodes[CharCodes[\"OpeningSquareBracket\"] = 91] = \"OpeningSquareBracket\";\n})(CharCodes || (CharCodes = {}));\n/** All the states the tokenizer can be in. */\n\n\nvar State;\n\n(function (State) {\n  State[State[\"Text\"] = 1] = \"Text\";\n  State[State[\"BeforeTagName\"] = 2] = \"BeforeTagName\";\n  State[State[\"InTagName\"] = 3] = \"InTagName\";\n  State[State[\"InSelfClosingTag\"] = 4] = \"InSelfClosingTag\";\n  State[State[\"BeforeClosingTagName\"] = 5] = \"BeforeClosingTagName\";\n  State[State[\"InClosingTagName\"] = 6] = \"InClosingTagName\";\n  State[State[\"AfterClosingTagName\"] = 7] = \"AfterClosingTagName\"; // Attributes\n\n  State[State[\"BeforeAttributeName\"] = 8] = \"BeforeAttributeName\";\n  State[State[\"InAttributeName\"] = 9] = \"InAttributeName\";\n  State[State[\"AfterAttributeName\"] = 10] = \"AfterAttributeName\";\n  State[State[\"BeforeAttributeValue\"] = 11] = \"BeforeAttributeValue\";\n  State[State[\"InAttributeValueDq\"] = 12] = \"InAttributeValueDq\";\n  State[State[\"InAttributeValueSq\"] = 13] = \"InAttributeValueSq\";\n  State[State[\"InAttributeValueNq\"] = 14] = \"InAttributeValueNq\"; // Declarations\n\n  State[State[\"BeforeDeclaration\"] = 15] = \"BeforeDeclaration\";\n  State[State[\"InDeclaration\"] = 16] = \"InDeclaration\"; // Processing instructions\n\n  State[State[\"InProcessingInstruction\"] = 17] = \"InProcessingInstruction\"; // Comments & CDATA\n\n  State[State[\"BeforeComment\"] = 18] = \"BeforeComment\";\n  State[State[\"CDATASequence\"] = 19] = \"CDATASequence\";\n  State[State[\"InSpecialComment\"] = 20] = \"InSpecialComment\";\n  State[State[\"InCommentLike\"] = 21] = \"InCommentLike\"; // Special tags\n\n  State[State[\"BeforeSpecialS\"] = 22] = \"BeforeSpecialS\";\n  State[State[\"SpecialStartSequence\"] = 23] = \"SpecialStartSequence\";\n  State[State[\"InSpecialTag\"] = 24] = \"InSpecialTag\";\n  State[State[\"BeforeEntity\"] = 25] = \"BeforeEntity\";\n  State[State[\"BeforeNumericEntity\"] = 26] = \"BeforeNumericEntity\";\n  State[State[\"InNamedEntity\"] = 27] = \"InNamedEntity\";\n  State[State[\"InNumericEntity\"] = 28] = \"InNumericEntity\";\n  State[State[\"InHexEntity\"] = 29] = \"InHexEntity\";\n})(State || (State = {}));\n\nfunction isWhitespace(c) {\n  return c === CharCodes.Space || c === CharCodes.NewLine || c === CharCodes.Tab || c === CharCodes.FormFeed || c === CharCodes.CarriageReturn;\n}\n\nfunction isEndOfTagSection(c) {\n  return c === CharCodes.Slash || c === CharCodes.Gt || isWhitespace(c);\n}\n\nfunction isNumber(c) {\n  return c >= CharCodes.Zero && c <= CharCodes.Nine;\n}\n\nfunction isASCIIAlpha(c) {\n  return c >= CharCodes.LowerA && c <= CharCodes.LowerZ || c >= CharCodes.UpperA && c <= CharCodes.UpperZ;\n}\n\nfunction isHexDigit(c) {\n  return c >= CharCodes.UpperA && c <= CharCodes.UpperF || c >= CharCodes.LowerA && c <= CharCodes.LowerF;\n}\n\nexport var QuoteType;\n\n(function (QuoteType) {\n  QuoteType[QuoteType[\"NoValue\"] = 0] = \"NoValue\";\n  QuoteType[QuoteType[\"Unquoted\"] = 1] = \"Unquoted\";\n  QuoteType[QuoteType[\"Single\"] = 2] = \"Single\";\n  QuoteType[QuoteType[\"Double\"] = 3] = \"Double\";\n})(QuoteType || (QuoteType = {}));\n/**\n * Sequences used to match longer strings.\n *\n * We don't have `Script`, `Style`, or `Title` here. Instead, we re-use the *End\n * sequences with an increased offset.\n */\n\n\nconst Sequences = {\n  Cdata: new Uint8Array([0x43, 0x44, 0x41, 0x54, 0x41, 0x5b]),\n  CdataEnd: new Uint8Array([0x5d, 0x5d, 0x3e]),\n  CommentEnd: new Uint8Array([0x2d, 0x2d, 0x3e]),\n  ScriptEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74]),\n  StyleEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x74, 0x79, 0x6c, 0x65]),\n  TitleEnd: new Uint8Array([0x3c, 0x2f, 0x74, 0x69, 0x74, 0x6c, 0x65]) // `</title`\n\n};\nexport default class Tokenizer {\n  constructor(_ref, cbs) {\n    let {\n      xmlMode = false,\n      decodeEntities = true\n    } = _ref;\n    this.cbs = cbs;\n    /** The current state the tokenizer is in. */\n\n    this.state = State.Text;\n    /** The read buffer. */\n\n    this.buffer = \"\";\n    /** The beginning of the section that is currently being read. */\n\n    this.sectionStart = 0;\n    /** The index within the buffer that we are currently looking at. */\n\n    this.index = 0;\n    /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */\n\n    this.baseState = State.Text;\n    /** For special parsing behavior inside of script and style tags. */\n\n    this.isSpecial = false;\n    /** Indicates whether the tokenizer has been paused. */\n\n    this.running = true;\n    /** The offset of the current buffer. */\n\n    this.offset = 0;\n    this.sequenceIndex = 0;\n    this.trieIndex = 0;\n    this.trieCurrent = 0;\n    /** For named entities, the index of the value. For numeric entities, the code point. */\n\n    this.entityResult = 0;\n    this.entityExcess = 0;\n    this.xmlMode = xmlMode;\n    this.decodeEntities = decodeEntities;\n    this.entityTrie = xmlMode ? xmlDecodeTree : htmlDecodeTree;\n  }\n\n  reset() {\n    this.state = State.Text;\n    this.buffer = \"\";\n    this.sectionStart = 0;\n    this.index = 0;\n    this.baseState = State.Text;\n    this.currentSequence = undefined;\n    this.running = true;\n    this.offset = 0;\n  }\n\n  write(chunk) {\n    this.offset += this.buffer.length;\n    this.buffer = chunk;\n    this.parse();\n  }\n\n  end() {\n    if (this.running) this.finish();\n  }\n\n  pause() {\n    this.running = false;\n  }\n\n  resume() {\n    this.running = true;\n\n    if (this.index < this.buffer.length + this.offset) {\n      this.parse();\n    }\n  }\n  /**\n   * The current index within all of the written data.\n   */\n\n\n  getIndex() {\n    return this.index;\n  }\n  /**\n   * The start of the current section.\n   */\n\n\n  getSectionStart() {\n    return this.sectionStart;\n  }\n\n  stateText(c) {\n    if (c === CharCodes.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes.Lt)) {\n      if (this.index > this.sectionStart) {\n        this.cbs.ontext(this.sectionStart, this.index);\n      }\n\n      this.state = State.BeforeTagName;\n      this.sectionStart = this.index;\n    } else if (this.decodeEntities && c === CharCodes.Amp) {\n      this.state = State.BeforeEntity;\n    }\n  }\n\n  stateSpecialStartSequence(c) {\n    const isEnd = this.sequenceIndex === this.currentSequence.length;\n    const isMatch = isEnd ? // If we are at the end of the sequence, make sure the tag name has ended\n    isEndOfTagSection(c) : // Otherwise, do a case-insensitive comparison\n    (c | 0x20) === this.currentSequence[this.sequenceIndex];\n\n    if (!isMatch) {\n      this.isSpecial = false;\n    } else if (!isEnd) {\n      this.sequenceIndex++;\n      return;\n    }\n\n    this.sequenceIndex = 0;\n    this.state = State.InTagName;\n    this.stateInTagName(c);\n  }\n  /** Look for an end tag. For <title> tags, also decode entities. */\n\n\n  stateInSpecialTag(c) {\n    if (this.sequenceIndex === this.currentSequence.length) {\n      if (c === CharCodes.Gt || isWhitespace(c)) {\n        const endOfText = this.index - this.currentSequence.length;\n\n        if (this.sectionStart < endOfText) {\n          // Spoof the index so that reported locations match up.\n          const actualIndex = this.index;\n          this.index = endOfText;\n          this.cbs.ontext(this.sectionStart, endOfText);\n          this.index = actualIndex;\n        }\n\n        this.isSpecial = false;\n        this.sectionStart = endOfText + 2; // Skip over the `</`\n\n        this.stateInClosingTagName(c);\n        return; // We are done; skip the rest of the function.\n      }\n\n      this.sequenceIndex = 0;\n    }\n\n    if ((c | 0x20) === this.currentSequence[this.sequenceIndex]) {\n      this.sequenceIndex += 1;\n    } else if (this.sequenceIndex === 0) {\n      if (this.currentSequence === Sequences.TitleEnd) {\n        // We have to parse entities in <title> tags.\n        if (this.decodeEntities && c === CharCodes.Amp) {\n          this.state = State.BeforeEntity;\n        }\n      } else if (this.fastForwardTo(CharCodes.Lt)) {\n        // Outside of <title> tags, we can fast-forward.\n        this.sequenceIndex = 1;\n      }\n    } else {\n      // If we see a `<`, set the sequence index to 1; useful for eg. `<</script>`.\n      this.sequenceIndex = Number(c === CharCodes.Lt);\n    }\n  }\n\n  stateCDATASequence(c) {\n    if (c === Sequences.Cdata[this.sequenceIndex]) {\n      if (++this.sequenceIndex === Sequences.Cdata.length) {\n        this.state = State.InCommentLike;\n        this.currentSequence = Sequences.CdataEnd;\n        this.sequenceIndex = 0;\n        this.sectionStart = this.index + 1;\n      }\n    } else {\n      this.sequenceIndex = 0;\n      this.state = State.InDeclaration;\n      this.stateInDeclaration(c); // Reconsume the character\n    }\n  }\n  /**\n   * When we wait for one specific character, we can speed things up\n   * by skipping through the buffer until we find it.\n   *\n   * @returns Whether the character was found.\n   */\n\n\n  fastForwardTo(c) {\n    while (++this.index < this.buffer.length + this.offset) {\n      if (this.buffer.charCodeAt(this.index - this.offset) === c) {\n        return true;\n      }\n    }\n    /*\n     * We increment the index at the end of the `parse` loop,\n     * so set it to `buffer.length - 1` here.\n     *\n     * TODO: Refactor `parse` to increment index before calling states.\n     */\n\n\n    this.index = this.buffer.length + this.offset - 1;\n    return false;\n  }\n  /**\n   * Comments and CDATA end with `-->` and `]]>`.\n   *\n   * Their common qualities are:\n   * - Their end sequences have a distinct character they start with.\n   * - That character is then repeated, so we have to check multiple repeats.\n   * - All characters but the start character of the sequence can be skipped.\n   */\n\n\n  stateInCommentLike(c) {\n    if (c === this.currentSequence[this.sequenceIndex]) {\n      if (++this.sequenceIndex === this.currentSequence.length) {\n        if (this.currentSequence === Sequences.CdataEnd) {\n          this.cbs.oncdata(this.sectionStart, this.index, 2);\n        } else {\n          this.cbs.oncomment(this.sectionStart, this.index, 2);\n        }\n\n        this.sequenceIndex = 0;\n        this.sectionStart = this.index + 1;\n        this.state = State.Text;\n      }\n    } else if (this.sequenceIndex === 0) {\n      // Fast-forward to the first character of the sequence\n      if (this.fastForwardTo(this.currentSequence[0])) {\n        this.sequenceIndex = 1;\n      }\n    } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {\n      // Allow long sequences, eg. --->, ]]]>\n      this.sequenceIndex = 0;\n    }\n  }\n  /**\n   * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.\n   *\n   * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).\n   * We allow anything that wouldn't end the tag.\n   */\n\n\n  isTagStartChar(c) {\n    return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);\n  }\n\n  startSpecial(sequence, offset) {\n    this.isSpecial = true;\n    this.currentSequence = sequence;\n    this.sequenceIndex = offset;\n    this.state = State.SpecialStartSequence;\n  }\n\n  stateBeforeTagName(c) {\n    if (c === CharCodes.ExclamationMark) {\n      this.state = State.BeforeDeclaration;\n      this.sectionStart = this.index + 1;\n    } else if (c === CharCodes.Questionmark) {\n      this.state = State.InProcessingInstruction;\n      this.sectionStart = this.index + 1;\n    } else if (this.isTagStartChar(c)) {\n      const lower = c | 0x20;\n      this.sectionStart = this.index;\n\n      if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {\n        this.startSpecial(Sequences.TitleEnd, 3);\n      } else {\n        this.state = !this.xmlMode && lower === Sequences.ScriptEnd[2] ? State.BeforeSpecialS : State.InTagName;\n      }\n    } else if (c === CharCodes.Slash) {\n      this.state = State.BeforeClosingTagName;\n    } else {\n      this.state = State.Text;\n      this.stateText(c);\n    }\n  }\n\n  stateInTagName(c) {\n    if (isEndOfTagSection(c)) {\n      this.cbs.onopentagname(this.sectionStart, this.index);\n      this.sectionStart = -1;\n      this.state = State.BeforeAttributeName;\n      this.stateBeforeAttributeName(c);\n    }\n  }\n\n  stateBeforeClosingTagName(c) {\n    if (isWhitespace(c)) {// Ignore\n    } else if (c === CharCodes.Gt) {\n      this.state = State.Text;\n    } else {\n      this.state = this.isTagStartChar(c) ? State.InClosingTagName : State.InSpecialComment;\n      this.sectionStart = this.index;\n    }\n  }\n\n  stateInClosingTagName(c) {\n    if (c === CharCodes.Gt || isWhitespace(c)) {\n      this.cbs.onclosetag(this.sectionStart, this.index);\n      this.sectionStart = -1;\n      this.state = State.AfterClosingTagName;\n      this.stateAfterClosingTagName(c);\n    }\n  }\n\n  stateAfterClosingTagName(c) {\n    // Skip everything until \">\"\n    if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {\n      this.state = State.Text;\n      this.sectionStart = this.index + 1;\n    }\n  }\n\n  stateBeforeAttributeName(c) {\n    if (c === CharCodes.Gt) {\n      this.cbs.onopentagend(this.index);\n\n      if (this.isSpecial) {\n        this.state = State.InSpecialTag;\n        this.sequenceIndex = 0;\n      } else {\n        this.state = State.Text;\n      }\n\n      this.baseState = this.state;\n      this.sectionStart = this.index + 1;\n    } else if (c === CharCodes.Slash) {\n      this.state = State.InSelfClosingTag;\n    } else if (!isWhitespace(c)) {\n      this.state = State.InAttributeName;\n      this.sectionStart = this.index;\n    }\n  }\n\n  stateInSelfClosingTag(c) {\n    if (c === CharCodes.Gt) {\n      this.cbs.onselfclosingtag(this.index);\n      this.state = State.Text;\n      this.baseState = State.Text;\n      this.sectionStart = this.index + 1;\n      this.isSpecial = false; // Reset special state, in case of self-closing special tags\n    } else if (!isWhitespace(c)) {\n      this.state = State.BeforeAttributeName;\n      this.stateBeforeAttributeName(c);\n    }\n  }\n\n  stateInAttributeName(c) {\n    if (c === CharCodes.Eq || isEndOfTagSection(c)) {\n      this.cbs.onattribname(this.sectionStart, this.index);\n      this.sectionStart = -1;\n      this.state = State.AfterAttributeName;\n      this.stateAfterAttributeName(c);\n    }\n  }\n\n  stateAfterAttributeName(c) {\n    if (c === CharCodes.Eq) {\n      this.state = State.BeforeAttributeValue;\n    } else if (c === CharCodes.Slash || c === CharCodes.Gt) {\n      this.cbs.onattribend(QuoteType.NoValue, this.index);\n      this.state = State.BeforeAttributeName;\n      this.stateBeforeAttributeName(c);\n    } else if (!isWhitespace(c)) {\n      this.cbs.onattribend(QuoteType.NoValue, this.index);\n      this.state = State.InAttributeName;\n      this.sectionStart = this.index;\n    }\n  }\n\n  stateBeforeAttributeValue(c) {\n    if (c === CharCodes.DoubleQuote) {\n      this.state = State.InAttributeValueDq;\n      this.sectionStart = this.index + 1;\n    } else if (c === CharCodes.SingleQuote) {\n      this.state = State.InAttributeValueSq;\n      this.sectionStart = this.index + 1;\n    } else if (!isWhitespace(c)) {\n      this.sectionStart = this.index;\n      this.state = State.InAttributeValueNq;\n      this.stateInAttributeValueNoQuotes(c); // Reconsume token\n    }\n  }\n\n  handleInAttributeValue(c, quote) {\n    if (c === quote || !this.decodeEntities && this.fastForwardTo(quote)) {\n      this.cbs.onattribdata(this.sectionStart, this.index);\n      this.sectionStart = -1;\n      this.cbs.onattribend(quote === CharCodes.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index);\n      this.state = State.BeforeAttributeName;\n    } else if (this.decodeEntities && c === CharCodes.Amp) {\n      this.baseState = this.state;\n      this.state = State.BeforeEntity;\n    }\n  }\n\n  stateInAttributeValueDoubleQuotes(c) {\n    this.handleInAttributeValue(c, CharCodes.DoubleQuote);\n  }\n\n  stateInAttributeValueSingleQuotes(c) {\n    this.handleInAttributeValue(c, CharCodes.SingleQuote);\n  }\n\n  stateInAttributeValueNoQuotes(c) {\n    if (isWhitespace(c) || c === CharCodes.Gt) {\n      this.cbs.onattribdata(this.sectionStart, this.index);\n      this.sectionStart = -1;\n      this.cbs.onattribend(QuoteType.Unquoted, this.index);\n      this.state = State.BeforeAttributeName;\n      this.stateBeforeAttributeName(c);\n    } else if (this.decodeEntities && c === CharCodes.Amp) {\n      this.baseState = this.state;\n      this.state = State.BeforeEntity;\n    }\n  }\n\n  stateBeforeDeclaration(c) {\n    if (c === CharCodes.OpeningSquareBracket) {\n      this.state = State.CDATASequence;\n      this.sequenceIndex = 0;\n    } else {\n      this.state = c === CharCodes.Dash ? State.BeforeComment : State.InDeclaration;\n    }\n  }\n\n  stateInDeclaration(c) {\n    if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {\n      this.cbs.ondeclaration(this.sectionStart, this.index);\n      this.state = State.Text;\n      this.sectionStart = this.index + 1;\n    }\n  }\n\n  stateInProcessingInstruction(c) {\n    if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {\n      this.cbs.onprocessinginstruction(this.sectionStart, this.index);\n      this.state = State.Text;\n      this.sectionStart = this.index + 1;\n    }\n  }\n\n  stateBeforeComment(c) {\n    if (c === CharCodes.Dash) {\n      this.state = State.InCommentLike;\n      this.currentSequence = Sequences.CommentEnd; // Allow short comments (eg. <!-->)\n\n      this.sequenceIndex = 2;\n      this.sectionStart = this.index + 1;\n    } else {\n      this.state = State.InDeclaration;\n    }\n  }\n\n  stateInSpecialComment(c) {\n    if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {\n      this.cbs.oncomment(this.sectionStart, this.index, 0);\n      this.state = State.Text;\n      this.sectionStart = this.index + 1;\n    }\n  }\n\n  stateBeforeSpecialS(c) {\n    const lower = c | 0x20;\n\n    if (lower === Sequences.ScriptEnd[3]) {\n      this.startSpecial(Sequences.ScriptEnd, 4);\n    } else if (lower === Sequences.StyleEnd[3]) {\n      this.startSpecial(Sequences.StyleEnd, 4);\n    } else {\n      this.state = State.InTagName;\n      this.stateInTagName(c); // Consume the token again\n    }\n  }\n\n  stateBeforeEntity(c) {\n    // Start excess with 1 to include the '&'\n    this.entityExcess = 1;\n    this.entityResult = 0;\n\n    if (c === CharCodes.Num) {\n      this.state = State.BeforeNumericEntity;\n    } else if (c === CharCodes.Amp) {// We have two `&` characters in a row. Stay in the current state.\n    } else {\n      this.trieIndex = 0;\n      this.trieCurrent = this.entityTrie[0];\n      this.state = State.InNamedEntity;\n      this.stateInNamedEntity(c);\n    }\n  }\n\n  stateInNamedEntity(c) {\n    this.entityExcess += 1;\n    this.trieIndex = determineBranch(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c);\n\n    if (this.trieIndex < 0) {\n      this.emitNamedEntity();\n      this.index--;\n      return;\n    }\n\n    this.trieCurrent = this.entityTrie[this.trieIndex];\n    const masked = this.trieCurrent & BinTrieFlags.VALUE_LENGTH; // If the branch is a value, store it and continue\n\n    if (masked) {\n      // The mask is the number of bytes of the value, including the current byte.\n      const valueLength = (masked >> 14) - 1; // If we have a legacy entity while parsing strictly, just skip the number of bytes\n\n      if (!this.allowLegacyEntity() && c !== CharCodes.Semi) {\n        this.trieIndex += valueLength;\n      } else {\n        // Add 1 as we have already incremented the excess\n        const entityStart = this.index - this.entityExcess + 1;\n\n        if (entityStart > this.sectionStart) {\n          this.emitPartial(this.sectionStart, entityStart);\n        } // If this is a surrogate pair, consume the next two bytes\n\n\n        this.entityResult = this.trieIndex;\n        this.trieIndex += valueLength;\n        this.entityExcess = 0;\n        this.sectionStart = this.index + 1;\n\n        if (valueLength === 0) {\n          this.emitNamedEntity();\n        }\n      }\n    }\n  }\n\n  emitNamedEntity() {\n    this.state = this.baseState;\n\n    if (this.entityResult === 0) {\n      return;\n    }\n\n    const valueLength = (this.entityTrie[this.entityResult] & BinTrieFlags.VALUE_LENGTH) >> 14;\n\n    switch (valueLength) {\n      case 1:\n        this.emitCodePoint(this.entityTrie[this.entityResult] & ~BinTrieFlags.VALUE_LENGTH);\n        break;\n\n      case 2:\n        this.emitCodePoint(this.entityTrie[this.entityResult + 1]);\n        break;\n\n      case 3:\n        {\n          this.emitCodePoint(this.entityTrie[this.entityResult + 1]);\n          this.emitCodePoint(this.entityTrie[this.entityResult + 2]);\n        }\n    }\n  }\n\n  stateBeforeNumericEntity(c) {\n    if ((c | 0x20) === CharCodes.LowerX) {\n      this.entityExcess++;\n      this.state = State.InHexEntity;\n    } else {\n      this.state = State.InNumericEntity;\n      this.stateInNumericEntity(c);\n    }\n  }\n\n  emitNumericEntity(strict) {\n    const entityStart = this.index - this.entityExcess - 1;\n    const numberStart = entityStart + 2 + Number(this.state === State.InHexEntity);\n\n    if (numberStart !== this.index) {\n      // Emit leading data if any\n      if (entityStart > this.sectionStart) {\n        this.emitPartial(this.sectionStart, entityStart);\n      }\n\n      this.sectionStart = this.index + Number(strict);\n      this.emitCodePoint(replaceCodePoint(this.entityResult));\n    }\n\n    this.state = this.baseState;\n  }\n\n  stateInNumericEntity(c) {\n    if (c === CharCodes.Semi) {\n      this.emitNumericEntity(true);\n    } else if (isNumber(c)) {\n      this.entityResult = this.entityResult * 10 + (c - CharCodes.Zero);\n      this.entityExcess++;\n    } else {\n      if (this.allowLegacyEntity()) {\n        this.emitNumericEntity(false);\n      } else {\n        this.state = this.baseState;\n      }\n\n      this.index--;\n    }\n  }\n\n  stateInHexEntity(c) {\n    if (c === CharCodes.Semi) {\n      this.emitNumericEntity(true);\n    } else if (isNumber(c)) {\n      this.entityResult = this.entityResult * 16 + (c - CharCodes.Zero);\n      this.entityExcess++;\n    } else if (isHexDigit(c)) {\n      this.entityResult = this.entityResult * 16 + ((c | 0x20) - CharCodes.LowerA + 10);\n      this.entityExcess++;\n    } else {\n      if (this.allowLegacyEntity()) {\n        this.emitNumericEntity(false);\n      } else {\n        this.state = this.baseState;\n      }\n\n      this.index--;\n    }\n  }\n\n  allowLegacyEntity() {\n    return !this.xmlMode && (this.baseState === State.Text || this.baseState === State.InSpecialTag);\n  }\n  /**\n   * Remove data that has already been consumed from the buffer.\n   */\n\n\n  cleanup() {\n    // If we are inside of text or attributes, emit what we already have.\n    if (this.running && this.sectionStart !== this.index) {\n      if (this.state === State.Text || this.state === State.InSpecialTag && this.sequenceIndex === 0) {\n        this.cbs.ontext(this.sectionStart, this.index);\n        this.sectionStart = this.index;\n      } else if (this.state === State.InAttributeValueDq || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueNq) {\n        this.cbs.onattribdata(this.sectionStart, this.index);\n        this.sectionStart = this.index;\n      }\n    }\n  }\n\n  shouldContinue() {\n    return this.index < this.buffer.length + this.offset && this.running;\n  }\n  /**\n   * Iterates through the buffer, calling the function corresponding to the current state.\n   *\n   * States that are more likely to be hit are higher up, as a performance improvement.\n   */\n\n\n  parse() {\n    while (this.shouldContinue()) {\n      const c = this.buffer.charCodeAt(this.index - this.offset);\n\n      if (this.state === State.Text) {\n        this.stateText(c);\n      } else if (this.state === State.SpecialStartSequence) {\n        this.stateSpecialStartSequence(c);\n      } else if (this.state === State.InSpecialTag) {\n        this.stateInSpecialTag(c);\n      } else if (this.state === State.CDATASequence) {\n        this.stateCDATASequence(c);\n      } else if (this.state === State.InAttributeValueDq) {\n        this.stateInAttributeValueDoubleQuotes(c);\n      } else if (this.state === State.InAttributeName) {\n        this.stateInAttributeName(c);\n      } else if (this.state === State.InCommentLike) {\n        this.stateInCommentLike(c);\n      } else if (this.state === State.InSpecialComment) {\n        this.stateInSpecialComment(c);\n      } else if (this.state === State.BeforeAttributeName) {\n        this.stateBeforeAttributeName(c);\n      } else if (this.state === State.InTagName) {\n        this.stateInTagName(c);\n      } else if (this.state === State.InClosingTagName) {\n        this.stateInClosingTagName(c);\n      } else if (this.state === State.BeforeTagName) {\n        this.stateBeforeTagName(c);\n      } else if (this.state === State.AfterAttributeName) {\n        this.stateAfterAttributeName(c);\n      } else if (this.state === State.InAttributeValueSq) {\n        this.stateInAttributeValueSingleQuotes(c);\n      } else if (this.state === State.BeforeAttributeValue) {\n        this.stateBeforeAttributeValue(c);\n      } else if (this.state === State.BeforeClosingTagName) {\n        this.stateBeforeClosingTagName(c);\n      } else if (this.state === State.AfterClosingTagName) {\n        this.stateAfterClosingTagName(c);\n      } else if (this.state === State.BeforeSpecialS) {\n        this.stateBeforeSpecialS(c);\n      } else if (this.state === State.InAttributeValueNq) {\n        this.stateInAttributeValueNoQuotes(c);\n      } else if (this.state === State.InSelfClosingTag) {\n        this.stateInSelfClosingTag(c);\n      } else if (this.state === State.InDeclaration) {\n        this.stateInDeclaration(c);\n      } else if (this.state === State.BeforeDeclaration) {\n        this.stateBeforeDeclaration(c);\n      } else if (this.state === State.BeforeComment) {\n        this.stateBeforeComment(c);\n      } else if (this.state === State.InProcessingInstruction) {\n        this.stateInProcessingInstruction(c);\n      } else if (this.state === State.InNamedEntity) {\n        this.stateInNamedEntity(c);\n      } else if (this.state === State.BeforeEntity) {\n        this.stateBeforeEntity(c);\n      } else if (this.state === State.InHexEntity) {\n        this.stateInHexEntity(c);\n      } else if (this.state === State.InNumericEntity) {\n        this.stateInNumericEntity(c);\n      } else {\n        // `this._state === State.BeforeNumericEntity`\n        this.stateBeforeNumericEntity(c);\n      }\n\n      this.index++;\n    }\n\n    this.cleanup();\n  }\n\n  finish() {\n    if (this.state === State.InNamedEntity) {\n      this.emitNamedEntity();\n    } // If there is remaining data, emit it in a reasonable way\n\n\n    if (this.sectionStart < this.index) {\n      this.handleTrailingData();\n    }\n\n    this.cbs.onend();\n  }\n  /** Handle any trailing data. */\n\n\n  handleTrailingData() {\n    const endIndex = this.buffer.length + this.offset;\n\n    if (this.state === State.InCommentLike) {\n      if (this.currentSequence === Sequences.CdataEnd) {\n        this.cbs.oncdata(this.sectionStart, endIndex, 0);\n      } else {\n        this.cbs.oncomment(this.sectionStart, endIndex, 0);\n      }\n    } else if (this.state === State.InNumericEntity && this.allowLegacyEntity()) {\n      this.emitNumericEntity(false); // All trailing data will have been consumed\n    } else if (this.state === State.InHexEntity && this.allowLegacyEntity()) {\n      this.emitNumericEntity(false); // All trailing data will have been consumed\n    } else if (this.state === State.InTagName || this.state === State.BeforeAttributeName || this.state === State.BeforeAttributeValue || this.state === State.AfterAttributeName || this.state === State.InAttributeName || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueDq || this.state === State.InAttributeValueNq || this.state === State.InClosingTagName) {\n      /*\n       * If we are currently in an opening or closing tag, us not calling the\n       * respective callback signals that the tag should be ignored.\n       */\n    } else {\n      this.cbs.ontext(this.sectionStart, endIndex);\n    }\n  }\n\n  emitPartial(start, endIndex) {\n    if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {\n      this.cbs.onattribdata(start, endIndex);\n    } else {\n      this.cbs.ontext(start, endIndex);\n    }\n  }\n\n  emitCodePoint(cp) {\n    if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {\n      this.cbs.onattribentity(cp);\n    } else {\n      this.cbs.ontextentity(cp);\n    }\n  }\n\n}","map":{"version":3,"sources":["Tokenizer.ts"],"names":[],"mappings":"AAAA,SACI,cADJ,EAEI,aAFJ,EAGI,YAHJ,EAII,eAJJ,EAKI,gBALJ,QAMO,wBANP;AAQA,IAAW,SAAX;;AAAA,CAAA,UAAW,SAAX,EAAoB;AAChB,EAAA,SAAA,CAAA,SAAA,CAAA,KAAA,CAAA,GAAA,CAAA,CAAA,GAAA,KAAA;AACA,EAAA,SAAA,CAAA,SAAA,CAAA,SAAA,CAAA,GAAA,EAAA,CAAA,GAAA,SAAA;AACA,EAAA,SAAA,CAAA,SAAA,CAAA,UAAA,CAAA,GAAA,EAAA,CAAA,GAAA,UAAA;AACA,EAAA,SAAA,CAAA,SAAA,CAAA,gBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,gBAAA;AACA,EAAA,SAAA,CAAA,SAAA,CAAA,OAAA,CAAA,GAAA,EAAA,CAAA,GAAA,OAAA;AACA,EAAA,SAAA,CAAA,SAAA,CAAA,iBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,iBAAA;AACA,EAAA,SAAA,CAAA,SAAA,CAAA,KAAA,CAAA,GAAA,EAAA,CAAA,GAAA,KAAA;AACA,EAAA,SAAA,CAAA,SAAA,CAAA,KAAA,CAAA,GAAA,EAAA,CAAA,GAAA,KAAA;AACA,EAAA,SAAA,CAAA,SAAA,CAAA,aAAA,CAAA,GAAA,EAAA,CAAA,GAAA,aAAA;AACA,EAAA,SAAA,CAAA,SAAA,CAAA,aAAA,CAAA,GAAA,EAAA,CAAA,GAAA,aAAA;AACA,EAAA,SAAA,CAAA,SAAA,CAAA,MAAA,CAAA,GAAA,EAAA,CAAA,GAAA,MAAA;AACA,EAAA,SAAA,CAAA,SAAA,CAAA,OAAA,CAAA,GAAA,EAAA,CAAA,GAAA,OAAA;AACA,EAAA,SAAA,CAAA,SAAA,CAAA,MAAA,CAAA,GAAA,EAAA,CAAA,GAAA,MAAA;AACA,EAAA,SAAA,CAAA,SAAA,CAAA,MAAA,CAAA,GAAA,EAAA,CAAA,GAAA,MAAA;AACA,EAAA,SAAA,CAAA,SAAA,CAAA,MAAA,CAAA,GAAA,EAAA,CAAA,GAAA,MAAA;AACA,EAAA,SAAA,CAAA,SAAA,CAAA,IAAA,CAAA,GAAA,EAAA,CAAA,GAAA,IAAA;AACA,EAAA,SAAA,CAAA,SAAA,CAAA,IAAA,CAAA,GAAA,EAAA,CAAA,GAAA,IAAA;AACA,EAAA,SAAA,CAAA,SAAA,CAAA,IAAA,CAAA,GAAA,EAAA,CAAA,GAAA,IAAA;AACA,EAAA,SAAA,CAAA,SAAA,CAAA,cAAA,CAAA,GAAA,EAAA,CAAA,GAAA,cAAA;AACA,EAAA,SAAA,CAAA,SAAA,CAAA,QAAA,CAAA,GAAA,EAAA,CAAA,GAAA,QAAA;AACA,EAAA,SAAA,CAAA,SAAA,CAAA,QAAA,CAAA,GAAA,EAAA,CAAA,GAAA,QAAA;AACA,EAAA,SAAA,CAAA,SAAA,CAAA,QAAA,CAAA,GAAA,EAAA,CAAA,GAAA,QAAA;AACA,EAAA,SAAA,CAAA,SAAA,CAAA,QAAA,CAAA,GAAA,GAAA,CAAA,GAAA,QAAA;AACA,EAAA,SAAA,CAAA,SAAA,CAAA,QAAA,CAAA,GAAA,EAAA,CAAA,GAAA,QAAA;AACA,EAAA,SAAA,CAAA,SAAA,CAAA,QAAA,CAAA,GAAA,GAAA,CAAA,GAAA,QAAA;AACA,EAAA,SAAA,CAAA,SAAA,CAAA,QAAA,CAAA,GAAA,GAAA,CAAA,GAAA,QAAA;AACA,EAAA,SAAA,CAAA,SAAA,CAAA,sBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,sBAAA;AACH,CA5BD,EAAW,SAAS,KAAT,SAAS,GAAA,EAAA,CAApB;AA8BA;;;AACA,IAAW,KAAX;;AAAA,CAAA,UAAW,KAAX,EAAgB;AACZ,EAAA,KAAA,CAAA,KAAA,CAAA,MAAA,CAAA,GAAA,CAAA,CAAA,GAAA,MAAA;AACA,EAAA,KAAA,CAAA,KAAA,CAAA,eAAA,CAAA,GAAA,CAAA,CAAA,GAAA,eAAA;AACA,EAAA,KAAA,CAAA,KAAA,CAAA,WAAA,CAAA,GAAA,CAAA,CAAA,GAAA,WAAA;AACA,EAAA,KAAA,CAAA,KAAA,CAAA,kBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,kBAAA;AACA,EAAA,KAAA,CAAA,KAAA,CAAA,sBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,sBAAA;AACA,EAAA,KAAA,CAAA,KAAA,CAAA,kBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,kBAAA;AACA,EAAA,KAAA,CAAA,KAAA,CAAA,qBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,qBAAA,CAPY,CASZ;;AACA,EAAA,KAAA,CAAA,KAAA,CAAA,qBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,qBAAA;AACA,EAAA,KAAA,CAAA,KAAA,CAAA,iBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,iBAAA;AACA,EAAA,KAAA,CAAA,KAAA,CAAA,oBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,oBAAA;AACA,EAAA,KAAA,CAAA,KAAA,CAAA,sBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,sBAAA;AACA,EAAA,KAAA,CAAA,KAAA,CAAA,oBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,oBAAA;AACA,EAAA,KAAA,CAAA,KAAA,CAAA,oBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,oBAAA;AACA,EAAA,KAAA,CAAA,KAAA,CAAA,oBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,oBAAA,CAhBY,CAkBZ;;AACA,EAAA,KAAA,CAAA,KAAA,CAAA,mBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,mBAAA;AACA,EAAA,KAAA,CAAA,KAAA,CAAA,eAAA,CAAA,GAAA,EAAA,CAAA,GAAA,eAAA,CApBY,CAsBZ;;AACA,EAAA,KAAA,CAAA,KAAA,CAAA,yBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,yBAAA,CAvBY,CAyBZ;;AACA,EAAA,KAAA,CAAA,KAAA,CAAA,eAAA,CAAA,GAAA,EAAA,CAAA,GAAA,eAAA;AACA,EAAA,KAAA,CAAA,KAAA,CAAA,eAAA,CAAA,GAAA,EAAA,CAAA,GAAA,eAAA;AACA,EAAA,KAAA,CAAA,KAAA,CAAA,kBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,kBAAA;AACA,EAAA,KAAA,CAAA,KAAA,CAAA,eAAA,CAAA,GAAA,EAAA,CAAA,GAAA,eAAA,CA7BY,CA+BZ;;AACA,EAAA,KAAA,CAAA,KAAA,CAAA,gBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,gBAAA;AACA,EAAA,KAAA,CAAA,KAAA,CAAA,sBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,sBAAA;AACA,EAAA,KAAA,CAAA,KAAA,CAAA,cAAA,CAAA,GAAA,EAAA,CAAA,GAAA,cAAA;AAEA,EAAA,KAAA,CAAA,KAAA,CAAA,cAAA,CAAA,GAAA,EAAA,CAAA,GAAA,cAAA;AACA,EAAA,KAAA,CAAA,KAAA,CAAA,qBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,qBAAA;AACA,EAAA,KAAA,CAAA,KAAA,CAAA,eAAA,CAAA,GAAA,EAAA,CAAA,GAAA,eAAA;AACA,EAAA,KAAA,CAAA,KAAA,CAAA,iBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,iBAAA;AACA,EAAA,KAAA,CAAA,KAAA,CAAA,aAAA,CAAA,GAAA,EAAA,CAAA,GAAA,aAAA;AACH,CAzCD,EAAW,KAAK,KAAL,KAAK,GAAA,EAAA,CAAhB;;AA2CA,SAAS,YAAT,CAAsB,CAAtB,EAA+B;AAC3B,SACI,CAAC,KAAK,SAAS,CAAC,KAAhB,IACA,CAAC,KAAK,SAAS,CAAC,OADhB,IAEA,CAAC,KAAK,SAAS,CAAC,GAFhB,IAGA,CAAC,KAAK,SAAS,CAAC,QAHhB,IAIA,CAAC,KAAK,SAAS,CAAC,cALpB;AAOH;;AAED,SAAS,iBAAT,CAA2B,CAA3B,EAAoC;AAChC,SAAO,CAAC,KAAK,SAAS,CAAC,KAAhB,IAAyB,CAAC,KAAK,SAAS,CAAC,EAAzC,IAA+C,YAAY,CAAC,CAAD,CAAlE;AACH;;AAED,SAAS,QAAT,CAAkB,CAAlB,EAA2B;AACvB,SAAO,CAAC,IAAI,SAAS,CAAC,IAAf,IAAuB,CAAC,IAAI,SAAS,CAAC,IAA7C;AACH;;AAED,SAAS,YAAT,CAAsB,CAAtB,EAA+B;AAC3B,SACK,CAAC,IAAI,SAAS,CAAC,MAAf,IAAyB,CAAC,IAAI,SAAS,CAAC,MAAzC,IACC,CAAC,IAAI,SAAS,CAAC,MAAf,IAAyB,CAAC,IAAI,SAAS,CAAC,MAF7C;AAIH;;AAED,SAAS,UAAT,CAAoB,CAApB,EAA6B;AACzB,SACK,CAAC,IAAI,SAAS,CAAC,MAAf,IAAyB,CAAC,IAAI,SAAS,CAAC,MAAzC,IACC,CAAC,IAAI,SAAS,CAAC,MAAf,IAAyB,CAAC,IAAI,SAAS,CAAC,MAF7C;AAIH;;AAED,OAAA,IAAY,SAAZ;;AAAA,CAAA,UAAY,SAAZ,EAAqB;AACjB,EAAA,SAAA,CAAA,SAAA,CAAA,SAAA,CAAA,GAAA,CAAA,CAAA,GAAA,SAAA;AACA,EAAA,SAAA,CAAA,SAAA,CAAA,UAAA,CAAA,GAAA,CAAA,CAAA,GAAA,UAAA;AACA,EAAA,SAAA,CAAA,SAAA,CAAA,QAAA,CAAA,GAAA,CAAA,CAAA,GAAA,QAAA;AACA,EAAA,SAAA,CAAA,SAAA,CAAA,QAAA,CAAA,GAAA,CAAA,CAAA,GAAA,QAAA;AACH,CALD,EAAY,SAAS,KAAT,SAAS,GAAA,EAAA,CAArB;AAyBA;;;;;AAKG;;;AACH,MAAM,SAAS,GAAG;AACd,EAAA,KAAK,EAAE,IAAI,UAAJ,CAAe,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,EAAyB,IAAzB,EAA+B,IAA/B,CAAf,CADO;AAEd,EAAA,QAAQ,EAAE,IAAI,UAAJ,CAAe,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,CAAf,CAFI;AAGd,EAAA,UAAU,EAAE,IAAI,UAAJ,CAAe,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,CAAf,CAHE;AAId,EAAA,SAAS,EAAE,IAAI,UAAJ,CAAe,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,EAAyB,IAAzB,EAA+B,IAA/B,EAAqC,IAArC,EAA2C,IAA3C,CAAf,CAJG;AAKd,EAAA,QAAQ,EAAE,IAAI,UAAJ,CAAe,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,EAAyB,IAAzB,EAA+B,IAA/B,EAAqC,IAArC,CAAf,CALI;AAMd,EAAA,QAAQ,EAAE,IAAI,UAAJ,CAAe,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,EAAyB,IAAzB,EAA+B,IAA/B,EAAqC,IAArC,CAAf,CANI,CAMwD;;AANxD,CAAlB;AASA,eAAc,MAAO,SAAP,CAAgB;AAsB1B,EAAA,WAAA,OAKqB,GALrB,EAKmC;AAAA,QAJ/B;AACI,MAAA,OAAO,GAAG,KADd;AAEI,MAAA,cAAc,GAAG;AAFrB,KAI+B;AAAd,SAAA,GAAA,GAAA,GAAA;AA1BrB;;AACQ,SAAA,KAAA,GAAQ,KAAK,CAAC,IAAd;AACR;;AACQ,SAAA,MAAA,GAAS,EAAT;AACR;;AACQ,SAAA,YAAA,GAAe,CAAf;AACR;;AACQ,SAAA,KAAA,GAAQ,CAAR;AACR;;AACQ,SAAA,SAAA,GAAY,KAAK,CAAC,IAAlB;AACR;;AACQ,SAAA,SAAA,GAAY,KAAZ;AACR;;AACO,SAAA,OAAA,GAAU,IAAV;AACP;;AACQ,SAAA,MAAA,GAAS,CAAT;AAgFA,SAAA,aAAA,GAAgB,CAAhB;AA8WA,SAAA,SAAA,GAAY,CAAZ;AACA,SAAA,WAAA,GAAc,CAAd;AACR;;AACQ,SAAA,YAAA,GAAe,CAAf;AACA,SAAA,YAAA,GAAe,CAAf;AArbJ,SAAK,OAAL,GAAe,OAAf;AACA,SAAK,cAAL,GAAsB,cAAtB;AACA,SAAK,UAAL,GAAkB,OAAO,GAAG,aAAH,GAAmB,cAA5C;AACH;;AAEM,EAAA,KAAK,GAAA;AACR,SAAK,KAAL,GAAa,KAAK,CAAC,IAAnB;AACA,SAAK,MAAL,GAAc,EAAd;AACA,SAAK,YAAL,GAAoB,CAApB;AACA,SAAK,KAAL,GAAa,CAAb;AACA,SAAK,SAAL,GAAiB,KAAK,CAAC,IAAvB;AACA,SAAK,eAAL,GAAuB,SAAvB;AACA,SAAK,OAAL,GAAe,IAAf;AACA,SAAK,MAAL,GAAc,CAAd;AACH;;AAEM,EAAA,KAAK,CAAC,KAAD,EAAc;AACtB,SAAK,MAAL,IAAe,KAAK,MAAL,CAAY,MAA3B;AACA,SAAK,MAAL,GAAc,KAAd;AACA,SAAK,KAAL;AACH;;AAEM,EAAA,GAAG,GAAA;AACN,QAAI,KAAK,OAAT,EAAkB,KAAK,MAAL;AACrB;;AAEM,EAAA,KAAK,GAAA;AACR,SAAK,OAAL,GAAe,KAAf;AACH;;AAEM,EAAA,MAAM,GAAA;AACT,SAAK,OAAL,GAAe,IAAf;;AACA,QAAI,KAAK,KAAL,GAAa,KAAK,MAAL,CAAY,MAAZ,GAAqB,KAAK,MAA3C,EAAmD;AAC/C,WAAK,KAAL;AACH;AACJ;AAED;;AAEG;;;AACI,EAAA,QAAQ,GAAA;AACX,WAAO,KAAK,KAAZ;AACH;AAED;;AAEG;;;AACI,EAAA,eAAe,GAAA;AAClB,WAAO,KAAK,YAAZ;AACH;;AAEO,EAAA,SAAS,CAAC,CAAD,EAAU;AACvB,QACI,CAAC,KAAK,SAAS,CAAC,EAAhB,IACC,CAAC,KAAK,cAAN,IAAwB,KAAK,aAAL,CAAmB,SAAS,CAAC,EAA7B,CAF7B,EAGE;AACE,UAAI,KAAK,KAAL,GAAa,KAAK,YAAtB,EAAoC;AAChC,aAAK,GAAL,CAAS,MAAT,CAAgB,KAAK,YAArB,EAAmC,KAAK,KAAxC;AACH;;AACD,WAAK,KAAL,GAAa,KAAK,CAAC,aAAnB;AACA,WAAK,YAAL,GAAoB,KAAK,KAAzB;AACH,KATD,MASO,IAAI,KAAK,cAAL,IAAuB,CAAC,KAAK,SAAS,CAAC,GAA3C,EAAgD;AACnD,WAAK,KAAL,GAAa,KAAK,CAAC,YAAnB;AACH;AACJ;;AAIO,EAAA,yBAAyB,CAAC,CAAD,EAAU;AACvC,UAAM,KAAK,GAAG,KAAK,aAAL,KAAuB,KAAK,eAAL,CAAqB,MAA1D;AACA,UAAM,OAAO,GAAG,KAAK,GACf;AACA,IAAA,iBAAiB,CAAC,CAAD,CAFF,GAGf;AACA,KAAC,CAAC,GAAG,IAAL,MAAe,KAAK,eAAL,CAAqB,KAAK,aAA1B,CAJrB;;AAMA,QAAI,CAAC,OAAL,EAAc;AACV,WAAK,SAAL,GAAiB,KAAjB;AACH,KAFD,MAEO,IAAI,CAAC,KAAL,EAAY;AACf,WAAK,aAAL;AACA;AACH;;AAED,SAAK,aAAL,GAAqB,CAArB;AACA,SAAK,KAAL,GAAa,KAAK,CAAC,SAAnB;AACA,SAAK,cAAL,CAAoB,CAApB;AACH;AAED;;;AACQ,EAAA,iBAAiB,CAAC,CAAD,EAAU;AAC/B,QAAI,KAAK,aAAL,KAAuB,KAAK,eAAL,CAAqB,MAAhD,EAAwD;AACpD,UAAI,CAAC,KAAK,SAAS,CAAC,EAAhB,IAAsB,YAAY,CAAC,CAAD,CAAtC,EAA2C;AACvC,cAAM,SAAS,GAAG,KAAK,KAAL,GAAa,KAAK,eAAL,CAAqB,MAApD;;AAEA,YAAI,KAAK,YAAL,GAAoB,SAAxB,EAAmC;AAC/B;AACA,gBAAM,WAAW,GAAG,KAAK,KAAzB;AACA,eAAK,KAAL,GAAa,SAAb;AACA,eAAK,GAAL,CAAS,MAAT,CAAgB,KAAK,YAArB,EAAmC,SAAnC;AACA,eAAK,KAAL,GAAa,WAAb;AACH;;AAED,aAAK,SAAL,GAAiB,KAAjB;AACA,aAAK,YAAL,GAAoB,SAAS,GAAG,CAAhC,CAZuC,CAYJ;;AACnC,aAAK,qBAAL,CAA2B,CAA3B;AACA,eAduC,CAc/B;AACX;;AAED,WAAK,aAAL,GAAqB,CAArB;AACH;;AAED,QAAI,CAAC,CAAC,GAAG,IAAL,MAAe,KAAK,eAAL,CAAqB,KAAK,aAA1B,CAAnB,EAA6D;AACzD,WAAK,aAAL,IAAsB,CAAtB;AACH,KAFD,MAEO,IAAI,KAAK,aAAL,KAAuB,CAA3B,EAA8B;AACjC,UAAI,KAAK,eAAL,KAAyB,SAAS,CAAC,QAAvC,EAAiD;AAC7C;AACA,YAAI,KAAK,cAAL,IAAuB,CAAC,KAAK,SAAS,CAAC,GAA3C,EAAgD;AAC5C,eAAK,KAAL,GAAa,KAAK,CAAC,YAAnB;AACH;AACJ,OALD,MAKO,IAAI,KAAK,aAAL,CAAmB,SAAS,CAAC,EAA7B,CAAJ,EAAsC;AACzC;AACA,aAAK,aAAL,GAAqB,CAArB;AACH;AACJ,KAVM,MAUA;AACH;AACA,WAAK,aAAL,GAAqB,MAAM,CAAC,CAAC,KAAK,SAAS,CAAC,EAAjB,CAA3B;AACH;AACJ;;AAEO,EAAA,kBAAkB,CAAC,CAAD,EAAU;AAChC,QAAI,CAAC,KAAK,SAAS,CAAC,KAAV,CAAgB,KAAK,aAArB,CAAV,EAA+C;AAC3C,UAAI,EAAE,KAAK,aAAP,KAAyB,SAAS,CAAC,KAAV,CAAgB,MAA7C,EAAqD;AACjD,aAAK,KAAL,GAAa,KAAK,CAAC,aAAnB;AACA,aAAK,eAAL,GAAuB,SAAS,CAAC,QAAjC;AACA,aAAK,aAAL,GAAqB,CAArB;AACA,aAAK,YAAL,GAAoB,KAAK,KAAL,GAAa,CAAjC;AACH;AACJ,KAPD,MAOO;AACH,WAAK,aAAL,GAAqB,CAArB;AACA,WAAK,KAAL,GAAa,KAAK,CAAC,aAAnB;AACA,WAAK,kBAAL,CAAwB,CAAxB,EAHG,CAGyB;AAC/B;AACJ;AAED;;;;;AAKG;;;AACK,EAAA,aAAa,CAAC,CAAD,EAAU;AAC3B,WAAO,EAAE,KAAK,KAAP,GAAe,KAAK,MAAL,CAAY,MAAZ,GAAqB,KAAK,MAAhD,EAAwD;AACpD,UAAI,KAAK,MAAL,CAAY,UAAZ,CAAuB,KAAK,KAAL,GAAa,KAAK,MAAzC,MAAqD,CAAzD,EAA4D;AACxD,eAAO,IAAP;AACH;AACJ;AAED;;;;;AAKG;;;AACH,SAAK,KAAL,GAAa,KAAK,MAAL,CAAY,MAAZ,GAAqB,KAAK,MAA1B,GAAmC,CAAhD;AAEA,WAAO,KAAP;AACH;AAED;;;;;;;AAOG;;;AACK,EAAA,kBAAkB,CAAC,CAAD,EAAU;AAChC,QAAI,CAAC,KAAK,KAAK,eAAL,CAAqB,KAAK,aAA1B,CAAV,EAAoD;AAChD,UAAI,EAAE,KAAK,aAAP,KAAyB,KAAK,eAAL,CAAqB,MAAlD,EAA0D;AACtD,YAAI,KAAK,eAAL,KAAyB,SAAS,CAAC,QAAvC,EAAiD;AAC7C,eAAK,GAAL,CAAS,OAAT,CAAiB,KAAK,YAAtB,EAAoC,KAAK,KAAzC,EAAgD,CAAhD;AACH,SAFD,MAEO;AACH,eAAK,GAAL,CAAS,SAAT,CAAmB,KAAK,YAAxB,EAAsC,KAAK,KAA3C,EAAkD,CAAlD;AACH;;AAED,aAAK,aAAL,GAAqB,CAArB;AACA,aAAK,YAAL,GAAoB,KAAK,KAAL,GAAa,CAAjC;AACA,aAAK,KAAL,GAAa,KAAK,CAAC,IAAnB;AACH;AACJ,KAZD,MAYO,IAAI,KAAK,aAAL,KAAuB,CAA3B,EAA8B;AACjC;AACA,UAAI,KAAK,aAAL,CAAmB,KAAK,eAAL,CAAqB,CAArB,CAAnB,CAAJ,EAAiD;AAC7C,aAAK,aAAL,GAAqB,CAArB;AACH;AACJ,KALM,MAKA,IAAI,CAAC,KAAK,KAAK,eAAL,CAAqB,KAAK,aAAL,GAAqB,CAA1C,CAAV,EAAwD;AAC3D;AACA,WAAK,aAAL,GAAqB,CAArB;AACH;AACJ;AAED;;;;;AAKG;;;AACK,EAAA,cAAc,CAAC,CAAD,EAAU;AAC5B,WAAO,KAAK,OAAL,GAAe,CAAC,iBAAiB,CAAC,CAAD,CAAjC,GAAuC,YAAY,CAAC,CAAD,CAA1D;AACH;;AAEO,EAAA,YAAY,CAAC,QAAD,EAAuB,MAAvB,EAAqC;AACrD,SAAK,SAAL,GAAiB,IAAjB;AACA,SAAK,eAAL,GAAuB,QAAvB;AACA,SAAK,aAAL,GAAqB,MAArB;AACA,SAAK,KAAL,GAAa,KAAK,CAAC,oBAAnB;AACH;;AAEO,EAAA,kBAAkB,CAAC,CAAD,EAAU;AAChC,QAAI,CAAC,KAAK,SAAS,CAAC,eAApB,EAAqC;AACjC,WAAK,KAAL,GAAa,KAAK,CAAC,iBAAnB;AACA,WAAK,YAAL,GAAoB,KAAK,KAAL,GAAa,CAAjC;AACH,KAHD,MAGO,IAAI,CAAC,KAAK,SAAS,CAAC,YAApB,EAAkC;AACrC,WAAK,KAAL,GAAa,KAAK,CAAC,uBAAnB;AACA,WAAK,YAAL,GAAoB,KAAK,KAAL,GAAa,CAAjC;AACH,KAHM,MAGA,IAAI,KAAK,cAAL,CAAoB,CAApB,CAAJ,EAA4B;AAC/B,YAAM,KAAK,GAAG,CAAC,GAAG,IAAlB;AACA,WAAK,YAAL,GAAoB,KAAK,KAAzB;;AACA,UAAI,CAAC,KAAK,OAAN,IAAiB,KAAK,KAAK,SAAS,CAAC,QAAV,CAAmB,CAAnB,CAA/B,EAAsD;AAClD,aAAK,YAAL,CAAkB,SAAS,CAAC,QAA5B,EAAsC,CAAtC;AACH,OAFD,MAEO;AACH,aAAK,KAAL,GACI,CAAC,KAAK,OAAN,IAAiB,KAAK,KAAK,SAAS,CAAC,SAAV,CAAoB,CAApB,CAA3B,GACM,KAAK,CAAC,cADZ,GAEM,KAAK,CAAC,SAHhB;AAIH;AACJ,KAXM,MAWA,IAAI,CAAC,KAAK,SAAS,CAAC,KAApB,EAA2B;AAC9B,WAAK,KAAL,GAAa,KAAK,CAAC,oBAAnB;AACH,KAFM,MAEA;AACH,WAAK,KAAL,GAAa,KAAK,CAAC,IAAnB;AACA,WAAK,SAAL,CAAe,CAAf;AACH;AACJ;;AACO,EAAA,cAAc,CAAC,CAAD,EAAU;AAC5B,QAAI,iBAAiB,CAAC,CAAD,CAArB,EAA0B;AACtB,WAAK,GAAL,CAAS,aAAT,CAAuB,KAAK,YAA5B,EAA0C,KAAK,KAA/C;AACA,WAAK,YAAL,GAAoB,CAAC,CAArB;AACA,WAAK,KAAL,GAAa,KAAK,CAAC,mBAAnB;AACA,WAAK,wBAAL,CAA8B,CAA9B;AACH;AACJ;;AACO,EAAA,yBAAyB,CAAC,CAAD,EAAU;AACvC,QAAI,YAAY,CAAC,CAAD,CAAhB,EAAqB,CACjB;AACH,KAFD,MAEO,IAAI,CAAC,KAAK,SAAS,CAAC,EAApB,EAAwB;AAC3B,WAAK,KAAL,GAAa,KAAK,CAAC,IAAnB;AACH,KAFM,MAEA;AACH,WAAK,KAAL,GAAa,KAAK,cAAL,CAAoB,CAApB,IACP,KAAK,CAAC,gBADC,GAEP,KAAK,CAAC,gBAFZ;AAGA,WAAK,YAAL,GAAoB,KAAK,KAAzB;AACH;AACJ;;AACO,EAAA,qBAAqB,CAAC,CAAD,EAAU;AACnC,QAAI,CAAC,KAAK,SAAS,CAAC,EAAhB,IAAsB,YAAY,CAAC,CAAD,CAAtC,EAA2C;AACvC,WAAK,GAAL,CAAS,UAAT,CAAoB,KAAK,YAAzB,EAAuC,KAAK,KAA5C;AACA,WAAK,YAAL,GAAoB,CAAC,CAArB;AACA,WAAK,KAAL,GAAa,KAAK,CAAC,mBAAnB;AACA,WAAK,wBAAL,CAA8B,CAA9B;AACH;AACJ;;AACO,EAAA,wBAAwB,CAAC,CAAD,EAAU;AACtC;AACA,QAAI,CAAC,KAAK,SAAS,CAAC,EAAhB,IAAsB,KAAK,aAAL,CAAmB,SAAS,CAAC,EAA7B,CAA1B,EAA4D;AACxD,WAAK,KAAL,GAAa,KAAK,CAAC,IAAnB;AACA,WAAK,YAAL,GAAoB,KAAK,KAAL,GAAa,CAAjC;AACH;AACJ;;AACO,EAAA,wBAAwB,CAAC,CAAD,EAAU;AACtC,QAAI,CAAC,KAAK,SAAS,CAAC,EAApB,EAAwB;AACpB,WAAK,GAAL,CAAS,YAAT,CAAsB,KAAK,KAA3B;;AACA,UAAI,KAAK,SAAT,EAAoB;AAChB,aAAK,KAAL,GAAa,KAAK,CAAC,YAAnB;AACA,aAAK,aAAL,GAAqB,CAArB;AACH,OAHD,MAGO;AACH,aAAK,KAAL,GAAa,KAAK,CAAC,IAAnB;AACH;;AACD,WAAK,SAAL,GAAiB,KAAK,KAAtB;AACA,WAAK,YAAL,GAAoB,KAAK,KAAL,GAAa,CAAjC;AACH,KAVD,MAUO,IAAI,CAAC,KAAK,SAAS,CAAC,KAApB,EAA2B;AAC9B,WAAK,KAAL,GAAa,KAAK,CAAC,gBAAnB;AACH,KAFM,MAEA,IAAI,CAAC,YAAY,CAAC,CAAD,CAAjB,EAAsB;AACzB,WAAK,KAAL,GAAa,KAAK,CAAC,eAAnB;AACA,WAAK,YAAL,GAAoB,KAAK,KAAzB;AACH;AACJ;;AACO,EAAA,qBAAqB,CAAC,CAAD,EAAU;AACnC,QAAI,CAAC,KAAK,SAAS,CAAC,EAApB,EAAwB;AACpB,WAAK,GAAL,CAAS,gBAAT,CAA0B,KAAK,KAA/B;AACA,WAAK,KAAL,GAAa,KAAK,CAAC,IAAnB;AACA,WAAK,SAAL,GAAiB,KAAK,CAAC,IAAvB;AACA,WAAK,YAAL,GAAoB,KAAK,KAAL,GAAa,CAAjC;AACA,WAAK,SAAL,GAAiB,KAAjB,CALoB,CAKI;AAC3B,KAND,MAMO,IAAI,CAAC,YAAY,CAAC,CAAD,CAAjB,EAAsB;AACzB,WAAK,KAAL,GAAa,KAAK,CAAC,mBAAnB;AACA,WAAK,wBAAL,CAA8B,CAA9B;AACH;AACJ;;AACO,EAAA,oBAAoB,CAAC,CAAD,EAAU;AAClC,QAAI,CAAC,KAAK,SAAS,CAAC,EAAhB,IAAsB,iBAAiB,CAAC,CAAD,CAA3C,EAAgD;AAC5C,WAAK,GAAL,CAAS,YAAT,CAAsB,KAAK,YAA3B,EAAyC,KAAK,KAA9C;AACA,WAAK,YAAL,GAAoB,CAAC,CAArB;AACA,WAAK,KAAL,GAAa,KAAK,CAAC,kBAAnB;AACA,WAAK,uBAAL,CAA6B,CAA7B;AACH;AACJ;;AACO,EAAA,uBAAuB,CAAC,CAAD,EAAU;AACrC,QAAI,CAAC,KAAK,SAAS,CAAC,EAApB,EAAwB;AACpB,WAAK,KAAL,GAAa,KAAK,CAAC,oBAAnB;AACH,KAFD,MAEO,IAAI,CAAC,KAAK,SAAS,CAAC,KAAhB,IAAyB,CAAC,KAAK,SAAS,CAAC,EAA7C,EAAiD;AACpD,WAAK,GAAL,CAAS,WAAT,CAAqB,SAAS,CAAC,OAA/B,EAAwC,KAAK,KAA7C;AACA,WAAK,KAAL,GAAa,KAAK,CAAC,mBAAnB;AACA,WAAK,wBAAL,CAA8B,CAA9B;AACH,KAJM,MAIA,IAAI,CAAC,YAAY,CAAC,CAAD,CAAjB,EAAsB;AACzB,WAAK,GAAL,CAAS,WAAT,CAAqB,SAAS,CAAC,OAA/B,EAAwC,KAAK,KAA7C;AACA,WAAK,KAAL,GAAa,KAAK,CAAC,eAAnB;AACA,WAAK,YAAL,GAAoB,KAAK,KAAzB;AACH;AACJ;;AACO,EAAA,yBAAyB,CAAC,CAAD,EAAU;AACvC,QAAI,CAAC,KAAK,SAAS,CAAC,WAApB,EAAiC;AAC7B,WAAK,KAAL,GAAa,KAAK,CAAC,kBAAnB;AACA,WAAK,YAAL,GAAoB,KAAK,KAAL,GAAa,CAAjC;AACH,KAHD,MAGO,IAAI,CAAC,KAAK,SAAS,CAAC,WAApB,EAAiC;AACpC,WAAK,KAAL,GAAa,KAAK,CAAC,kBAAnB;AACA,WAAK,YAAL,GAAoB,KAAK,KAAL,GAAa,CAAjC;AACH,KAHM,MAGA,IAAI,CAAC,YAAY,CAAC,CAAD,CAAjB,EAAsB;AACzB,WAAK,YAAL,GAAoB,KAAK,KAAzB;AACA,WAAK,KAAL,GAAa,KAAK,CAAC,kBAAnB;AACA,WAAK,6BAAL,CAAmC,CAAnC,EAHyB,CAGc;AAC1C;AACJ;;AACO,EAAA,sBAAsB,CAAC,CAAD,EAAY,KAAZ,EAAyB;AACnD,QACI,CAAC,KAAK,KAAN,IACC,CAAC,KAAK,cAAN,IAAwB,KAAK,aAAL,CAAmB,KAAnB,CAF7B,EAGE;AACE,WAAK,GAAL,CAAS,YAAT,CAAsB,KAAK,YAA3B,EAAyC,KAAK,KAA9C;AACA,WAAK,YAAL,GAAoB,CAAC,CAArB;AACA,WAAK,GAAL,CAAS,WAAT,CACI,KAAK,KAAK,SAAS,CAAC,WAApB,GACM,SAAS,CAAC,MADhB,GAEM,SAAS,CAAC,MAHpB,EAII,KAAK,KAJT;AAMA,WAAK,KAAL,GAAa,KAAK,CAAC,mBAAnB;AACH,KAbD,MAaO,IAAI,KAAK,cAAL,IAAuB,CAAC,KAAK,SAAS,CAAC,GAA3C,EAAgD;AACnD,WAAK,SAAL,GAAiB,KAAK,KAAtB;AACA,WAAK,KAAL,GAAa,KAAK,CAAC,YAAnB;AACH;AACJ;;AACO,EAAA,iCAAiC,CAAC,CAAD,EAAU;AAC/C,SAAK,sBAAL,CAA4B,CAA5B,EAA+B,SAAS,CAAC,WAAzC;AACH;;AACO,EAAA,iCAAiC,CAAC,CAAD,EAAU;AAC/C,SAAK,sBAAL,CAA4B,CAA5B,EAA+B,SAAS,CAAC,WAAzC;AACH;;AACO,EAAA,6BAA6B,CAAC,CAAD,EAAU;AAC3C,QAAI,YAAY,CAAC,CAAD,CAAZ,IAAmB,CAAC,KAAK,SAAS,CAAC,EAAvC,EAA2C;AACvC,WAAK,GAAL,CAAS,YAAT,CAAsB,KAAK,YAA3B,EAAyC,KAAK,KAA9C;AACA,WAAK,YAAL,GAAoB,CAAC,CAArB;AACA,WAAK,GAAL,CAAS,WAAT,CAAqB,SAAS,CAAC,QAA/B,EAAyC,KAAK,KAA9C;AACA,WAAK,KAAL,GAAa,KAAK,CAAC,mBAAnB;AACA,WAAK,wBAAL,CAA8B,CAA9B;AACH,KAND,MAMO,IAAI,KAAK,cAAL,IAAuB,CAAC,KAAK,SAAS,CAAC,GAA3C,EAAgD;AACnD,WAAK,SAAL,GAAiB,KAAK,KAAtB;AACA,WAAK,KAAL,GAAa,KAAK,CAAC,YAAnB;AACH;AACJ;;AACO,EAAA,sBAAsB,CAAC,CAAD,EAAU;AACpC,QAAI,CAAC,KAAK,SAAS,CAAC,oBAApB,EAA0C;AACtC,WAAK,KAAL,GAAa,KAAK,CAAC,aAAnB;AACA,WAAK,aAAL,GAAqB,CAArB;AACH,KAHD,MAGO;AACH,WAAK,KAAL,GACI,CAAC,KAAK,SAAS,CAAC,IAAhB,GACM,KAAK,CAAC,aADZ,GAEM,KAAK,CAAC,aAHhB;AAIH;AACJ;;AACO,EAAA,kBAAkB,CAAC,CAAD,EAAU;AAChC,QAAI,CAAC,KAAK,SAAS,CAAC,EAAhB,IAAsB,KAAK,aAAL,CAAmB,SAAS,CAAC,EAA7B,CAA1B,EAA4D;AACxD,WAAK,GAAL,CAAS,aAAT,CAAuB,KAAK,YAA5B,EAA0C,KAAK,KAA/C;AACA,WAAK,KAAL,GAAa,KAAK,CAAC,IAAnB;AACA,WAAK,YAAL,GAAoB,KAAK,KAAL,GAAa,CAAjC;AACH;AACJ;;AACO,EAAA,4BAA4B,CAAC,CAAD,EAAU;AAC1C,QAAI,CAAC,KAAK,SAAS,CAAC,EAAhB,IAAsB,KAAK,aAAL,CAAmB,SAAS,CAAC,EAA7B,CAA1B,EAA4D;AACxD,WAAK,GAAL,CAAS,uBAAT,CAAiC,KAAK,YAAtC,EAAoD,KAAK,KAAzD;AACA,WAAK,KAAL,GAAa,KAAK,CAAC,IAAnB;AACA,WAAK,YAAL,GAAoB,KAAK,KAAL,GAAa,CAAjC;AACH;AACJ;;AACO,EAAA,kBAAkB,CAAC,CAAD,EAAU;AAChC,QAAI,CAAC,KAAK,SAAS,CAAC,IAApB,EAA0B;AACtB,WAAK,KAAL,GAAa,KAAK,CAAC,aAAnB;AACA,WAAK,eAAL,GAAuB,SAAS,CAAC,UAAjC,CAFsB,CAGtB;;AACA,WAAK,aAAL,GAAqB,CAArB;AACA,WAAK,YAAL,GAAoB,KAAK,KAAL,GAAa,CAAjC;AACH,KAND,MAMO;AACH,WAAK,KAAL,GAAa,KAAK,CAAC,aAAnB;AACH;AACJ;;AACO,EAAA,qBAAqB,CAAC,CAAD,EAAU;AACnC,QAAI,CAAC,KAAK,SAAS,CAAC,EAAhB,IAAsB,KAAK,aAAL,CAAmB,SAAS,CAAC,EAA7B,CAA1B,EAA4D;AACxD,WAAK,GAAL,CAAS,SAAT,CAAmB,KAAK,YAAxB,EAAsC,KAAK,KAA3C,EAAkD,CAAlD;AACA,WAAK,KAAL,GAAa,KAAK,CAAC,IAAnB;AACA,WAAK,YAAL,GAAoB,KAAK,KAAL,GAAa,CAAjC;AACH;AACJ;;AACO,EAAA,mBAAmB,CAAC,CAAD,EAAU;AACjC,UAAM,KAAK,GAAG,CAAC,GAAG,IAAlB;;AACA,QAAI,KAAK,KAAK,SAAS,CAAC,SAAV,CAAoB,CAApB,CAAd,EAAsC;AAClC,WAAK,YAAL,CAAkB,SAAS,CAAC,SAA5B,EAAuC,CAAvC;AACH,KAFD,MAEO,IAAI,KAAK,KAAK,SAAS,CAAC,QAAV,CAAmB,CAAnB,CAAd,EAAqC;AACxC,WAAK,YAAL,CAAkB,SAAS,CAAC,QAA5B,EAAsC,CAAtC;AACH,KAFM,MAEA;AACH,WAAK,KAAL,GAAa,KAAK,CAAC,SAAnB;AACA,WAAK,cAAL,CAAoB,CAApB,EAFG,CAEqB;AAC3B;AACJ;;AAQO,EAAA,iBAAiB,CAAC,CAAD,EAAU;AAC/B;AACA,SAAK,YAAL,GAAoB,CAApB;AACA,SAAK,YAAL,GAAoB,CAApB;;AAEA,QAAI,CAAC,KAAK,SAAS,CAAC,GAApB,EAAyB;AACrB,WAAK,KAAL,GAAa,KAAK,CAAC,mBAAnB;AACH,KAFD,MAEO,IAAI,CAAC,KAAK,SAAS,CAAC,GAApB,EAAyB,CAC5B;AACH,KAFM,MAEA;AACH,WAAK,SAAL,GAAiB,CAAjB;AACA,WAAK,WAAL,GAAmB,KAAK,UAAL,CAAgB,CAAhB,CAAnB;AACA,WAAK,KAAL,GAAa,KAAK,CAAC,aAAnB;AACA,WAAK,kBAAL,CAAwB,CAAxB;AACH;AACJ;;AAEO,EAAA,kBAAkB,CAAC,CAAD,EAAU;AAChC,SAAK,YAAL,IAAqB,CAArB;AAEA,SAAK,SAAL,GAAiB,eAAe,CAC5B,KAAK,UADuB,EAE5B,KAAK,WAFuB,EAG5B,KAAK,SAAL,GAAiB,CAHW,EAI5B,CAJ4B,CAAhC;;AAOA,QAAI,KAAK,SAAL,GAAiB,CAArB,EAAwB;AACpB,WAAK,eAAL;AACA,WAAK,KAAL;AACA;AACH;;AAED,SAAK,WAAL,GAAmB,KAAK,UAAL,CAAgB,KAAK,SAArB,CAAnB;AAEA,UAAM,MAAM,GAAG,KAAK,WAAL,GAAmB,YAAY,CAAC,YAA/C,CAlBgC,CAoBhC;;AACA,QAAI,MAAJ,EAAY;AACR;AACA,YAAM,WAAW,GAAG,CAAC,MAAM,IAAI,EAAX,IAAiB,CAArC,CAFQ,CAIR;;AACA,UAAI,CAAC,KAAK,iBAAL,EAAD,IAA6B,CAAC,KAAK,SAAS,CAAC,IAAjD,EAAuD;AACnD,aAAK,SAAL,IAAkB,WAAlB;AACH,OAFD,MAEO;AACH;AACA,cAAM,WAAW,GAAG,KAAK,KAAL,GAAa,KAAK,YAAlB,GAAiC,CAArD;;AAEA,YAAI,WAAW,GAAG,KAAK,YAAvB,EAAqC;AACjC,eAAK,WAAL,CAAiB,KAAK,YAAtB,EAAoC,WAApC;AACH,SANE,CAQH;;;AACA,aAAK,YAAL,GAAoB,KAAK,SAAzB;AACA,aAAK,SAAL,IAAkB,WAAlB;AACA,aAAK,YAAL,GAAoB,CAApB;AACA,aAAK,YAAL,GAAoB,KAAK,KAAL,GAAa,CAAjC;;AAEA,YAAI,WAAW,KAAK,CAApB,EAAuB;AACnB,eAAK,eAAL;AACH;AACJ;AACJ;AACJ;;AAEO,EAAA,eAAe,GAAA;AACnB,SAAK,KAAL,GAAa,KAAK,SAAlB;;AAEA,QAAI,KAAK,YAAL,KAAsB,CAA1B,EAA6B;AACzB;AACH;;AAED,UAAM,WAAW,GACb,CAAC,KAAK,UAAL,CAAgB,KAAK,YAArB,IAAqC,YAAY,CAAC,YAAnD,KACA,EAFJ;;AAIA,YAAQ,WAAR;AACI,WAAK,CAAL;AACI,aAAK,aAAL,CACI,KAAK,UAAL,CAAgB,KAAK,YAArB,IACI,CAAC,YAAY,CAAC,YAFtB;AAIA;;AACJ,WAAK,CAAL;AACI,aAAK,aAAL,CAAmB,KAAK,UAAL,CAAgB,KAAK,YAAL,GAAoB,CAApC,CAAnB;AACA;;AACJ,WAAK,CAAL;AAAQ;AACJ,eAAK,aAAL,CAAmB,KAAK,UAAL,CAAgB,KAAK,YAAL,GAAoB,CAApC,CAAnB;AACA,eAAK,aAAL,CAAmB,KAAK,UAAL,CAAgB,KAAK,YAAL,GAAoB,CAApC,CAAnB;AACH;AAbL;AAeH;;AAEO,EAAA,wBAAwB,CAAC,CAAD,EAAU;AACtC,QAAI,CAAC,CAAC,GAAG,IAAL,MAAe,SAAS,CAAC,MAA7B,EAAqC;AACjC,WAAK,YAAL;AACA,WAAK,KAAL,GAAa,KAAK,CAAC,WAAnB;AACH,KAHD,MAGO;AACH,WAAK,KAAL,GAAa,KAAK,CAAC,eAAnB;AACA,WAAK,oBAAL,CAA0B,CAA1B;AACH;AACJ;;AAEO,EAAA,iBAAiB,CAAC,MAAD,EAAgB;AACrC,UAAM,WAAW,GAAG,KAAK,KAAL,GAAa,KAAK,YAAlB,GAAiC,CAArD;AACA,UAAM,WAAW,GACb,WAAW,GAAG,CAAd,GAAkB,MAAM,CAAC,KAAK,KAAL,KAAe,KAAK,CAAC,WAAtB,CAD5B;;AAGA,QAAI,WAAW,KAAK,KAAK,KAAzB,EAAgC;AAC5B;AACA,UAAI,WAAW,GAAG,KAAK,YAAvB,EAAqC;AACjC,aAAK,WAAL,CAAiB,KAAK,YAAtB,EAAoC,WAApC;AACH;;AAED,WAAK,YAAL,GAAoB,KAAK,KAAL,GAAa,MAAM,CAAC,MAAD,CAAvC;AACA,WAAK,aAAL,CAAmB,gBAAgB,CAAC,KAAK,YAAN,CAAnC;AACH;;AACD,SAAK,KAAL,GAAa,KAAK,SAAlB;AACH;;AACO,EAAA,oBAAoB,CAAC,CAAD,EAAU;AAClC,QAAI,CAAC,KAAK,SAAS,CAAC,IAApB,EAA0B;AACtB,WAAK,iBAAL,CAAuB,IAAvB;AACH,KAFD,MAEO,IAAI,QAAQ,CAAC,CAAD,CAAZ,EAAiB;AACpB,WAAK,YAAL,GAAoB,KAAK,YAAL,GAAoB,EAApB,IAA0B,CAAC,GAAG,SAAS,CAAC,IAAxC,CAApB;AACA,WAAK,YAAL;AACH,KAHM,MAGA;AACH,UAAI,KAAK,iBAAL,EAAJ,EAA8B;AAC1B,aAAK,iBAAL,CAAuB,KAAvB;AACH,OAFD,MAEO;AACH,aAAK,KAAL,GAAa,KAAK,SAAlB;AACH;;AACD,WAAK,KAAL;AACH;AACJ;;AACO,EAAA,gBAAgB,CAAC,CAAD,EAAU;AAC9B,QAAI,CAAC,KAAK,SAAS,CAAC,IAApB,EAA0B;AACtB,WAAK,iBAAL,CAAuB,IAAvB;AACH,KAFD,MAEO,IAAI,QAAQ,CAAC,CAAD,CAAZ,EAAiB;AACpB,WAAK,YAAL,GAAoB,KAAK,YAAL,GAAoB,EAApB,IAA0B,CAAC,GAAG,SAAS,CAAC,IAAxC,CAApB;AACA,WAAK,YAAL;AACH,KAHM,MAGA,IAAI,UAAU,CAAC,CAAD,CAAd,EAAmB;AACtB,WAAK,YAAL,GACI,KAAK,YAAL,GAAoB,EAApB,IAA0B,CAAC,CAAC,GAAG,IAAL,IAAa,SAAS,CAAC,MAAvB,GAAgC,EAA1D,CADJ;AAEA,WAAK,YAAL;AACH,KAJM,MAIA;AACH,UAAI,KAAK,iBAAL,EAAJ,EAA8B;AAC1B,aAAK,iBAAL,CAAuB,KAAvB;AACH,OAFD,MAEO;AACH,aAAK,KAAL,GAAa,KAAK,SAAlB;AACH;;AACD,WAAK,KAAL;AACH;AACJ;;AAEO,EAAA,iBAAiB,GAAA;AACrB,WACI,CAAC,KAAK,OAAN,KACC,KAAK,SAAL,KAAmB,KAAK,CAAC,IAAzB,IACG,KAAK,SAAL,KAAmB,KAAK,CAAC,YAF7B,CADJ;AAKH;AAED;;AAEG;;;AACK,EAAA,OAAO,GAAA;AACX;AACA,QAAI,KAAK,OAAL,IAAgB,KAAK,YAAL,KAAsB,KAAK,KAA/C,EAAsD;AAClD,UACI,KAAK,KAAL,KAAe,KAAK,CAAC,IAArB,IACC,KAAK,KAAL,KAAe,KAAK,CAAC,YAArB,IAAqC,KAAK,aAAL,KAAuB,CAFjE,EAGE;AACE,aAAK,GAAL,CAAS,MAAT,CAAgB,KAAK,YAArB,EAAmC,KAAK,KAAxC;AACA,aAAK,YAAL,GAAoB,KAAK,KAAzB;AACH,OAND,MAMO,IACH,KAAK,KAAL,KAAe,KAAK,CAAC,kBAArB,IACA,KAAK,KAAL,KAAe,KAAK,CAAC,kBADrB,IAEA,KAAK,KAAL,KAAe,KAAK,CAAC,kBAHlB,EAIL;AACE,aAAK,GAAL,CAAS,YAAT,CAAsB,KAAK,YAA3B,EAAyC,KAAK,KAA9C;AACA,aAAK,YAAL,GAAoB,KAAK,KAAzB;AACH;AACJ;AACJ;;AAEO,EAAA,cAAc,GAAA;AAClB,WAAO,KAAK,KAAL,GAAa,KAAK,MAAL,CAAY,MAAZ,GAAqB,KAAK,MAAvC,IAAiD,KAAK,OAA7D;AACH;AAED;;;;AAIG;;;AACK,EAAA,KAAK,GAAA;AACT,WAAO,KAAK,cAAL,EAAP,EAA8B;AAC1B,YAAM,CAAC,GAAG,KAAK,MAAL,CAAY,UAAZ,CAAuB,KAAK,KAAL,GAAa,KAAK,MAAzC,CAAV;;AACA,UAAI,KAAK,KAAL,KAAe,KAAK,CAAC,IAAzB,EAA+B;AAC3B,aAAK,SAAL,CAAe,CAAf;AACH,OAFD,MAEO,IAAI,KAAK,KAAL,KAAe,KAAK,CAAC,oBAAzB,EAA+C;AAClD,aAAK,yBAAL,CAA+B,CAA/B;AACH,OAFM,MAEA,IAAI,KAAK,KAAL,KAAe,KAAK,CAAC,YAAzB,EAAuC;AAC1C,aAAK,iBAAL,CAAuB,CAAvB;AACH,OAFM,MAEA,IAAI,KAAK,KAAL,KAAe,KAAK,CAAC,aAAzB,EAAwC;AAC3C,aAAK,kBAAL,CAAwB,CAAxB;AACH,OAFM,MAEA,IAAI,KAAK,KAAL,KAAe,KAAK,CAAC,kBAAzB,EAA6C;AAChD,aAAK,iCAAL,CAAuC,CAAvC;AACH,OAFM,MAEA,IAAI,KAAK,KAAL,KAAe,KAAK,CAAC,eAAzB,EAA0C;AAC7C,aAAK,oBAAL,CAA0B,CAA1B;AACH,OAFM,MAEA,IAAI,KAAK,KAAL,KAAe,KAAK,CAAC,aAAzB,EAAwC;AAC3C,aAAK,kBAAL,CAAwB,CAAxB;AACH,OAFM,MAEA,IAAI,KAAK,KAAL,KAAe,KAAK,CAAC,gBAAzB,EAA2C;AAC9C,aAAK,qBAAL,CAA2B,CAA3B;AACH,OAFM,MAEA,IAAI,KAAK,KAAL,KAAe,KAAK,CAAC,mBAAzB,EAA8C;AACjD,aAAK,wBAAL,CAA8B,CAA9B;AACH,OAFM,MAEA,IAAI,KAAK,KAAL,KAAe,KAAK,CAAC,SAAzB,EAAoC;AACvC,aAAK,cAAL,CAAoB,CAApB;AACH,OAFM,MAEA,IAAI,KAAK,KAAL,KAAe,KAAK,CAAC,gBAAzB,EAA2C;AAC9C,aAAK,qBAAL,CAA2B,CAA3B;AACH,OAFM,MAEA,IAAI,KAAK,KAAL,KAAe,KAAK,CAAC,aAAzB,EAAwC;AAC3C,aAAK,kBAAL,CAAwB,CAAxB;AACH,OAFM,MAEA,IAAI,KAAK,KAAL,KAAe,KAAK,CAAC,kBAAzB,EAA6C;AAChD,aAAK,uBAAL,CAA6B,CAA7B;AACH,OAFM,MAEA,IAAI,KAAK,KAAL,KAAe,KAAK,CAAC,kBAAzB,EAA6C;AAChD,aAAK,iCAAL,CAAuC,CAAvC;AACH,OAFM,MAEA,IAAI,KAAK,KAAL,KAAe,KAAK,CAAC,oBAAzB,EAA+C;AAClD,aAAK,yBAAL,CAA+B,CAA/B;AACH,OAFM,MAEA,IAAI,KAAK,KAAL,KAAe,KAAK,CAAC,oBAAzB,EAA+C;AAClD,aAAK,yBAAL,CAA+B,CAA/B;AACH,OAFM,MAEA,IAAI,KAAK,KAAL,KAAe,KAAK,CAAC,mBAAzB,EAA8C;AACjD,aAAK,wBAAL,CAA8B,CAA9B;AACH,OAFM,MAEA,IAAI,KAAK,KAAL,KAAe,KAAK,CAAC,cAAzB,EAAyC;AAC5C,aAAK,mBAAL,CAAyB,CAAzB;AACH,OAFM,MAEA,IAAI,KAAK,KAAL,KAAe,KAAK,CAAC,kBAAzB,EAA6C;AAChD,aAAK,6BAAL,CAAmC,CAAnC;AACH,OAFM,MAEA,IAAI,KAAK,KAAL,KAAe,KAAK,CAAC,gBAAzB,EAA2C;AAC9C,aAAK,qBAAL,CAA2B,CAA3B;AACH,OAFM,MAEA,IAAI,KAAK,KAAL,KAAe,KAAK,CAAC,aAAzB,EAAwC;AAC3C,aAAK,kBAAL,CAAwB,CAAxB;AACH,OAFM,MAEA,IAAI,KAAK,KAAL,KAAe,KAAK,CAAC,iBAAzB,EAA4C;AAC/C,aAAK,sBAAL,CAA4B,CAA5B;AACH,OAFM,MAEA,IAAI,KAAK,KAAL,KAAe,KAAK,CAAC,aAAzB,EAAwC;AAC3C,aAAK,kBAAL,CAAwB,CAAxB;AACH,OAFM,MAEA,IAAI,KAAK,KAAL,KAAe,KAAK,CAAC,uBAAzB,EAAkD;AACrD,aAAK,4BAAL,CAAkC,CAAlC;AACH,OAFM,MAEA,IAAI,KAAK,KAAL,KAAe,KAAK,CAAC,aAAzB,EAAwC;AAC3C,aAAK,kBAAL,CAAwB,CAAxB;AACH,OAFM,MAEA,IAAI,KAAK,KAAL,KAAe,KAAK,CAAC,YAAzB,EAAuC;AAC1C,aAAK,iBAAL,CAAuB,CAAvB;AACH,OAFM,MAEA,IAAI,KAAK,KAAL,KAAe,KAAK,CAAC,WAAzB,EAAsC;AACzC,aAAK,gBAAL,CAAsB,CAAtB;AACH,OAFM,MAEA,IAAI,KAAK,KAAL,KAAe,KAAK,CAAC,eAAzB,EAA0C;AAC7C,aAAK,oBAAL,CAA0B,CAA1B;AACH,OAFM,MAEA;AACH;AACA,aAAK,wBAAL,CAA8B,CAA9B;AACH;;AACD,WAAK,KAAL;AACH;;AACD,SAAK,OAAL;AACH;;AAEO,EAAA,MAAM,GAAA;AACV,QAAI,KAAK,KAAL,KAAe,KAAK,CAAC,aAAzB,EAAwC;AACpC,WAAK,eAAL;AACH,KAHS,CAKV;;;AACA,QAAI,KAAK,YAAL,GAAoB,KAAK,KAA7B,EAAoC;AAChC,WAAK,kBAAL;AACH;;AACD,SAAK,GAAL,CAAS,KAAT;AACH;AAED;;;AACQ,EAAA,kBAAkB,GAAA;AACtB,UAAM,QAAQ,GAAG,KAAK,MAAL,CAAY,MAAZ,GAAqB,KAAK,MAA3C;;AACA,QAAI,KAAK,KAAL,KAAe,KAAK,CAAC,aAAzB,EAAwC;AACpC,UAAI,KAAK,eAAL,KAAyB,SAAS,CAAC,QAAvC,EAAiD;AAC7C,aAAK,GAAL,CAAS,OAAT,CAAiB,KAAK,YAAtB,EAAoC,QAApC,EAA8C,CAA9C;AACH,OAFD,MAEO;AACH,aAAK,GAAL,CAAS,SAAT,CAAmB,KAAK,YAAxB,EAAsC,QAAtC,EAAgD,CAAhD;AACH;AACJ,KAND,MAMO,IACH,KAAK,KAAL,KAAe,KAAK,CAAC,eAArB,IACA,KAAK,iBAAL,EAFG,EAGL;AACE,WAAK,iBAAL,CAAuB,KAAvB,EADF,CAEE;AACH,KANM,MAMA,IACH,KAAK,KAAL,KAAe,KAAK,CAAC,WAArB,IACA,KAAK,iBAAL,EAFG,EAGL;AACE,WAAK,iBAAL,CAAuB,KAAvB,EADF,CAEE;AACH,KANM,MAMA,IACH,KAAK,KAAL,KAAe,KAAK,CAAC,SAArB,IACA,KAAK,KAAL,KAAe,KAAK,CAAC,mBADrB,IAEA,KAAK,KAAL,KAAe,KAAK,CAAC,oBAFrB,IAGA,KAAK,KAAL,KAAe,KAAK,CAAC,kBAHrB,IAIA,KAAK,KAAL,KAAe,KAAK,CAAC,eAJrB,IAKA,KAAK,KAAL,KAAe,KAAK,CAAC,kBALrB,IAMA,KAAK,KAAL,KAAe,KAAK,CAAC,kBANrB,IAOA,KAAK,KAAL,KAAe,KAAK,CAAC,kBAPrB,IAQA,KAAK,KAAL,KAAe,KAAK,CAAC,gBATlB,EAUL;AACE;;;AAGG;AACN,KAfM,MAeA;AACH,WAAK,GAAL,CAAS,MAAT,CAAgB,KAAK,YAArB,EAAmC,QAAnC;AACH;AACJ;;AAEO,EAAA,WAAW,CAAC,KAAD,EAAgB,QAAhB,EAAgC;AAC/C,QACI,KAAK,SAAL,KAAmB,KAAK,CAAC,IAAzB,IACA,KAAK,SAAL,KAAmB,KAAK,CAAC,YAF7B,EAGE;AACE,WAAK,GAAL,CAAS,YAAT,CAAsB,KAAtB,EAA6B,QAA7B;AACH,KALD,MAKO;AACH,WAAK,GAAL,CAAS,MAAT,CAAgB,KAAhB,EAAuB,QAAvB;AACH;AACJ;;AACO,EAAA,aAAa,CAAC,EAAD,EAAW;AAC5B,QACI,KAAK,SAAL,KAAmB,KAAK,CAAC,IAAzB,IACA,KAAK,SAAL,KAAmB,KAAK,CAAC,YAF7B,EAGE;AACE,WAAK,GAAL,CAAS,cAAT,CAAwB,EAAxB;AACH,KALD,MAKO;AACH,WAAK,GAAL,CAAS,YAAT,CAAsB,EAAtB;AACH;AACJ;;AAnyByB","sourceRoot":"https://raw.githubusercontent.com/fb55/htmlparser2/4763205746cd80120b5d2b69041197a394d24ba9/src/","sourcesContent":["import { htmlDecodeTree, xmlDecodeTree, BinTrieFlags, determineBranch, replaceCodePoint, } from \"entities/lib/decode.js\";\nvar CharCodes;\n(function (CharCodes) {\n    CharCodes[CharCodes[\"Tab\"] = 9] = \"Tab\";\n    CharCodes[CharCodes[\"NewLine\"] = 10] = \"NewLine\";\n    CharCodes[CharCodes[\"FormFeed\"] = 12] = \"FormFeed\";\n    CharCodes[CharCodes[\"CarriageReturn\"] = 13] = \"CarriageReturn\";\n    CharCodes[CharCodes[\"Space\"] = 32] = \"Space\";\n    CharCodes[CharCodes[\"ExclamationMark\"] = 33] = \"ExclamationMark\";\n    CharCodes[CharCodes[\"Num\"] = 35] = \"Num\";\n    CharCodes[CharCodes[\"Amp\"] = 38] = \"Amp\";\n    CharCodes[CharCodes[\"SingleQuote\"] = 39] = \"SingleQuote\";\n    CharCodes[CharCodes[\"DoubleQuote\"] = 34] = \"DoubleQuote\";\n    CharCodes[CharCodes[\"Dash\"] = 45] = \"Dash\";\n    CharCodes[CharCodes[\"Slash\"] = 47] = \"Slash\";\n    CharCodes[CharCodes[\"Zero\"] = 48] = \"Zero\";\n    CharCodes[CharCodes[\"Nine\"] = 57] = \"Nine\";\n    CharCodes[CharCodes[\"Semi\"] = 59] = \"Semi\";\n    CharCodes[CharCodes[\"Lt\"] = 60] = \"Lt\";\n    CharCodes[CharCodes[\"Eq\"] = 61] = \"Eq\";\n    CharCodes[CharCodes[\"Gt\"] = 62] = \"Gt\";\n    CharCodes[CharCodes[\"Questionmark\"] = 63] = \"Questionmark\";\n    CharCodes[CharCodes[\"UpperA\"] = 65] = \"UpperA\";\n    CharCodes[CharCodes[\"LowerA\"] = 97] = \"LowerA\";\n    CharCodes[CharCodes[\"UpperF\"] = 70] = \"UpperF\";\n    CharCodes[CharCodes[\"LowerF\"] = 102] = \"LowerF\";\n    CharCodes[CharCodes[\"UpperZ\"] = 90] = \"UpperZ\";\n    CharCodes[CharCodes[\"LowerZ\"] = 122] = \"LowerZ\";\n    CharCodes[CharCodes[\"LowerX\"] = 120] = \"LowerX\";\n    CharCodes[CharCodes[\"OpeningSquareBracket\"] = 91] = \"OpeningSquareBracket\";\n})(CharCodes || (CharCodes = {}));\n/** All the states the tokenizer can be in. */\nvar State;\n(function (State) {\n    State[State[\"Text\"] = 1] = \"Text\";\n    State[State[\"BeforeTagName\"] = 2] = \"BeforeTagName\";\n    State[State[\"InTagName\"] = 3] = \"InTagName\";\n    State[State[\"InSelfClosingTag\"] = 4] = \"InSelfClosingTag\";\n    State[State[\"BeforeClosingTagName\"] = 5] = \"BeforeClosingTagName\";\n    State[State[\"InClosingTagName\"] = 6] = \"InClosingTagName\";\n    State[State[\"AfterClosingTagName\"] = 7] = \"AfterClosingTagName\";\n    // Attributes\n    State[State[\"BeforeAttributeName\"] = 8] = \"BeforeAttributeName\";\n    State[State[\"InAttributeName\"] = 9] = \"InAttributeName\";\n    State[State[\"AfterAttributeName\"] = 10] = \"AfterAttributeName\";\n    State[State[\"BeforeAttributeValue\"] = 11] = \"BeforeAttributeValue\";\n    State[State[\"InAttributeValueDq\"] = 12] = \"InAttributeValueDq\";\n    State[State[\"InAttributeValueSq\"] = 13] = \"InAttributeValueSq\";\n    State[State[\"InAttributeValueNq\"] = 14] = \"InAttributeValueNq\";\n    // Declarations\n    State[State[\"BeforeDeclaration\"] = 15] = \"BeforeDeclaration\";\n    State[State[\"InDeclaration\"] = 16] = \"InDeclaration\";\n    // Processing instructions\n    State[State[\"InProcessingInstruction\"] = 17] = \"InProcessingInstruction\";\n    // Comments & CDATA\n    State[State[\"BeforeComment\"] = 18] = \"BeforeComment\";\n    State[State[\"CDATASequence\"] = 19] = \"CDATASequence\";\n    State[State[\"InSpecialComment\"] = 20] = \"InSpecialComment\";\n    State[State[\"InCommentLike\"] = 21] = \"InCommentLike\";\n    // Special tags\n    State[State[\"BeforeSpecialS\"] = 22] = \"BeforeSpecialS\";\n    State[State[\"SpecialStartSequence\"] = 23] = \"SpecialStartSequence\";\n    State[State[\"InSpecialTag\"] = 24] = \"InSpecialTag\";\n    State[State[\"BeforeEntity\"] = 25] = \"BeforeEntity\";\n    State[State[\"BeforeNumericEntity\"] = 26] = \"BeforeNumericEntity\";\n    State[State[\"InNamedEntity\"] = 27] = \"InNamedEntity\";\n    State[State[\"InNumericEntity\"] = 28] = \"InNumericEntity\";\n    State[State[\"InHexEntity\"] = 29] = \"InHexEntity\";\n})(State || (State = {}));\nfunction isWhitespace(c) {\n    return (c === CharCodes.Space ||\n        c === CharCodes.NewLine ||\n        c === CharCodes.Tab ||\n        c === CharCodes.FormFeed ||\n        c === CharCodes.CarriageReturn);\n}\nfunction isEndOfTagSection(c) {\n    return c === CharCodes.Slash || c === CharCodes.Gt || isWhitespace(c);\n}\nfunction isNumber(c) {\n    return c >= CharCodes.Zero && c <= CharCodes.Nine;\n}\nfunction isASCIIAlpha(c) {\n    return ((c >= CharCodes.LowerA && c <= CharCodes.LowerZ) ||\n        (c >= CharCodes.UpperA && c <= CharCodes.UpperZ));\n}\nfunction isHexDigit(c) {\n    return ((c >= CharCodes.UpperA && c <= CharCodes.UpperF) ||\n        (c >= CharCodes.LowerA && c <= CharCodes.LowerF));\n}\nexport var QuoteType;\n(function (QuoteType) {\n    QuoteType[QuoteType[\"NoValue\"] = 0] = \"NoValue\";\n    QuoteType[QuoteType[\"Unquoted\"] = 1] = \"Unquoted\";\n    QuoteType[QuoteType[\"Single\"] = 2] = \"Single\";\n    QuoteType[QuoteType[\"Double\"] = 3] = \"Double\";\n})(QuoteType || (QuoteType = {}));\n/**\n * Sequences used to match longer strings.\n *\n * We don't have `Script`, `Style`, or `Title` here. Instead, we re-use the *End\n * sequences with an increased offset.\n */\nconst Sequences = {\n    Cdata: new Uint8Array([0x43, 0x44, 0x41, 0x54, 0x41, 0x5b]),\n    CdataEnd: new Uint8Array([0x5d, 0x5d, 0x3e]),\n    CommentEnd: new Uint8Array([0x2d, 0x2d, 0x3e]),\n    ScriptEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74]),\n    StyleEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x74, 0x79, 0x6c, 0x65]),\n    TitleEnd: new Uint8Array([0x3c, 0x2f, 0x74, 0x69, 0x74, 0x6c, 0x65]), // `</title`\n};\nexport default class Tokenizer {\n    constructor({ xmlMode = false, decodeEntities = true, }, cbs) {\n        this.cbs = cbs;\n        /** The current state the tokenizer is in. */\n        this.state = State.Text;\n        /** The read buffer. */\n        this.buffer = \"\";\n        /** The beginning of the section that is currently being read. */\n        this.sectionStart = 0;\n        /** The index within the buffer that we are currently looking at. */\n        this.index = 0;\n        /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */\n        this.baseState = State.Text;\n        /** For special parsing behavior inside of script and style tags. */\n        this.isSpecial = false;\n        /** Indicates whether the tokenizer has been paused. */\n        this.running = true;\n        /** The offset of the current buffer. */\n        this.offset = 0;\n        this.sequenceIndex = 0;\n        this.trieIndex = 0;\n        this.trieCurrent = 0;\n        /** For named entities, the index of the value. For numeric entities, the code point. */\n        this.entityResult = 0;\n        this.entityExcess = 0;\n        this.xmlMode = xmlMode;\n        this.decodeEntities = decodeEntities;\n        this.entityTrie = xmlMode ? xmlDecodeTree : htmlDecodeTree;\n    }\n    reset() {\n        this.state = State.Text;\n        this.buffer = \"\";\n        this.sectionStart = 0;\n        this.index = 0;\n        this.baseState = State.Text;\n        this.currentSequence = undefined;\n        this.running = true;\n        this.offset = 0;\n    }\n    write(chunk) {\n        this.offset += this.buffer.length;\n        this.buffer = chunk;\n        this.parse();\n    }\n    end() {\n        if (this.running)\n            this.finish();\n    }\n    pause() {\n        this.running = false;\n    }\n    resume() {\n        this.running = true;\n        if (this.index < this.buffer.length + this.offset) {\n            this.parse();\n        }\n    }\n    /**\n     * The current index within all of the written data.\n     */\n    getIndex() {\n        return this.index;\n    }\n    /**\n     * The start of the current section.\n     */\n    getSectionStart() {\n        return this.sectionStart;\n    }\n    stateText(c) {\n        if (c === CharCodes.Lt ||\n            (!this.decodeEntities && this.fastForwardTo(CharCodes.Lt))) {\n            if (this.index > this.sectionStart) {\n                this.cbs.ontext(this.sectionStart, this.index);\n            }\n            this.state = State.BeforeTagName;\n            this.sectionStart = this.index;\n        }\n        else if (this.decodeEntities && c === CharCodes.Amp) {\n            this.state = State.BeforeEntity;\n        }\n    }\n    stateSpecialStartSequence(c) {\n        const isEnd = this.sequenceIndex === this.currentSequence.length;\n        const isMatch = isEnd\n            ? // If we are at the end of the sequence, make sure the tag name has ended\n                isEndOfTagSection(c)\n            : // Otherwise, do a case-insensitive comparison\n                (c | 0x20) === this.currentSequence[this.sequenceIndex];\n        if (!isMatch) {\n            this.isSpecial = false;\n        }\n        else if (!isEnd) {\n            this.sequenceIndex++;\n            return;\n        }\n        this.sequenceIndex = 0;\n        this.state = State.InTagName;\n        this.stateInTagName(c);\n    }\n    /** Look for an end tag. For <title> tags, also decode entities. */\n    stateInSpecialTag(c) {\n        if (this.sequenceIndex === this.currentSequence.length) {\n            if (c === CharCodes.Gt || isWhitespace(c)) {\n                const endOfText = this.index - this.currentSequence.length;\n                if (this.sectionStart < endOfText) {\n                    // Spoof the index so that reported locations match up.\n                    const actualIndex = this.index;\n                    this.index = endOfText;\n                    this.cbs.ontext(this.sectionStart, endOfText);\n                    this.index = actualIndex;\n                }\n                this.isSpecial = false;\n                this.sectionStart = endOfText + 2; // Skip over the `</`\n                this.stateInClosingTagName(c);\n                return; // We are done; skip the rest of the function.\n            }\n            this.sequenceIndex = 0;\n        }\n        if ((c | 0x20) === this.currentSequence[this.sequenceIndex]) {\n            this.sequenceIndex += 1;\n        }\n        else if (this.sequenceIndex === 0) {\n            if (this.currentSequence === Sequences.TitleEnd) {\n                // We have to parse entities in <title> tags.\n                if (this.decodeEntities && c === CharCodes.Amp) {\n                    this.state = State.BeforeEntity;\n                }\n            }\n            else if (this.fastForwardTo(CharCodes.Lt)) {\n                // Outside of <title> tags, we can fast-forward.\n                this.sequenceIndex = 1;\n            }\n        }\n        else {\n            // If we see a `<`, set the sequence index to 1; useful for eg. `<</script>`.\n            this.sequenceIndex = Number(c === CharCodes.Lt);\n        }\n    }\n    stateCDATASequence(c) {\n        if (c === Sequences.Cdata[this.sequenceIndex]) {\n            if (++this.sequenceIndex === Sequences.Cdata.length) {\n                this.state = State.InCommentLike;\n                this.currentSequence = Sequences.CdataEnd;\n                this.sequenceIndex = 0;\n                this.sectionStart = this.index + 1;\n            }\n        }\n        else {\n            this.sequenceIndex = 0;\n            this.state = State.InDeclaration;\n            this.stateInDeclaration(c); // Reconsume the character\n        }\n    }\n    /**\n     * When we wait for one specific character, we can speed things up\n     * by skipping through the buffer until we find it.\n     *\n     * @returns Whether the character was found.\n     */\n    fastForwardTo(c) {\n        while (++this.index < this.buffer.length + this.offset) {\n            if (this.buffer.charCodeAt(this.index - this.offset) === c) {\n                return true;\n            }\n        }\n        /*\n         * We increment the index at the end of the `parse` loop,\n         * so set it to `buffer.length - 1` here.\n         *\n         * TODO: Refactor `parse` to increment index before calling states.\n         */\n        this.index = this.buffer.length + this.offset - 1;\n        return false;\n    }\n    /**\n     * Comments and CDATA end with `-->` and `]]>`.\n     *\n     * Their common qualities are:\n     * - Their end sequences have a distinct character they start with.\n     * - That character is then repeated, so we have to check multiple repeats.\n     * - All characters but the start character of the sequence can be skipped.\n     */\n    stateInCommentLike(c) {\n        if (c === this.currentSequence[this.sequenceIndex]) {\n            if (++this.sequenceIndex === this.currentSequence.length) {\n                if (this.currentSequence === Sequences.CdataEnd) {\n                    this.cbs.oncdata(this.sectionStart, this.index, 2);\n                }\n                else {\n                    this.cbs.oncomment(this.sectionStart, this.index, 2);\n                }\n                this.sequenceIndex = 0;\n                this.sectionStart = this.index + 1;\n                this.state = State.Text;\n            }\n        }\n        else if (this.sequenceIndex === 0) {\n            // Fast-forward to the first character of the sequence\n            if (this.fastForwardTo(this.currentSequence[0])) {\n                this.sequenceIndex = 1;\n            }\n        }\n        else if (c !== this.currentSequence[this.sequenceIndex - 1]) {\n            // Allow long sequences, eg. --->, ]]]>\n            this.sequenceIndex = 0;\n        }\n    }\n    /**\n     * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.\n     *\n     * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).\n     * We allow anything that wouldn't end the tag.\n     */\n    isTagStartChar(c) {\n        return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);\n    }\n    startSpecial(sequence, offset) {\n        this.isSpecial = true;\n        this.currentSequence = sequence;\n        this.sequenceIndex = offset;\n        this.state = State.SpecialStartSequence;\n    }\n    stateBeforeTagName(c) {\n        if (c === CharCodes.ExclamationMark) {\n            this.state = State.BeforeDeclaration;\n            this.sectionStart = this.index + 1;\n        }\n        else if (c === CharCodes.Questionmark) {\n            this.state = State.InProcessingInstruction;\n            this.sectionStart = this.index + 1;\n        }\n        else if (this.isTagStartChar(c)) {\n            const lower = c | 0x20;\n            this.sectionStart = this.index;\n            if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {\n                this.startSpecial(Sequences.TitleEnd, 3);\n            }\n            else {\n                this.state =\n                    !this.xmlMode && lower === Sequences.ScriptEnd[2]\n                        ? State.BeforeSpecialS\n                        : State.InTagName;\n            }\n        }\n        else if (c === CharCodes.Slash) {\n            this.state = State.BeforeClosingTagName;\n        }\n        else {\n            this.state = State.Text;\n            this.stateText(c);\n        }\n    }\n    stateInTagName(c) {\n        if (isEndOfTagSection(c)) {\n            this.cbs.onopentagname(this.sectionStart, this.index);\n            this.sectionStart = -1;\n            this.state = State.BeforeAttributeName;\n            this.stateBeforeAttributeName(c);\n        }\n    }\n    stateBeforeClosingTagName(c) {\n        if (isWhitespace(c)) {\n            // Ignore\n        }\n        else if (c === CharCodes.Gt) {\n            this.state = State.Text;\n        }\n        else {\n            this.state = this.isTagStartChar(c)\n                ? State.InClosingTagName\n                : State.InSpecialComment;\n            this.sectionStart = this.index;\n        }\n    }\n    stateInClosingTagName(c) {\n        if (c === CharCodes.Gt || isWhitespace(c)) {\n            this.cbs.onclosetag(this.sectionStart, this.index);\n            this.sectionStart = -1;\n            this.state = State.AfterClosingTagName;\n            this.stateAfterClosingTagName(c);\n        }\n    }\n    stateAfterClosingTagName(c) {\n        // Skip everything until \">\"\n        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {\n            this.state = State.Text;\n            this.sectionStart = this.index + 1;\n        }\n    }\n    stateBeforeAttributeName(c) {\n        if (c === CharCodes.Gt) {\n            this.cbs.onopentagend(this.index);\n            if (this.isSpecial) {\n                this.state = State.InSpecialTag;\n                this.sequenceIndex = 0;\n            }\n            else {\n                this.state = State.Text;\n            }\n            this.baseState = this.state;\n            this.sectionStart = this.index + 1;\n        }\n        else if (c === CharCodes.Slash) {\n            this.state = State.InSelfClosingTag;\n        }\n        else if (!isWhitespace(c)) {\n            this.state = State.InAttributeName;\n            this.sectionStart = this.index;\n        }\n    }\n    stateInSelfClosingTag(c) {\n        if (c === CharCodes.Gt) {\n            this.cbs.onselfclosingtag(this.index);\n            this.state = State.Text;\n            this.baseState = State.Text;\n            this.sectionStart = this.index + 1;\n            this.isSpecial = false; // Reset special state, in case of self-closing special tags\n        }\n        else if (!isWhitespace(c)) {\n            this.state = State.BeforeAttributeName;\n            this.stateBeforeAttributeName(c);\n        }\n    }\n    stateInAttributeName(c) {\n        if (c === CharCodes.Eq || isEndOfTagSection(c)) {\n            this.cbs.onattribname(this.sectionStart, this.index);\n            this.sectionStart = -1;\n            this.state = State.AfterAttributeName;\n            this.stateAfterAttributeName(c);\n        }\n    }\n    stateAfterAttributeName(c) {\n        if (c === CharCodes.Eq) {\n            this.state = State.BeforeAttributeValue;\n        }\n        else if (c === CharCodes.Slash || c === CharCodes.Gt) {\n            this.cbs.onattribend(QuoteType.NoValue, this.index);\n            this.state = State.BeforeAttributeName;\n            this.stateBeforeAttributeName(c);\n        }\n        else if (!isWhitespace(c)) {\n            this.cbs.onattribend(QuoteType.NoValue, this.index);\n            this.state = State.InAttributeName;\n            this.sectionStart = this.index;\n        }\n    }\n    stateBeforeAttributeValue(c) {\n        if (c === CharCodes.DoubleQuote) {\n            this.state = State.InAttributeValueDq;\n            this.sectionStart = this.index + 1;\n        }\n        else if (c === CharCodes.SingleQuote) {\n            this.state = State.InAttributeValueSq;\n            this.sectionStart = this.index + 1;\n        }\n        else if (!isWhitespace(c)) {\n            this.sectionStart = this.index;\n            this.state = State.InAttributeValueNq;\n            this.stateInAttributeValueNoQuotes(c); // Reconsume token\n        }\n    }\n    handleInAttributeValue(c, quote) {\n        if (c === quote ||\n            (!this.decodeEntities && this.fastForwardTo(quote))) {\n            this.cbs.onattribdata(this.sectionStart, this.index);\n            this.sectionStart = -1;\n            this.cbs.onattribend(quote === CharCodes.DoubleQuote\n                ? QuoteType.Double\n                : QuoteType.Single, this.index);\n            this.state = State.BeforeAttributeName;\n        }\n        else if (this.decodeEntities && c === CharCodes.Amp) {\n            this.baseState = this.state;\n            this.state = State.BeforeEntity;\n        }\n    }\n    stateInAttributeValueDoubleQuotes(c) {\n        this.handleInAttributeValue(c, CharCodes.DoubleQuote);\n    }\n    stateInAttributeValueSingleQuotes(c) {\n        this.handleInAttributeValue(c, CharCodes.SingleQuote);\n    }\n    stateInAttributeValueNoQuotes(c) {\n        if (isWhitespace(c) || c === CharCodes.Gt) {\n            this.cbs.onattribdata(this.sectionStart, this.index);\n            this.sectionStart = -1;\n            this.cbs.onattribend(QuoteType.Unquoted, this.index);\n            this.state = State.BeforeAttributeName;\n            this.stateBeforeAttributeName(c);\n        }\n        else if (this.decodeEntities && c === CharCodes.Amp) {\n            this.baseState = this.state;\n            this.state = State.BeforeEntity;\n        }\n    }\n    stateBeforeDeclaration(c) {\n        if (c === CharCodes.OpeningSquareBracket) {\n            this.state = State.CDATASequence;\n            this.sequenceIndex = 0;\n        }\n        else {\n            this.state =\n                c === CharCodes.Dash\n                    ? State.BeforeComment\n                    : State.InDeclaration;\n        }\n    }\n    stateInDeclaration(c) {\n        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {\n            this.cbs.ondeclaration(this.sectionStart, this.index);\n            this.state = State.Text;\n            this.sectionStart = this.index + 1;\n        }\n    }\n    stateInProcessingInstruction(c) {\n        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {\n            this.cbs.onprocessinginstruction(this.sectionStart, this.index);\n            this.state = State.Text;\n            this.sectionStart = this.index + 1;\n        }\n    }\n    stateBeforeComment(c) {\n        if (c === CharCodes.Dash) {\n            this.state = State.InCommentLike;\n            this.currentSequence = Sequences.CommentEnd;\n            // Allow short comments (eg. <!-->)\n            this.sequenceIndex = 2;\n            this.sectionStart = this.index + 1;\n        }\n        else {\n            this.state = State.InDeclaration;\n        }\n    }\n    stateInSpecialComment(c) {\n        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {\n            this.cbs.oncomment(this.sectionStart, this.index, 0);\n            this.state = State.Text;\n            this.sectionStart = this.index + 1;\n        }\n    }\n    stateBeforeSpecialS(c) {\n        const lower = c | 0x20;\n        if (lower === Sequences.ScriptEnd[3]) {\n            this.startSpecial(Sequences.ScriptEnd, 4);\n        }\n        else if (lower === Sequences.StyleEnd[3]) {\n            this.startSpecial(Sequences.StyleEnd, 4);\n        }\n        else {\n            this.state = State.InTagName;\n            this.stateInTagName(c); // Consume the token again\n        }\n    }\n    stateBeforeEntity(c) {\n        // Start excess with 1 to include the '&'\n        this.entityExcess = 1;\n        this.entityResult = 0;\n        if (c === CharCodes.Num) {\n            this.state = State.BeforeNumericEntity;\n        }\n        else if (c === CharCodes.Amp) {\n            // We have two `&` characters in a row. Stay in the current state.\n        }\n        else {\n            this.trieIndex = 0;\n            this.trieCurrent = this.entityTrie[0];\n            this.state = State.InNamedEntity;\n            this.stateInNamedEntity(c);\n        }\n    }\n    stateInNamedEntity(c) {\n        this.entityExcess += 1;\n        this.trieIndex = determineBranch(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c);\n        if (this.trieIndex < 0) {\n            this.emitNamedEntity();\n            this.index--;\n            return;\n        }\n        this.trieCurrent = this.entityTrie[this.trieIndex];\n        const masked = this.trieCurrent & BinTrieFlags.VALUE_LENGTH;\n        // If the branch is a value, store it and continue\n        if (masked) {\n            // The mask is the number of bytes of the value, including the current byte.\n            const valueLength = (masked >> 14) - 1;\n            // If we have a legacy entity while parsing strictly, just skip the number of bytes\n            if (!this.allowLegacyEntity() && c !== CharCodes.Semi) {\n                this.trieIndex += valueLength;\n            }\n            else {\n                // Add 1 as we have already incremented the excess\n                const entityStart = this.index - this.entityExcess + 1;\n                if (entityStart > this.sectionStart) {\n                    this.emitPartial(this.sectionStart, entityStart);\n                }\n                // If this is a surrogate pair, consume the next two bytes\n                this.entityResult = this.trieIndex;\n                this.trieIndex += valueLength;\n                this.entityExcess = 0;\n                this.sectionStart = this.index + 1;\n                if (valueLength === 0) {\n                    this.emitNamedEntity();\n                }\n            }\n        }\n    }\n    emitNamedEntity() {\n        this.state = this.baseState;\n        if (this.entityResult === 0) {\n            return;\n        }\n        const valueLength = (this.entityTrie[this.entityResult] & BinTrieFlags.VALUE_LENGTH) >>\n            14;\n        switch (valueLength) {\n            case 1:\n                this.emitCodePoint(this.entityTrie[this.entityResult] &\n                    ~BinTrieFlags.VALUE_LENGTH);\n                break;\n            case 2:\n                this.emitCodePoint(this.entityTrie[this.entityResult + 1]);\n                break;\n            case 3: {\n                this.emitCodePoint(this.entityTrie[this.entityResult + 1]);\n                this.emitCodePoint(this.entityTrie[this.entityResult + 2]);\n            }\n        }\n    }\n    stateBeforeNumericEntity(c) {\n        if ((c | 0x20) === CharCodes.LowerX) {\n            this.entityExcess++;\n            this.state = State.InHexEntity;\n        }\n        else {\n            this.state = State.InNumericEntity;\n            this.stateInNumericEntity(c);\n        }\n    }\n    emitNumericEntity(strict) {\n        const entityStart = this.index - this.entityExcess - 1;\n        const numberStart = entityStart + 2 + Number(this.state === State.InHexEntity);\n        if (numberStart !== this.index) {\n            // Emit leading data if any\n            if (entityStart > this.sectionStart) {\n                this.emitPartial(this.sectionStart, entityStart);\n            }\n            this.sectionStart = this.index + Number(strict);\n            this.emitCodePoint(replaceCodePoint(this.entityResult));\n        }\n        this.state = this.baseState;\n    }\n    stateInNumericEntity(c) {\n        if (c === CharCodes.Semi) {\n            this.emitNumericEntity(true);\n        }\n        else if (isNumber(c)) {\n            this.entityResult = this.entityResult * 10 + (c - CharCodes.Zero);\n            this.entityExcess++;\n        }\n        else {\n            if (this.allowLegacyEntity()) {\n                this.emitNumericEntity(false);\n            }\n            else {\n                this.state = this.baseState;\n            }\n            this.index--;\n        }\n    }\n    stateInHexEntity(c) {\n        if (c === CharCodes.Semi) {\n            this.emitNumericEntity(true);\n        }\n        else if (isNumber(c)) {\n            this.entityResult = this.entityResult * 16 + (c - CharCodes.Zero);\n            this.entityExcess++;\n        }\n        else if (isHexDigit(c)) {\n            this.entityResult =\n                this.entityResult * 16 + ((c | 0x20) - CharCodes.LowerA + 10);\n            this.entityExcess++;\n        }\n        else {\n            if (this.allowLegacyEntity()) {\n                this.emitNumericEntity(false);\n            }\n            else {\n                this.state = this.baseState;\n            }\n            this.index--;\n        }\n    }\n    allowLegacyEntity() {\n        return (!this.xmlMode &&\n            (this.baseState === State.Text ||\n                this.baseState === State.InSpecialTag));\n    }\n    /**\n     * Remove data that has already been consumed from the buffer.\n     */\n    cleanup() {\n        // If we are inside of text or attributes, emit what we already have.\n        if (this.running && this.sectionStart !== this.index) {\n            if (this.state === State.Text ||\n                (this.state === State.InSpecialTag && this.sequenceIndex === 0)) {\n                this.cbs.ontext(this.sectionStart, this.index);\n                this.sectionStart = this.index;\n            }\n            else if (this.state === State.InAttributeValueDq ||\n                this.state === State.InAttributeValueSq ||\n                this.state === State.InAttributeValueNq) {\n                this.cbs.onattribdata(this.sectionStart, this.index);\n                this.sectionStart = this.index;\n            }\n        }\n    }\n    shouldContinue() {\n        return this.index < this.buffer.length + this.offset && this.running;\n    }\n    /**\n     * Iterates through the buffer, calling the function corresponding to the current state.\n     *\n     * States that are more likely to be hit are higher up, as a performance improvement.\n     */\n    parse() {\n        while (this.shouldContinue()) {\n            const c = this.buffer.charCodeAt(this.index - this.offset);\n            if (this.state === State.Text) {\n                this.stateText(c);\n            }\n            else if (this.state === State.SpecialStartSequence) {\n                this.stateSpecialStartSequence(c);\n            }\n            else if (this.state === State.InSpecialTag) {\n                this.stateInSpecialTag(c);\n            }\n            else if (this.state === State.CDATASequence) {\n                this.stateCDATASequence(c);\n            }\n            else if (this.state === State.InAttributeValueDq) {\n                this.stateInAttributeValueDoubleQuotes(c);\n            }\n            else if (this.state === State.InAttributeName) {\n                this.stateInAttributeName(c);\n            }\n            else if (this.state === State.InCommentLike) {\n                this.stateInCommentLike(c);\n            }\n            else if (this.state === State.InSpecialComment) {\n                this.stateInSpecialComment(c);\n            }\n            else if (this.state === State.BeforeAttributeName) {\n                this.stateBeforeAttributeName(c);\n            }\n            else if (this.state === State.InTagName) {\n                this.stateInTagName(c);\n            }\n            else if (this.state === State.InClosingTagName) {\n                this.stateInClosingTagName(c);\n            }\n            else if (this.state === State.BeforeTagName) {\n                this.stateBeforeTagName(c);\n            }\n            else if (this.state === State.AfterAttributeName) {\n                this.stateAfterAttributeName(c);\n            }\n            else if (this.state === State.InAttributeValueSq) {\n                this.stateInAttributeValueSingleQuotes(c);\n            }\n            else if (this.state === State.BeforeAttributeValue) {\n                this.stateBeforeAttributeValue(c);\n            }\n            else if (this.state === State.BeforeClosingTagName) {\n                this.stateBeforeClosingTagName(c);\n            }\n            else if (this.state === State.AfterClosingTagName) {\n                this.stateAfterClosingTagName(c);\n            }\n            else if (this.state === State.BeforeSpecialS) {\n                this.stateBeforeSpecialS(c);\n            }\n            else if (this.state === State.InAttributeValueNq) {\n                this.stateInAttributeValueNoQuotes(c);\n            }\n            else if (this.state === State.InSelfClosingTag) {\n                this.stateInSelfClosingTag(c);\n            }\n            else if (this.state === State.InDeclaration) {\n                this.stateInDeclaration(c);\n            }\n            else if (this.state === State.BeforeDeclaration) {\n                this.stateBeforeDeclaration(c);\n            }\n            else if (this.state === State.BeforeComment) {\n                this.stateBeforeComment(c);\n            }\n            else if (this.state === State.InProcessingInstruction) {\n                this.stateInProcessingInstruction(c);\n            }\n            else if (this.state === State.InNamedEntity) {\n                this.stateInNamedEntity(c);\n            }\n            else if (this.state === State.BeforeEntity) {\n                this.stateBeforeEntity(c);\n            }\n            else if (this.state === State.InHexEntity) {\n                this.stateInHexEntity(c);\n            }\n            else if (this.state === State.InNumericEntity) {\n                this.stateInNumericEntity(c);\n            }\n            else {\n                // `this._state === State.BeforeNumericEntity`\n                this.stateBeforeNumericEntity(c);\n            }\n            this.index++;\n        }\n        this.cleanup();\n    }\n    finish() {\n        if (this.state === State.InNamedEntity) {\n            this.emitNamedEntity();\n        }\n        // If there is remaining data, emit it in a reasonable way\n        if (this.sectionStart < this.index) {\n            this.handleTrailingData();\n        }\n        this.cbs.onend();\n    }\n    /** Handle any trailing data. */\n    handleTrailingData() {\n        const endIndex = this.buffer.length + this.offset;\n        if (this.state === State.InCommentLike) {\n            if (this.currentSequence === Sequences.CdataEnd) {\n                this.cbs.oncdata(this.sectionStart, endIndex, 0);\n            }\n            else {\n                this.cbs.oncomment(this.sectionStart, endIndex, 0);\n            }\n        }\n        else if (this.state === State.InNumericEntity &&\n            this.allowLegacyEntity()) {\n            this.emitNumericEntity(false);\n            // All trailing data will have been consumed\n        }\n        else if (this.state === State.InHexEntity &&\n            this.allowLegacyEntity()) {\n            this.emitNumericEntity(false);\n            // All trailing data will have been consumed\n        }\n        else if (this.state === State.InTagName ||\n            this.state === State.BeforeAttributeName ||\n            this.state === State.BeforeAttributeValue ||\n            this.state === State.AfterAttributeName ||\n            this.state === State.InAttributeName ||\n            this.state === State.InAttributeValueSq ||\n            this.state === State.InAttributeValueDq ||\n            this.state === State.InAttributeValueNq ||\n            this.state === State.InClosingTagName) {\n            /*\n             * If we are currently in an opening or closing tag, us not calling the\n             * respective callback signals that the tag should be ignored.\n             */\n        }\n        else {\n            this.cbs.ontext(this.sectionStart, endIndex);\n        }\n    }\n    emitPartial(start, endIndex) {\n        if (this.baseState !== State.Text &&\n            this.baseState !== State.InSpecialTag) {\n            this.cbs.onattribdata(start, endIndex);\n        }\n        else {\n            this.cbs.ontext(start, endIndex);\n        }\n    }\n    emitCodePoint(cp) {\n        if (this.baseState !== State.Text &&\n            this.baseState !== State.InSpecialTag) {\n            this.cbs.onattribentity(cp);\n        }\n        else {\n            this.cbs.ontextentity(cp);\n        }\n    }\n}\n//# sourceMappingURL=Tokenizer.js.map"]},"metadata":{},"sourceType":"module"}