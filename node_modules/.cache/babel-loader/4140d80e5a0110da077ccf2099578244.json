{"ast":null,"code":"const Reason = require(\"./reason\");\n\nconst handlers = require(\"./handlers\");\n\nconst utils = require(\"./utils\");\n\nconst override = {\n  timeoutMessage: \"not mined within\",\n  // Substring of timeout err fired by web3\n  defaultWeb3Error: \"please check your gas limit\",\n  // Substring of default Web3 error\n  defaultMaxBlocks: 50,\n  // Max # of blocks web3 will wait for a tx\n  pollingInterval: 1000,\n\n  /**\n   * Attempts to extract receipt object from Web3 error message\n   * @param  {Object} message       web3 error\n   * @return {Object|undefined} receipt\n   */\n  extractReceipt(message) {\n    const hasReceipt = message && message.includes(\"{\");\n    message.includes(\"}\");\n\n    if (hasReceipt) {\n      const receiptString = \"{\" + message.split(\"{\")[1].trim();\n\n      try {\n        return JSON.parse(receiptString);\n      } catch (err) {// ignore\n      }\n    }\n  },\n\n  /**\n   * Fired after web3 ceases to support subscriptions if user has specified\n   * a higher block wait time than web3's 50 blocks limit. Opens a subscription to listen\n   * for new blocks and begins evaluating whether block height has reached the user\n   * defined timeout threshhold. Resolves either a contract instance or a transaction receipt.\n   *\n   * @param  {Object} context execution state\n   * @param  {Object} err     error\n   */\n  start: async function (context, web3Error) {\n    const constructor = this;\n    let currentBlock = override.defaultMaxBlocks; // Reject after attempting to get reason string if we shouldn't be waiting.\n\n    if (!handlers.ignoreTimeoutError(context, web3Error)) {\n      // We might have been routed here in web3 >= beta.34 by their own status check\n      // error. We want to extract the receipt, emit a receipt event\n      // and reject it ourselves.\n      const receipt = override.extractReceipt(web3Error.message);\n\n      if (receipt) {\n        await handlers.receipt(context, receipt);\n        return;\n      } //set up gas for getting reason -- we want it to be a lot, but not infinite\n\n\n      const defaultGas = utils.bigNumberify(Math.floor(context.blockLimit / 2)).toHexString(); // This will run if there's a reason and no status field\n      // e.g: revert with reason ganache --vmErrorsOnRPCResponse=true\n\n      const reason = await Reason.get({ ...context.params,\n        gas: defaultGas\n      }, //don't be gas-limited here!\n      constructor.web3, constructor.interfaceAdapter);\n\n      if (reason) {\n        web3Error.reason = reason;\n        web3Error.message += ` -- Reason given: ${reason}.`;\n      }\n\n      return context.promiEvent.reject(web3Error);\n    } // This will run every block from now until contract.timeoutBlocks\n\n\n    const listener = function (pollID) {\n      currentBlock++;\n\n      if (currentBlock > constructor.timeoutBlocks) {\n        clearInterval(pollID);\n        return;\n      }\n\n      constructor.interfaceAdapter.getTransactionReceipt(context.transactionHash).then(result => {\n        if (!result) return; // make sure reporter receives tx receipt promievent\n\n        handlers.receipt(context, result);\n        result.contractAddress ? constructor.at(result.contractAddress).then(context.promiEvent.resolve).catch(context.promiEvent.reject) : constructor.promiEvent.resolve(result);\n      }).catch(err => {\n        clearInterval(pollID);\n        context.promiEvent.reject(err);\n      });\n    }; // Start polling\n\n\n    let currentPollingBlock = await constructor.interfaceAdapter.getBlockNumber();\n    const pollID = setInterval(async () => {\n      const newBlock = await constructor.interfaceAdapter.getBlockNumber();\n\n      if (newBlock > currentPollingBlock) {\n        currentPollingBlock = newBlock;\n        listener(pollID);\n      }\n    }, override.pollingInterval);\n  }\n};\nmodule.exports = override;","map":{"version":3,"sources":["U:/NFT-Mar/faucet/node_modules/@truffle/contract/lib/override.js"],"names":["Reason","require","handlers","utils","override","timeoutMessage","defaultWeb3Error","defaultMaxBlocks","pollingInterval","extractReceipt","message","hasReceipt","includes","receiptString","split","trim","JSON","parse","err","start","context","web3Error","constructor","currentBlock","ignoreTimeoutError","receipt","defaultGas","bigNumberify","Math","floor","blockLimit","toHexString","reason","get","params","gas","web3","interfaceAdapter","promiEvent","reject","listener","pollID","timeoutBlocks","clearInterval","getTransactionReceipt","transactionHash","then","result","contractAddress","at","resolve","catch","currentPollingBlock","getBlockNumber","setInterval","newBlock","module","exports"],"mappings":"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","sourcesContent":["const Reason = require(\"./reason\");\nconst handlers = require(\"./handlers\");\nconst utils = require(\"./utils\");\n\nconst override = {\n  timeoutMessage: \"not mined within\", // Substring of timeout err fired by web3\n  defaultWeb3Error: \"please check your gas limit\", // Substring of default Web3 error\n  defaultMaxBlocks: 50, // Max # of blocks web3 will wait for a tx\n  pollingInterval: 1000,\n\n  /**\n   * Attempts to extract receipt object from Web3 error message\n   * @param  {Object} message       web3 error\n   * @return {Object|undefined} receipt\n   */\n  extractReceipt(message) {\n    const hasReceipt = message && message.includes(\"{\");\n    message.includes(\"}\");\n\n    if (hasReceipt) {\n      const receiptString = \"{\" + message.split(\"{\")[1].trim();\n      try {\n        return JSON.parse(receiptString);\n      } catch (err) {\n        // ignore\n      }\n    }\n  },\n\n  /**\n   * Fired after web3 ceases to support subscriptions if user has specified\n   * a higher block wait time than web3's 50 blocks limit. Opens a subscription to listen\n   * for new blocks and begins evaluating whether block height has reached the user\n   * defined timeout threshhold. Resolves either a contract instance or a transaction receipt.\n   *\n   * @param  {Object} context execution state\n   * @param  {Object} err     error\n   */\n  start: async function (context, web3Error) {\n    const constructor = this;\n    let currentBlock = override.defaultMaxBlocks;\n\n    // Reject after attempting to get reason string if we shouldn't be waiting.\n    if (!handlers.ignoreTimeoutError(context, web3Error)) {\n      // We might have been routed here in web3 >= beta.34 by their own status check\n      // error. We want to extract the receipt, emit a receipt event\n      // and reject it ourselves.\n      const receipt = override.extractReceipt(web3Error.message);\n      if (receipt) {\n        await handlers.receipt(context, receipt);\n        return;\n      }\n\n      //set up gas for getting reason -- we want it to be a lot, but not infinite\n      const defaultGas = utils\n        .bigNumberify(Math.floor(context.blockLimit / 2))\n        .toHexString();\n\n      // This will run if there's a reason and no status field\n      // e.g: revert with reason ganache --vmErrorsOnRPCResponse=true\n      const reason = await Reason.get(\n        { ...context.params, gas: defaultGas }, //don't be gas-limited here!\n        constructor.web3,\n        constructor.interfaceAdapter\n      );\n      if (reason) {\n        web3Error.reason = reason;\n        web3Error.message += ` -- Reason given: ${reason}.`;\n      }\n\n      return context.promiEvent.reject(web3Error);\n    }\n\n    // This will run every block from now until contract.timeoutBlocks\n    const listener = function (pollID) {\n      currentBlock++;\n\n      if (currentBlock > constructor.timeoutBlocks) {\n        clearInterval(pollID);\n        return;\n      }\n\n      constructor.interfaceAdapter\n        .getTransactionReceipt(context.transactionHash)\n        .then(result => {\n          if (!result) return;\n\n          // make sure reporter receives tx receipt promievent\n          handlers.receipt(context, result);\n          result.contractAddress\n            ? constructor\n                .at(result.contractAddress)\n                .then(context.promiEvent.resolve)\n                .catch(context.promiEvent.reject)\n            : constructor.promiEvent.resolve(result);\n        })\n        .catch(err => {\n          clearInterval(pollID);\n          context.promiEvent.reject(err);\n        });\n    };\n\n    // Start polling\n    let currentPollingBlock =\n      await constructor.interfaceAdapter.getBlockNumber();\n\n    const pollID = setInterval(async () => {\n      const newBlock = await constructor.interfaceAdapter.getBlockNumber();\n\n      if (newBlock > currentPollingBlock) {\n        currentPollingBlock = newBlock;\n        listener(pollID);\n      }\n    }, override.pollingInterval);\n  }\n};\n\nmodule.exports = override;\n"]},"metadata":{},"sourceType":"script"}