{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.abiSelector = exports.abiTypeSignature = exports.abiTupleSignature = exports.abiSignature = exports.ShortSelectorSize = void 0;\n\nconst web3_utils_1 = require(\"web3-utils\");\n\nexports.ShortSelectorSize = 4; //NOTE: this function returns the written out SIGNATURE, not the SELECTOR\n\nfunction abiSignature(abiEntry) {\n  return abiEntry.name + abiTupleSignature(abiEntry.inputs);\n}\n\nexports.abiSignature = abiSignature;\n\nfunction abiTupleSignature(parameters) {\n  const components = parameters.map(abiTypeSignature);\n  return \"(\" + components.join(\",\") + \")\";\n}\n\nexports.abiTupleSignature = abiTupleSignature;\n\nfunction abiTypeSignature(parameter) {\n  const tupleMatch = parameter.type.match(/^tuple(.*)/);\n\n  if (tupleMatch === null) {\n    //does not start with \"tuple\"\n    return parameter.type;\n  } else {\n    const tail = tupleMatch[1]; //everything after \"tuple\"\n\n    const tupleSignature = abiTupleSignature(parameter.components); //it won't be undefined\n\n    return tupleSignature + tail;\n  }\n}\n\nexports.abiTypeSignature = abiTypeSignature;\n\nfunction abiSelector(abiEntry) {\n  const signature = abiSignature(abiEntry); //NOTE: web3's soliditySha3 has a problem if the empty\n  //string is passed in.  Fortunately, that should never happen here.\n\n  const hash = (0, web3_utils_1.soliditySha3)({\n    type: \"string\",\n    value: signature\n  });\n\n  switch (abiEntry.type) {\n    case \"event\":\n      return hash;\n\n    case \"function\":\n    case \"error\":\n      return hash.slice(0, 2 + 2 * exports.ShortSelectorSize);\n    //arithmetic to account for hex string\n  }\n}\n\nexports.abiSelector = abiSelector;","map":{"version":3,"sources":["../../lib/signature.ts"],"names":[],"mappings":";;;;;;;AACA,MAAA,YAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AAEa,OAAA,CAAA,iBAAA,GAAoB,CAApB,C,CAEb;;AACA,SAAgB,YAAhB,CACE,QADF,EACmD;AAEjD,SAAO,QAAQ,CAAC,IAAT,GAAgB,iBAAiB,CAAC,QAAQ,CAAC,MAAV,CAAxC;AACD;;AAJD,OAAA,CAAA,YAAA,GAAA,YAAA;;AAMA,SAAgB,iBAAhB,CAAkC,UAAlC,EAAyD;AACvD,QAAM,UAAU,GAAG,UAAU,CAAC,GAAX,CAAe,gBAAf,CAAnB;AACA,SAAO,MAAM,UAAU,CAAC,IAAX,CAAgB,GAAhB,CAAN,GAA6B,GAApC;AACD;;AAHD,OAAA,CAAA,iBAAA,GAAA,iBAAA;;AAKA,SAAgB,gBAAhB,CAAiC,SAAjC,EAAqD;AACnD,QAAM,UAAU,GAAG,SAAS,CAAC,IAAV,CAAe,KAAf,CAAqB,YAArB,CAAnB;;AACA,MAAI,UAAU,KAAK,IAAnB,EAAyB;AACvB;AACA,WAAO,SAAS,CAAC,IAAjB;AACD,GAHD,MAGO;AACL,UAAM,IAAI,GAAG,UAAU,CAAC,CAAD,CAAvB,CADK,CACuB;;AAC5B,UAAM,cAAc,GAAG,iBAAiB,CACtC,SAAS,CAAC,UAD4B,CAAxC,CAFK,CAIF;;AACH,WAAO,cAAc,GAAG,IAAxB;AACD;AACF;;AAZD,OAAA,CAAA,gBAAA,GAAA,gBAAA;;AAcA,SAAgB,WAAhB,CACE,QADF,EACmD;AAEjD,QAAM,SAAS,GAAG,YAAY,CAAC,QAAD,CAA9B,CAFiD,CAGjD;AACA;;AACA,QAAM,IAAI,GAAG,CAAA,GAAA,YAAA,CAAA,YAAA,EAAa;AAAE,IAAA,IAAI,EAAE,QAAR;AAAkB,IAAA,KAAK,EAAE;AAAzB,GAAb,CAAb;;AACA,UAAQ,QAAQ,CAAC,IAAjB;AACE,SAAK,OAAL;AACE,aAAO,IAAP;;AACF,SAAK,UAAL;AACA,SAAK,OAAL;AACE,aAAO,IAAI,CAAC,KAAL,CAAW,CAAX,EAAc,IAAI,IAAI,OAAA,CAAA,iBAAtB,CAAP;AAAiD;AALrD;AAOD;;AAdD,OAAA,CAAA,WAAA,GAAA,WAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.abiSelector = exports.abiTypeSignature = exports.abiTupleSignature = exports.abiSignature = exports.ShortSelectorSize = void 0;\nconst web3_utils_1 = require(\"web3-utils\");\nexports.ShortSelectorSize = 4;\n//NOTE: this function returns the written out SIGNATURE, not the SELECTOR\nfunction abiSignature(abiEntry) {\n    return abiEntry.name + abiTupleSignature(abiEntry.inputs);\n}\nexports.abiSignature = abiSignature;\nfunction abiTupleSignature(parameters) {\n    const components = parameters.map(abiTypeSignature);\n    return \"(\" + components.join(\",\") + \")\";\n}\nexports.abiTupleSignature = abiTupleSignature;\nfunction abiTypeSignature(parameter) {\n    const tupleMatch = parameter.type.match(/^tuple(.*)/);\n    if (tupleMatch === null) {\n        //does not start with \"tuple\"\n        return parameter.type;\n    }\n    else {\n        const tail = tupleMatch[1]; //everything after \"tuple\"\n        const tupleSignature = abiTupleSignature(parameter.components); //it won't be undefined\n        return tupleSignature + tail;\n    }\n}\nexports.abiTypeSignature = abiTypeSignature;\nfunction abiSelector(abiEntry) {\n    const signature = abiSignature(abiEntry);\n    //NOTE: web3's soliditySha3 has a problem if the empty\n    //string is passed in.  Fortunately, that should never happen here.\n    const hash = (0, web3_utils_1.soliditySha3)({ type: \"string\", value: signature });\n    switch (abiEntry.type) {\n        case \"event\":\n            return hash;\n        case \"function\":\n        case \"error\":\n            return hash.slice(0, 2 + 2 * exports.ShortSelectorSize); //arithmetic to account for hex string\n    }\n}\nexports.abiSelector = abiSelector;\n//# sourceMappingURL=signature.js.map"]},"metadata":{},"sourceType":"script"}